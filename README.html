<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!-- TOC -->
<ul>
<li><a href="#%E9%9B%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">零 基础知识</a>
<ul>
<li><a href="#1-%E5%8D%95%E8%AF%8D">1. 单词</a></li>
<li><a href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AD%E6%B3%95%E5%90%8D%E7%A7%B0%E7%9A%84%E6%9C%AF%E8%AF%AD">2. 常见的语法名称的术语</a>
<ul>
<li><a href="#121-numeric-literals%E6%95%B0%E5%80%BC%E8%AF%AD%E6%B3%95">1.2.1. Numeric Literals（数值语法）</a></li>
<li><a href="#122-%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AF%AD%E6%B3%95">1.2.2. 重点掌握十进制的语法</a></li>
<li><a href="#123-stringnumericliteral">1.2.3. StringNumericLiteral</a></li>
</ul>
</li>
<li><a href="#3-typeof-instanceof">3 typeof, instanceof</a></li>
<li><a href="#4-%E7%94%A8%E4%BA%8E%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0">4. 用于调试的一些函数</a>
<ul>
<li><a href="#41-consolelog%E4%B8%8Econsoledir">4.1. console.log()与console.dir()</a></li>
</ul>
</li>
<li><a href="#5-objectprototypetostringcallobject">5 Object.prototype.toString.call(object)</a></li>
<li><a href="#6-%E7%90%86%E8%A7%A3%E8%BF%99%E6%AE%B5%E8%AF%9D">6 理解这段话</a></li>
<li><a href="#7-object%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">7 Object的一些常用函数</a>
<ul>
<li><a href="#71-objectprototypetostring">7.1 Object.prototype.toString</a></li>
<li><a href="#72-objectkeysobj">7.2 Object.keys(obj)</a></li>
<li><a href="#73-objectassign">7.3 Object.assign()</a></li>
</ul>
</li>
<li><a href="#8-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%8C%E7%B2%BE%E5%BA%A6%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95">8 浮点数双精度的科学计数法</a>
<ul>
<li><a href="#51-%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">5.1 将浮点数转化为二进制科学计数法遇到的问题</a></li>
<li><a href="#52-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%8E%9F%E5%9B%A0%E9%97%AE%E9%A2%98">5.2 常见的解释原因问题</a></li>
</ul>
</li>
<li><a href="#9-%E4%B8%80%E4%BA%9Bjs%E7%9A%84%E7%AE%80%E5%8D%95%E8%A1%A8%E7%A4%BA">9 一些js的简单表示</a></li>
<li><a href="#10-tostring%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%98%93%E9%94%99%E7%82%B9">10 toString函数的一些易错点</a></li>
<li><a href="#11-%E5%8C%BA%E5%88%AB%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">11 区别实例对象与函数对象</a></li>
<li><a href="#12-%E7%9C%8B%E6%87%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">12 看懂数据类型</a></li>
<li><a href="#13-%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">13 两种类型的回调函数</a>
<ul>
<li><a href="#21-%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.1 同步回调函数</a></li>
<li><a href="#22-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.2 异步回调函数</a></li>
</ul>
</li>
<li><a href="#14-js%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Berror">14 js常见的内置类型之Error</a>
<ul>
<li><a href="#141-error%E7%9A%84%E7%B1%BB%E5%9E%8B">14.1 Error的类型</a>
<ul>
<li><a href="#1411-referenceerror">14.1.1 ReferenceError</a></li>
<li><a href="#1412-typeerror">14.1.2 TypeError</a></li>
<li><a href="#1413-rangeerror">14.1.3 RangeError</a></li>
<li><a href="#1414-syntaxerror">14.1.4 SyntaxError</a></li>
</ul>
</li>
<li><a href="#142-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">14.2 错误处理</a>
<ul>
<li><a href="#1421-try%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81catcherror%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">14.2.1 try{执行代码}catch(error){错误处理}</a></li>
<li><a href="#1422-throw-error">14.2.2 throw error</a></li>
</ul>
</li>
<li><a href="#143-%E9%94%99%E8%AF%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">14.3 错误对象的属性</a>
<ul>
<li><a href="#1431-message">14.3.1 message</a></li>
<li><a href="#1432-stack">14.3.2 stack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-%E7%90%86%E8%A7%A3apply-call-bind">15 理解apply, call, bind</a>
<ul>
<li><a href="#151-funcapplythisarg-args">15.1 func.apply(thisArg, [args])</a>
<ul>
<li><a href="#1511-%E7%90%86%E8%A7%A3apply%E7%9A%84%E4%BD%9C%E7%94%A8">15.1.1 理解apply的作用</a></li>
</ul>
</li>
<li><a href="#152-bindfunc1-func2">15.2 bind(func1, func2)</a>
<ul>
<li><a href="#231-%E6%BA%90%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3">2.3.1 源码的理解</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%80-javascript%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86">一 javascript的基础认识</a>
<ul>
<li><a href="#1-%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80">1. 解释型语言</a></li>
<li><a href="#2-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80">2. 动态类型语言</a></li>
<li><a href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3. 应用场景</a></li>
<li><a href="#4-%E7%BC%96%E5%86%99%E4%BD%8D%E7%BD%AE">4. 编写位置</a>
<ul>
<li><a href="#41-%E5%9C%A8html%E5%85%83%E7%B4%A0%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Cjs%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BB%BA%E8%AE%AE">4.1. 在HTML元素中属性直接执行js代码（不建议）</a></li>
<li><a href="#42-%E4%B9%A6%E5%86%99%E5%88%B0script%E6%A0%87%E7%AD%BE%E4%B8%AD">4.2. 书写到script标签中</a></li>
<li><a href="#43-%E4%BB%8E%E5%A4%96%E9%83%A8%E5%BC%95%E5%85%A5js%E6%96%87%E4%BB%B6">4.3. 从外部引入js文件</a></li>
<li><a href="#44-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">4.4. 注意事项</a></li>
</ul>
</li>
<li><a href="#5-js%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B3%A8%E9%87%8A">5. js代码的注释</a></li>
<li><a href="#6-js%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">6. js的内置数据类型数据类型</a></li>
<li><a href="#7-%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%AC%E8%B4%A8">7. 变量存储的本质</a>
<ul>
<li><a href="#71-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB">7.1 内存的分类</a></li>
<li><a href="#72-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%90%84%E9%83%A8%E5%88%86%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%8D%E7%BD%AE">7.2 代码运行时，各部分存储的位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-js%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90">二 js内置数据类型与语法解析</a>
<ul>
<li><a href="#1-js%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">1 js的内置类型</a>
<ul>
<li><a href="#11-%E4%BD%BF%E7%94%A8typeof%E6%9D%A5%E5%88%86%E8%BE%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">1.1 使用typeof来分辨不同的内置类型</a></li>
<li><a href="#12-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3">1.2 基本类型的理解</a>
<ul>
<li><a href="#121-undefined">1.2.1 undefined</a></li>
<li><a href="#1211-undefined%E5%92%8Cundeclared%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.1.1 undefined和undeclared的区别</a></li>
</ul>
</li>
<li><a href="#13-%E6%80%BB%E7%BB%93">1.3 总结</a></li>
</ul>
</li>
<li><a href="#2-js%E7%9A%84%E5%86%85%E7%BD%AE%E5%80%BC%E7%B1%BB%E5%9E%8B">2 js的内置值类型</a>
<ul>
<li><a href="#21-js%E7%9A%84%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8Barray">2.1 js的数组类型(Array)</a>
<ul>
<li><a href="#211-%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B">2.1.1 类数组转化为数组类型</a></li>
<li><a href="#2111-arrayslicecallarraylike">2.1.1.1 Array#slice.call(arrayLike)</a></li>
<li><a href="#2112-slicecallarraylike">2.1.1.2 [].slice.call(arrayLike)</a></li>
<li><a href="#2113-arrayfromarraylikefunc">2.1.1.3 Array.from(arrayLike[,func]);</a></li>
</ul>
</li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8Bstring">2.2 字符串类型(string)</a>
<ul>
<li><a href="#221-%E5%8C%BA%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">2.2.1 区分字符串和字符数组</a></li>
<li><a href="#222-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%9F%E7%94%A8%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD">2.2.2 字符串借用数组类型的函数来实现功能</a></li>
<li><a href="#2221-arrayprototypejoincallstring-%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E7%9A%84%E5%80%BC">2.2.2.1 Array.prototype.join.call(string, 中间插入的值)</a>
<ul>
<li><a href="#2222-arrayprototypemapcallstring-funcjoin">2.2.2.2 Array.prototype.map.call(string, func).join(&quot;&quot;)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8Bnumber">2.3 数字类型(number)</a>
<ul>
<li><a href="#231-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BE%83%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98">2.3.1 数字类型的较小值问题</a>
<ul>
<li><a href="#2311-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AF%AF%E5%B7%AE">2.3.1.1 二进制的误差</a></li>
</ul>
</li>
<li><a href="#2312-numberepsilon">2.3.1.2 Number.EPSILON</a></li>
<li><a href="#232-number%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.3.2 Number常用的属性和方法</a>
<ul>
<li><a href="#2321-numberepsilon">2.3.2.1 Number.EPSILON</a></li>
<li><a href="#2322-numbermax_safe_integer">2.3.2.2 Number.MAX_SAFE_INTEGER</a></li>
<li><a href="#2323-numbermin_safe_integer">2.3.2.3 Number.MIN_SAFE_INTEGER</a></li>
<li><a href="#2324-numbertoexponential">2.3.2.4 Number#toExponential()</a></li>
<li><a href="#2325-numbertofixednum">2.3.2.5 Number#toFixed(num)</a></li>
<li><a href="#2326-numbertoprecisionnum">2.3.2.6 Number#toPrecision(num)</a></li>
<li><a href="#2326-numberisintegernum">2.3.2.6 Number.isInteger(num)</a></li>
<li><a href="#2327-numberissafeintegernum">2.3.2.7 Number.isSafeInteger(num)</a></li>
</ul>
</li>
<li><a href="#233-%E5%AE%9E%E7%8E%B032%E4%B8%BA%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0">2.3.3 实现32为有符号整数</a></li>
<li><a href="#234-%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97number">2.3.4 特殊数字(number)</a>
<ul>
<li><a href="#2341-%E4%B8%8D%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97nan">2.3.4.1 不是数字的数字(NaN)</a>
<ul>
<li><a href="#23411-nan%E4%B8%8E">2.3.4.1.1 NaN与==、===</a></li>
<li><a href="#23412-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E4%B8%8D%E6%98%AFnan%E7%9A%84%E6%96%B9%E6%B3%95----numberisnan">2.3.4.1.2 判断一个值是不是NaN的方法 -- Number.isNaN</a></li>
</ul>
</li>
<li><a href="#2342-%E6%97%A0%E7%A9%B7%E6%95%B0">2.3.4.2 无穷数</a>
<ul>
<li><a href="#23421-js%E4%B8%AD%E9%99%A4%E4%BB%A50%E4%B8%BA%E6%97%A0%E7%A9%B7%E5%80%BC">2.3.4.2.1 js中除以0为无穷值</a></li>
<li><a href="#23422-js%E4%B8%AD%E5%BD%93%E6%89%80%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%80%BC%E8%B6%85%E8%BF%87numbermax_value%E6%97%B6%E4%B8%BA%E6%97%A0%E7%A9%B7%E5%80%BC">2.3.4.2.2 js中当所表示的值超过Number.MAX_VALUE时，为无穷值</a></li>
<li><a href="#23423-js%E4%B8%AD%E6%97%A0%E7%A9%B7%E9%99%A4%E4%BB%A5%E6%97%A0%E7%A9%B7%E4%B8%BAnan">2.3.4.2.3 js中无穷除以无穷为NaN</a></li>
</ul>
</li>
<li><a href="#2343-%E9%9B%B6%E5%80%BC-">2.3.4.3 零值(+/-)</a>
<ul>
<li><a href="#23431--0%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%BA%E5%90%88">2.3.4.3.1 -0出现的场合</a></li>
<li><a href="#23432-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E5%AF%B9-0%E7%9A%84%E5%A4%84%E7%90%86">2.3.4.3.2 常见函数对-0的处理</a></li>
<li><a href="#23433--0%E4%B8%8E0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB">2.3.4.3.3 -0与0之间的大小关系</a></li>
<li><a href="#23434-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E5%80%BC%E6%98%AF-0">2.3.4.3.4 如何判断数值是-0</a></li>
</ul>
</li>
<li><a href="#2343-%E7%89%B9%E6%AE%8A%E7%AD%89%E5%BC%8Fobjectisv1-v2">2.3.4.3 特殊等式Object.is(v1, v2)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#24-%E4%B8%8D%E6%98%AF%E5%80%BC%E7%9A%84%E5%80%BCundefinednull">2.4 不是值的值(undefined,null)</a>
<ul>
<li><a href="#241-undefined%E5%92%8Cnull%E7%9A%84%E5%BC%82%E5%90%8C">2.4.1 undefined和null的异同</a></li>
<li><a href="#242-%E4%BD%9C%E4%B8%BA%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84undefined">2.4.2 作为标识符和变量的undefined</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8">3 数据类型和赋值，引用</a>
<ul>
<li><a href="#31-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">3.1 函数的参数的值传递方式</a></li>
<li><a href="#32-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85">3.2 函数的参数的传递封装对象（对基本类型进行封装）</a></li>
<li><a href="#33-%E6%80%BB%E7%BB%93">3.3 总结</a></li>
</ul>
</li>
<li><a href="#4-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0">4 原生函数</a>
<ul>
<li><a href="#41-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1">4.1 基本类型的封装对象</a></li>
<li><a href="#42-%E6%8B%86%E5%B0%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1">4.2 拆封基本类型的封装对象</a></li>
<li><a href="#43-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85">4.3 原生函数作为构造函数构建对象进行封装</a>
<ul>
<li><a href="#431-array%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.1 Array作为构造函数</a>
<ul>
<li><a href="#4311-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%8F%AA%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BD%9C%E4%B8%BAarray%E7%9A%84%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0">4.3.1.1 为什么不能只用一个数字作为Array的构造参数</a></li>
</ul>
</li>
<li><a href="#432-regexp%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%83%85%E5%86%B5">4.3.2 RegExp作为构造函数的情况</a></li>
<li><a href="#433-date%E5%92%8Cerror%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.3 Date和Error作为构造函数</a>
<ul>
<li><a href="#4331-date%E7%94%A8%E4%BA%8E%E6%A0%B9%E6%8D%AE%E6%97%B6%E9%97%B4%E5%88%9B%E5%BB%BA%E9%9A%8F%E6%9C%BA%E6%95%B0">4.3.3.1 Date用于根据时间创建随机数</a></li>
<li><a href="#4332-error%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.3.2 Error作为构造函数</a></li>
</ul>
</li>
<li><a href="#434-symbol%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.4 Symbol作为构造函数</a>
<ul>
<li><a href="#4341-symbol%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D">4.3.4.1 Symbol类型作为属性名</a>
<ul>
<li><a href="#43411-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84symbol%E5%B1%9E%E6%80%A7">4.3.4.1.1 访问对象的Symbol属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#44-objecttostringcallobj">4.4 Object#toString.call(obj)</a></li>
<li><a href="#45-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B">4.5 原生函数的原型</a>
<ul>
<li><a href="#451-%E6%9C%89%E4%BA%9B%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AF%B9%E8%B1%A1">4.5.1 有些原型对象并不一定是对象</a></li>
</ul>
</li>
<li><a href="#46-%E6%80%BB%E7%BB%93">4.6 总结</a></li>
</ul>
</li>
<li><a href="#5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5 类型转换</a>
<ul>
<li><a href="#51-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.1 类型转换和强制类型转换</a></li>
<li><a href="#52-%E6%95%B0%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%83%E5%B0%94%E5%80%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99">5.2 数值，字符串，布尔值之间的类型转化规则</a>
<ul>
<li><a href="#521-tostring%E8%A7%84%E5%88%99">5.2.1 ToString规则</a>
<ul>
<li><a href="#5211-jsonstringifyobj">5.2.1.1 JSON.stringify(obj)</a></li>
<li><a href="#52111-jsonstringifyobj%E9%92%88%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">5.2.1.1.1 JSON.stringify(obj)针对于对象</a></li>
</ul>
</li>
<li><a href="#522-tonumber%E8%A7%84%E5%88%99">5.2.2 ToNumber规则</a></li>
<li><a href="#523-toboolean%E8%A7%84%E5%88%99">5.2.3 ToBoolean规则</a>
<ul>
<li><a href="#4231-%E5%81%87%E5%80%BC">4.2.3.1 假值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#53-%E6%98%BE%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.3 显式强制类型转换</a>
<ul>
<li><a href="#531-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">5.3.1 其他类型转换为字符串</a>
<ul>
<li><a href="#4311-stringobj">4.3.1.1 String(obj)</a></li>
<li><a href="#4312-objtostring">4.3.1.2 obj.toString()</a></li>
</ul>
</li>
<li><a href="#532-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%80%BC">5.3.2 其他类型转换为数值</a>
<ul>
<li><a href="#5321-numberobj">5.3.2.1 Number(obj)</a></li>
<li><a href="#5322-objtonumber">5.3.2.2 obj.toNumber()</a></li>
<li><a href="#5323-parseintobj-radix-parsefloatobj">5.3.2.3 parseInt(obj, radix), parseFloat(obj)</a></li>
</ul>
</li>
<li><a href="#533-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">5.3.3 其他类型转换为布尔类型</a>
<ul>
<li><a href="#5331-boolean">5.3.3.1 Boolean()</a></li>
<li><a href="#5332-">5.3.3.2 !!</a></li>
</ul>
</li>
<li><a href="#534-%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">5.3.4 特殊符号的类型转化</a>
<ul>
<li><a href="#5341-">5.3.4.1 +</a>
<ul>
<li><a href="#53411-%E8%BF%90%E7%94%A8%E5%8F%B7%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E5%8C%96">5.3.4.1.1 运用+号进行字符串的转化</a></li>
</ul>
</li>
<li><a href="#5342---%E6%95%B4%E6%95%B0">5.3.4.2 ~ + 整数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#54-%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.4 隐式强制类型转换</a>
<ul>
<li><a href="#541-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96">5.4.1 常见的隐式转化</a>
<ul>
<li><a href="#5411-%E5%9C%A8%E6%9C%89%E8%BF%90%E7%AE%97%E7%AC%A6">5.4.1.1 在有运算符+</a></li>
<li><a href="#5412-%E5%9C%A8%E6%9C%89%E8%BF%90%E7%AE%97%E7%AC%A6-">5.4.1.2 在有运算符-</a></li>
<li><a href="#5413-%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%B8%BAboolean%E7%B1%BB%E5%9E%8B">5.4.1.3 隐式转化为Boolean类型</a></li>
<li><a href="#5414-%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96">5.4.1.4 符号类型的隐式转化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#55-%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E4%B8%8E%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96">5.5 宽松相等和严格相等与隐式转化</a>
<ul>
<li><a href="#551-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%84%E5%88%99">5.5.1 ==隐式类型转化的一般规则</a>
<ul>
<li><a href="#4511-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89">4.5.1.1 字符串和数字的宽松相等</a></li>
<li><a href="#4512-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">4.5.1.2 其他类型和布尔类型</a></li>
<li><a href="#4513-null%E5%92%8Cundefined%E7%9A%84%E6%AF%94%E8%BE%83">4.5.1.3 null和undefined的比较</a></li>
<li><a href="#4514-%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83">4.5.1.4 对象和非对象的比较</a></li>
<li><a href="#4515-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5">4.5.1.5 特殊情况</a></li>
</ul>
</li>
<li><a href="#552-%E6%8A%BD%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%AF%94%E8%BE%83">5.5.2 抽象关系比较</a></li>
<li><a href="#553--%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.5.3 == 使用的注意事项</a></li>
</ul>
</li>
<li><a href="#56-%E6%80%BB%E7%BB%93">5.6 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-js%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">三 js的基础语法</a>
<ul>
<li><a href="#1-%E6%95%B0%E7%BB%84">1. 数组</a>
<ul>
<li><a href="#11-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">1.1. 创建数组的两种方法</a></li>
<li><a href="#12-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">1.2 数组元素的增删改查</a>
<ul>
<li><a href="#121-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%B7%BB%E5%8A%A0">1.2.1 数组元素的添加</a></li>
<li><a href="#1211-%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0">1.2.1.1 利用索引直接添加</a></li>
<li><a href="#1212-arraypushval">1.2.1.2 Array#push(...val)</a></li>
<li><a href="#1213-arrayunshiftval">1.2.1.3 Array#unshift(...val)</a></li>
<li><a href="#1214-arrayfillvalstart-end">1.2.1.4 Array#fill(val[start[, end]]);</a></li>
<li><a href="#122-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4">1.2.2 数组元素的删除</a></li>
<li><a href="#1212-arraypop">1.2.1.2 Array#pop()</a></li>
<li><a href="#1213-arrayunshift">1.2.1.3 Array#unshift()</a></li>
<li><a href="#123-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%AE%E6%94%B9">1.2.3 数组元素的修改</a></li>
<li><a href="#124-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">1.2.4 数组元素的访问</a>
<ul>
<li><a href="#1241-index">1.2.4.1 [index]</a></li>
<li><a href="#1242-arrayindexofval">1.2.4.2 Array#indexOf（val)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">1.3 数组的常用函数</a>
<ul>
<li><a href="#131-arraylength">1.3.1 Array.length</a></li>
<li><a href="#132-arrayjoinseparator">1.3.2 Array#join([separator])</a></li>
<li><a href="#133-arraytostring">1.3.3 Array#toString()</a></li>
<li><a href="#134-arrayslicebegin-end">1.3.4 Array#slice([begin, [end]])</a>
<ul>
<li><a href="#1341-%E4%BD%BF%E7%94%A8arrayslice%E5%B0%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84">1.3.4.1 使用Array#slice将类数组转化为数组</a></li>
</ul>
</li>
<li><a href="#135-arraysplicestart-deletecount-item1-item2-">1.3.5 Array#splice(start[, deleteCount[, item1[, item2[, ...]]]])</a>
<ul>
<li><a href="#1351-arraysplice%E7%9A%84%E5%BA%94%E7%94%A8">1.3.5.1 Array#splice的应用</a></li>
</ul>
</li>
<li><a href="#136-arraysortfunc">1.3.6 Array#sort([func])</a></li>
<li><a href="#137-arrayreverse">1.3.7 Array#reverse()</a></li>
<li><a href="#138-arrayconcatvalue1-value2--valuen">1.3.8 Array#concat(value1[, value2[, ...[, valueN]]])</a></li>
</ul>
</li>
<li><a href="#14-%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B">1.4 数组的函数编程</a>
<ul>
<li><a href="#141-arrayforeachcallbackcurrentvalue--index--array-thisarg">1.4.1 Array#forEach(callback(currentValue [, index [, array]])[, thisArg])</a></li>
<li><a href="#142-arraymapcallbackcurrentvalue--index--array-thisarg">1.4.2 Array#map(callback(currentValue [, index [, array]])[, thisArg])</a></li>
<li><a href="#143-arrayfiltercallbackcurrentvalue--index--array-thisarg">1.4.3 Array#filter(callback(currentValue [, index [, array]])[, thisArg])</a></li>
<li><a href="#144-arraysomecallbackelement-index-array-thisarg">1.4.4 Array#some(callback(element[, index[, array]])[, thisArg])</a></li>
<li><a href="#145-arrayeverycallbackelement-index-array-thisarg">1.4.5 Array#every(callback(element[, index[, array]])[, thisArg])</a></li>
<li><a href="#146-arrayreducecallbackaccumulator-currentvalue-index-array-initialvalue">1.4.6 Array#reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</a></li>
</ul>
</li>
<li><a href="#15-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84">1.5. 遍历数组</a></li>
<li><a href="#16-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">1.6. 注意事项</a>
<ul>
<li><a href="#161-%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E8%B5%8B%E5%80%BC">1.6.1. 数组名的赋值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%AF%B9%E8%B1%A1">2. 对象</a>
<ul>
<li><a href="#21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B">2.1. 面向对象的编程</a>
<ul>
<li><a href="#211-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8Bpopprocess-oriented-programming">2.1.1 面向过程的编程(POP)(Process-oriented programming)</a></li>
<li><a href="#212-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boopoject-oriented-programming">2.1.2. 面向对象编程(OOP)(Oject-oriented programming)</a></li>
</ul>
</li>
<li><a href="#22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E7%BB%B4%E7%89%B9%E7%82%B9">2.2. 面向对象编程的思维特点</a></li>
<li><a href="#23-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">2.3. 对象的基本组成</a>
<ul>
<li><a href="#231-%E5%B1%9E%E6%80%A7">2.3.1. 属性</a></li>
<li><a href="#232-%E6%96%B9%E6%B3%95">2.3.2. 方法</a></li>
</ul>
</li>
<li><a href="#24-%E5%AF%B9%E8%B1%A1">2.4 对象</a>
<ul>
<li><a href="#241-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F">2.4.1 对象的定义形式</a></li>
<li><a href="#242-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB">2.4.2 对象的分类</a>
<ul>
<li><a href="#2421-%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1">2.4.2.1 普通对象</a></li>
<li><a href="#2422-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">2.4.2.2 类的实例对象</a></li>
</ul>
</li>
<li><a href="#243-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9">2.4.3 对象的属性访问和修改</a>
<ul>
<li><a href="#2431-%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">2.4.3.1 属性访问</a></li>
<li><a href="#2432-%E9%94%AE%E5%80%BC%E8%AE%BF%E9%97%AE">2.4.3.2 键值访问</a></li>
</ul>
</li>
<li><a href="#244-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%93%8D%E4%BD%9C">2.4.4 理解对象属性访问的默认操作</a>
<ul>
<li>[2.4.4.1 <a href="%E7%94%A8%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE">[ Get ]</a>](#2441--get-)</li>
<li><a href="#2442--put-%E7%94%A8%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%A2%9E%E5%92%8C%E4%BF%AE%E6%94%B9">2.4.4.2 [[ Put ]]（用于属性的新增和修改）</a></li>
<li><a href="#2443-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7">2.4.4.3 如何判断是否具有某个属性</a></li>
</ul>
</li>
<li><a href="#245-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6">2.4.5 对象的复制</a>
<ul>
<li><a href="#2451-%E6%B5%85%E5%A4%8D%E5%88%B6">2.4.5.1 浅复制</a></li>
<li><a href="#2452-%E6%B7%B1%E5%A4%8D%E5%88%B6">2.4.5.2 深复制</a></li>
</ul>
</li>
<li><a href="#246-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6">2.4.6 对象的属性描述符</a>
<ul>
<li><a href="#2461-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C">2.4.6.1 对对象属性特性的操作</a>
<ul>
<li><a href="#24611-objectdefineproperty">2.4.6.1.1 Object.defineProperty()</a></li>
</ul>
</li>
<li><a href="#2462-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7">2.4.6.2 对象属性的不变性</a>
<ul>
<li><a href="#24621-%E5%AF%B9%E8%B1%A1%E5%B8%B8%E9%87%8F">2.4.6.2.1 对象常量</a></li>
</ul>
</li>
<li><a href="#2463-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7">2.4.6.3 对象的不变性</a>
<ul>
<li><a href="#24631-objectpreventextensionsobj">2.4.6.3.1 Object.preventExtensions(obj)</a></li>
<li><a href="#24632-objectsealobj">2.4.6.3.2 Object.seal(obj)</a></li>
<li><a href="#24633-objectfreezeobj">2.4.6.3.3 Object.freeze(obj)</a></li>
</ul>
</li>
<li><a href="#2464-%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98">2.4.6.4 不可枚举属性的问题</a>
<ul>
<li><a href="#24641-objpropertyisenumerableprop">2.4.6.4.1 obj.propertyIsEnumerable(prop)</a></li>
<li><a href="#24642-objectgetpropertysymbolsobj">2.4.6.4.2 Object.getPropertySymbols(obj)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#247-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86">2.4.7 对象的遍历</a>
<ul>
<li><a href="#2471-objectkeysobj">2.4.7.1 Object.keys(obj)</a></li>
<li><a href="#2472-objectgetownpropertynamesobj">2.4.7.2 Object.getOwnPropertyNames(obj)</a></li>
<li><a href="#2473-forinkey">2.4.7.3 for...in...(key)</a></li>
<li><a href="#2474-forofvalue">2.4.7.4 for...of...(value)</a></li>
</ul>
</li>
<li><a href="#248-%E6%80%BB%E7%BB%93">2.4.8 总结</a></li>
</ul>
</li>
<li><a href="#25-%E7%B1%BB">2.5 类</a>
<ul>
<li><a href="#251-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0">2.5.1. 类的构造</a>
<ul>
<li><a href="#2511-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2.5.1.1 通过函数构造类（构造函数）</a></li>
<li><a href="#2512-%E9%80%9A%E8%BF%87class%E6%9E%84%E9%80%A0%E7%B1%BB">2.5.1.2 通过class构造类</a></li>
</ul>
</li>
<li><a href="#252-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E9%80%9A%E8%BF%87new%E6%9E%84%E9%80%A0%E7%9A%84%E5%AF%B9%E8%B1%A1">2.5.2 类的实例对象（通过new构造的对象）</a>
<ul>
<li><a href="#2521-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">2.5.2.1. 类的实例对象的成员类型(实例成员，静态成员)</a></li>
</ul>
</li>
<li><a href="#253-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E8%B4%A8">2.5.3 类的实例对象的实质</a></li>
<li><a href="#254-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%99">2.5.4. 类的实例对象的方法查询规则</a></li>
<li><a href="#255-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5 类的继承</a>
<ul>
<li><a href="#2551-%E5%8E%9F%E5%9E%8B%E9%93%BE">2.5.5.1. 原型链</a>
<ul>
<li><a href="#25511-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%9D%A5%E5%AF%BB%E6%89%BE%E7%9B%B8%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95">2.5.5.1.1 实例对象是如何通过原型链来寻找相应的方法?</a></li>
</ul>
</li>
<li><a href="#2552-%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%BC%95%E8%B5%B7%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%B1%8F%E8%94%BD">2.5.5.2 原型链引起的属性设置和屏蔽</a>
<ul>
<li><a href="#25521-%E5%B1%9E%E6%80%A7%E5%B1%8F%E8%94%BD">2.5.5.2.1 属性屏蔽</a></li>
<li><a href="#25522-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%BF%87%E7%A8%8Bmyobjectprop--value">2.5.5.2.2 属性设置的过程（myObject.prop = value)</a></li>
<li><a href="#25523-%E5%B1%9E%E6%80%A7%E5%B1%8F%E8%94%BD%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9--%E9%9A%90%E5%BC%8F%E5%B1%8F%E8%94%BD">2.5.5.2.3 属性屏蔽和属性设置的易错点--隐式屏蔽</a></li>
</ul>
</li>
<li><a href="#2553-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5.3 通过构造函数实现类的继承</a>
<ul>
<li><a href="#25521-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8sonprototypeproto--fatherprototype%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5.2.1 为什么不能使用Son.prototype.<strong>proto</strong> = Father.prototype来实现原型链的继承</a></li>
<li><a href="#25522-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8sonprototype--new-father">2.5.5.2.2 为什么不能使用Son.prototype = new Father()</a></li>
<li><a href="#25523-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8sonprototype--father">2.5.5.2.3 为什么不能使用Son.prototype = Father</a></li>
<li><a href="#25524-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5.2.4 如何实现父类静态成员的继承？</a></li>
</ul>
</li>
<li><a href="#2554-%E9%80%9A%E8%BF%87class%E4%B8%AD%E7%9A%84extends%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">2.5.5.4 通过class中的extends实现继承</a>
<ul>
<li><a href="#25531-class%E4%B8%AD%E7%9A%84super%E5%AF%B9%E8%B1%A1">2.5.5.3.1 class中的super对象</a></li>
<li><a href="#25532-class%E4%B8%AD%E7%9A%84static%E5%87%BD%E6%95%B0">2.5.5.3.2 class中的static函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#256-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">2.5.6 类的基本认识</a></li>
<li><a href="#257-%E7%B1%BB%E7%9A%84%E6%98%93%E6%B7%B7%E7%82%B9">2.5.7 类的易混点</a>
<ul>
<li><a href="#2571-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB">2.5.7.1 类的实例对象和类的关系</a>
<ul>
<li><a href="#25711-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%9C%AC%E8%B4%A8">2.5.7.1.1 类的实例的本质</a></li>
<li><a href="#25712-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF">2.5.7.1.2 原型继承</a></li>
<li><a href="#25713-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7constructor%E6%9C%AC%E8%B4%A8">2.5.7.1.3 类的实例对象的不可枚举属性constructor本质</a></li>
</ul>
</li>
<li><a href="#2572-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8">2.5.7.2 构造函数的本质</a></li>
<li><a href="#2573-instanceof%E5%88%A4%E6%96%AD%E7%9A%84%E5%AE%9E%E8%B4%A8%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0">2.5.7.3 instanceof判断的实质（对象与函数）</a></li>
<li><a href="#2574-%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B9%8B%E4%B8%AD">2.5.7.4 判断某个对象是否出现在另一个对象的原型链之中</a></li>
<li><a href="#2575-%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE">2.5.7.5 获取某个对象的原型链</a>
<ul>
<li><a href="#25751-objectgetprototypeofobj">2.5.7.5.1 Object.getPrototypeOf(obj)</a></li>
<li><a href="#25752-objproto">2.5.7.5.2 obj.<strong>proto</strong></a></li>
</ul>
</li>
<li><a href="#2576-%E6%80%BB%E7%BB%93">2.5.7.6 总结</a></li>
</ul>
</li>
<li><a href="#258-%E6%B3%A8%E6%84%8F">2.5.8 注意</a>
<ul>
<li><a href="#2581-%E4%BC%9A%E6%A3%80%E6%9F%A5%E6%89%80%E6%9C%89%E5%9C%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7">2.5.8.1 会检查所有在原型链上的属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E5%87%BD%E6%95%B0">3 函数</a>
<ul>
<li><a href="#31-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">3.1. 函数的定义</a>
<ul>
<li><a href="#311-%E5%87%BD%E6%95%B0%E7%9A%84%E5%91%BD%E5%90%8D%E5%86%99%E6%B3%95%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0">3.1.1. 函数的命名写法（命名函数）</a></li>
<li><a href="#312-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">3.1.2. 函数的表达式写法（匿名函数）</a></li>
</ul>
</li>
<li><a href="#32-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">3.2. 函数的参数传递</a>
<ul>
<li><a href="#321-%E5%BD%A2%E5%8F%82">3.2.1. 形参</a></li>
<li><a href="#322-%E5%AE%9E%E5%8F%82">3.2.2. 实参</a></li>
<li><a href="#323-%E5%BD%A2%E5%8F%82%E5%8F%98%E9%87%8F%E4%B8%AA%E6%95%B0%E5%92%8C%E5%AE%9E%E5%8F%82%E5%8F%98%E9%87%8F%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">3.2.3. 形参变量个数和实参变量个数的关系</a>
<ul>
<li><a href="#3231-arguments%E5%AF%B9%E8%B1%A1%E7%8E%B0%E5%9C%A8%E5%BE%88%E5%B0%91%E7%94%A8%E4%BA%86">3.2.3.1. arguments对象(现在很少用了)</a>
<ul>
<li><a href="#32311-%E7%89%B9%E7%82%B91">3.2.3.1.1. 特点1</a></li>
<li><a href="#32312-%E7%89%B9%E7%82%B92">3.2.3.1.2. 特点2</a></li>
<li><a href="#32313-%E7%89%B9%E7%82%B93">3.2.3.1.3. 特点3</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#324-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">3.2.4. 函数参数的值传递和引用传递</a>
<ul>
<li><a href="#3241-%E5%80%BC%E4%BC%A0%E9%80%92">3.2.4.1. 值传递</a></li>
<li><a href="#3242-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">3.2.4.2. 引用传递</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#33-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8">3.3. 函数的调用</a>
<ul>
<li><a href="#331-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%A0%88">3.3.1. 函数的调用栈</a></li>
<li><a href="#332-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8">3.3.2. 普通函数的调用</a></li>
<li><a href="#333-%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E7%9A%84%E8%B0%83%E7%94%A8%E5%BD%A2%E5%BC%8F">3.3.3 函数的特殊的调用形式</a></li>
<li><a href="#334-%E9%80%9A%E8%BF%87%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%B0%83iife">3.3.4. 通过立即调用函数进行调（IIFE）</a>
<ul>
<li><a href="#3341-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A7%84%E8%8C%83">3.3.4.1. 函数声明的立即调用函数规范</a>
<ul>
<li><a href="#32542-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%90%8E%E9%9D%A2%E5%A2%9E%E5%8A%A0%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%9A%84%E7%AB%8B%E5%8D%B3%E5%AE%9E%E8%A1%8C">3.2.5.4.2. 函数的表达式写法可以在后面增加参数列表从而实现函数的立即实行</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#34-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">3.4. 函数的返回值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B-js%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">四 JS的知识补充</a>
<ul>
<li><a href="#1-%E4%BD%9C%E7%94%A8%E5%9F%9F">1 作用域</a>
<ul>
<li><a href="#11-%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F">1.1 理解作用域</a>
<ul>
<li><a href="#111-%E8%AE%A4%E8%AF%86%E4%B8%89%E4%B8%AA%E5%AF%B9%E8%AF%9D%E7%9A%84%E9%83%A8%E5%88%86">1.1.1 认识三个对话的部分</a></li>
<li><a href="#112-%E5%AF%B9%E8%AF%9D%E7%9A%84%E8%BF%87%E7%A8%8B">1.1.2 对话的过程</a></li>
<li><a href="#113-js%E5%BC%95%E6%93%8E%E6%9F%A5%E8%AF%A2%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95">1.1.3 js引擎查询变量的方法</a></li>
<li><a href="#114-%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE">1.1.4 理解变量的访问</a></li>
</ul>
</li>
<li><a href="#12-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97">1.2 作用域嵌套</a></li>
<li><a href="#13-%E6%80%BB%E7%BB%93-1">1.3 总结</a></li>
<li><a href="#14-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F">1.4 词法作用域</a>
<ul>
<li><a href="#141-%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95">1.4.1 欺骗词法</a>
<ul>
<li><a href="#1411-eval">1.4.1.1 eval()</a></li>
</ul>
</li>
<li><a href="#142-%E6%80%BB%E7%BB%93">1.4.2 总结</a></li>
</ul>
</li>
<li><a href="#15-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F">1.5 函数作用域</a>
<ul>
<li><a href="#151-%E4%BD%9C%E7%94%A81%E9%9A%90%E8%97%8F%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">1.5.1 作用1：隐藏内部实现</a></li>
<li><a href="#152-%E4%BD%9C%E7%94%A82%E8%A7%84%E9%81%BF%E5%86%B2%E7%AA%81">1.5.2 作用2：规避冲突</a></li>
<li><a href="#153-%E4%BD%9C%E7%94%A83%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">1.5.3 作用3：全局命名空间</a></li>
<li><a href="#154-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.5.4 函数声明和函数表达式</a></li>
<li><a href="#154-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.5.4 立即执行函数表达式</a></li>
</ul>
</li>
<li><a href="#16-%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6 块作用域</a>
<ul>
<li><a href="#161-var%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8D%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6.1 var声明的变量不具有块级作用域</a></li>
<li><a href="#162-trycatch%E7%9A%84err%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6.2 try...catch的err具有块级作用域</a></li>
<li><a href="#163-letconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6.3 let/const声明的变量具有块级作用域</a>
<ul>
<li><a href="#1631-%E5%9C%A8if%E8%AF%AD%E5%8F%A5%E4%B8%AD">1.6.3.1 在if语句中</a></li>
<li><a href="#1632-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%AD">1.6.3.2 垃圾回收中</a></li>
<li><a href="#1633-let%E5%BE%AA%E7%8E%AF">1.6.3.3 let循环</a></li>
</ul>
</li>
<li><a href="#164-%E6%80%BB%E7%BB%93">1.6.4 总结</a></li>
</ul>
</li>
<li><a href="#17-%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87">1.7 声明的提升</a>
<ul>
<li><a href="#171-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86">1.7.1 编译器对代码的处理</a></li>
<li><a href="#172-%E6%8F%90%E5%8D%87">1.7.2 提升</a></li>
<li><a href="#173-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">1.7.3 函数声明和变量声明的优先级</a></li>
<li><a href="#174-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.7.4 函数声明不具有块级作用域</a></li>
<li><a href="#175-%E6%80%BB%E7%BB%93">1.7.5 总结</a></li>
</ul>
</li>
<li><a href="#18-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%97%AD%E5%8C%85">1.8 作用域的闭包</a>
<ul>
<li><a href="#181-%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85">1.8.1 理解闭包</a></li>
<li><a href="#182-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E8%B4%A8">1.8.2 闭包的实质</a></li>
<li><a href="#183-%E9%97%AD%E5%8C%85%E7%9A%84%E9%80%9A%E5%B8%B8%E5%BD%A2%E5%BC%8F">1.8.3 闭包的通常形式</a></li>
<li><a href="#184-%E9%97%AD%E5%8C%85%E7%9A%84%E8%BF%90%E7%94%A8">1.8.4 闭包的运用</a>
<ul>
<li><a href="#1841-%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%97%AD%E5%8C%85">1.8.4.1 循环和闭包</a></li>
<li><a href="#1842-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97">1.8.4.2 实现模块</a></li>
</ul>
</li>
<li><a href="#185-%E6%80%BB%E7%BB%93">1.8.5 总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-this%E7%9A%84%E7%90%86%E8%A7%A3">2 this的理解</a>
<ul>
<li><a href="#21-this%E7%9A%84%E5%AE%9E%E8%B4%A8">2.1 this的实质</a></li>
<li><a href="#22-%E7%A1%AE%E5%AE%9Athis%E6%89%80%E6%8C%87%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">2.2 确定this所指的对象的方法</a>
<ul>
<li><a href="#221-%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%AF%BB%E6%89%BE%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%BD%93%E5%89%8D%E7%9A%84%E8%B0%83%E7%94%A8%E6%A0%88">2.2.1 第一步：寻找调用位置和当前的调用栈</a></li>
<li><a href="#222-%E7%AC%AC%E4%BA%8C%E6%AD%A5%E6%A0%B9%E6%8D%AEthis%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99%E6%9D%A5%E7%A1%AE%E5%AE%9A%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AF%B9%E8%B1%A1">2.2.2 第二步：根据this的绑定规则来确定绑定的对象</a>
<ul>
<li><a href="#2221-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A">2.2.2.1 默认绑定</a></li>
<li><a href="#2222-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A">2.2.2.2 隐式绑定</a>
<ul>
<li><a href="#22221-%E9%9A%90%E5%BC%8F%E4%B8%A2%E5%A4%B1">2.2.2.2.1 隐式丢失</a></li>
</ul>
</li>
<li><a href="#2223-%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A">2.2.2.3 显示绑定</a></li>
<li><a href="#2224-new%E7%BB%91%E5%AE%9A">2.2.2.4 new绑定</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#23-this%E7%9A%84%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96">2.3 this的绑定例外</a>
<ul>
<li><a href="#231-%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84this">2.3.1 被忽略的this</a></li>
<li><a href="#232-%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%8C%85%E6%8B%AC%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92">2.3.2 间接引用(包括函数参数的传递)</a></li>
<li><a href="#233-%E8%BD%AF%E7%BB%91%E5%AE%9Aobjsoftbind">2.3.3 软绑定(obj.softBind(..))</a></li>
<li><a href="#234-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">2.3.4 箭头函数</a></li>
</ul>
</li>
<li><a href="#24-%E6%80%BB%E7%BB%93">2.4 总结</a></li>
</ul>
</li>
<li><a href="#3-%E6%9C%89%E5%85%B3%E7%B1%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">3 有关类的三种不同设计模式</a>
<ul>
<li><a href="#31-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E5%BC%8F">3.1 使用构造函数的模式</a></li>
<li><a href="#32-%E4%BD%BF%E7%94%A8class%E6%A8%A1%E5%BC%8F">3.2 使用class模式</a></li>
<li><a href="#33-%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE%E7%9A%84%E6%A8%A1%E5%BC%8F">3.3 使用事件委派的模式</a></li>
</ul>
</li>
<li><a href="#4-%E8%AF%AD%E6%B3%95">4 语法</a>
<ul>
<li><a href="#41-%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.1 语句和表达式</a>
<ul>
<li><a href="#411-%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BB%93%E6%9E%9C%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E">4.1.1 语句的结果值的隐式返回</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94-js%E7%9A%84dom%E6%93%8D%E4%BD%9C">五 js的DOM操作</a>
<ul>
<li><a href="#1-domdocument-object-model">1. DOM(document Object Model)</a>
<ul>
<li><a href="#12-dom%E6%A0%91">1.2. DOM树</a></li>
<li><a href="#13-%E8%8A%82%E7%82%B9node">1.3. 节点(node)</a>
<ul>
<li><a href="#131-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%86%E7%B1%BB">1.3.1. 节点的分类</a>
<ul>
<li><a href="#1311-%E6%96%87%E6%A1%A3%E8%8A%82%E7%82%B9document">1.3.1.1. 文档节点(document)</a></li>
<li><a href="#1311-%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9">1.3.1.1. 元素节点</a></li>
<li><a href="#1311-%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9">1.3.1.1. 属性节点</a></li>
<li><a href="#1311-%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9">1.3.1.1. 文本节点</a></li>
</ul>
</li>
<li><a href="#132-%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7">1.3.2. 节点的属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-dom%E6%96%B9%E6%B3%95">2 DOM方法</a>
<ul>
<li><a href="#21-dom-document%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.1 DOM document属性和方法</a>
<ul>
<li><a href="#211-document%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">2.1.1 document获取元素对象的方法</a>
<ul>
<li><a href="#2111-documentgetelementsbyclassnamenames">2.1.1.1 document.getElementsByClassName(names)</a></li>
<li><a href="#2112-documentgetelementsbytagnametagnames">2.1.1.2 document.getElementsByTagName(tagNames)</a></li>
<li><a href="#2113-documentgetelementbyidid">2.1.1.3 document.getElementById(id)</a></li>
<li><a href="#2114-documentgetelementsbynamenames">2.1.1.4 document.getElementsByName(names)</a></li>
<li><a href="#2115-documentqueryselectorcssselector">2.1.1.5 document.querySelector(cssSelector)</a></li>
<li><a href="#2116-documentqueryselectorallcssselector">2.1.1.6 document.querySelectorAll(cssSelector)</a></li>
</ul>
</li>
<li><a href="#212-document%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7">2.1.2 document常用的属性</a>
<ul>
<li><a href="#2121-documentbody">2.1.2.1 document.body</a></li>
<li><a href="#2122-documentall">2.1.2.2 document.all</a></li>
<li><a href="#2123-documentdoucumentelement">2.1.2.3 document.doucumentElement</a></li>
</ul>
</li>
<li><a href="#213-doucment%E4%B8%8E%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7">2.1.3 doucment与增加元素对象相关的属性</a>
<ul>
<li><a href="#2131-documentcreateelementtagname">2.1.3.1 document.createElement(tagName)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#22-dom-element%E6%96%B9%E6%B3%95">2.2 DOM Element方法</a>
<ul>
<li><a href="#221-element%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">2.2.1 element获取元素对象的方法</a>
<ul>
<li><a href="#2211-elementgetelementsbyclassnamenames">2.2.1.1 element.getElementsByClassName(names)</a></li>
<li><a href="#2212-elementgetelementsbytagnametagnames">2.2.1.2 element.getElementsByTagName(tagNames)</a></li>
<li><a href="#2113-elementqueryselectorcssselector">2.1.1.3 element.querySelector(cssSelector)</a></li>
<li><a href="#2114-elementmatchescssselector">2.1.1.4 element.matches(cssSelector)</a></li>
<li><a href="#2114-elementqueryselectorallcssselector">2.1.1.4 element.querySelectorAll(cssSelector)</a></li>
</ul>
</li>
<li><a href="#222-element%E4%B8%8E%E7%88%B6%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%AD%90%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%85%84%E5%BC%9F%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.2.2 element与父元素对象，子元素对象，兄弟元素对象有关的属性和方法</a>
<ul>
<li><a href="#2221-elementparentnode">2.2.2.1 element.parentNode</a>
<ul>
<li><a href="#22211-parentnodechildelementcount">2.2.2.1.1 parentNode.childElementCount</a></li>
<li><a href="#22212-parentnodechildren">2.2.2.1.2 parentNode.children</a></li>
<li><a href="#22213-parentnodefirstelementchild">2.2.2.1.3 parentNode.firstElementChild</a></li>
<li><a href="#22214-parentnodelastelementchild">2.2.2.1.4 parentNode.lastElementChild</a></li>
<li><a href="#22215-parentnodeappendnode">2.2.2.1.5 parentNode.append(...node)</a></li>
<li><a href="#22215-parentnodeprependnode">2.2.2.1.5 parentNode.prepend(node)</a></li>
</ul>
</li>
<li><a href="#2222-elementchildnode">2.2.2.2 element.childNode</a>
<ul>
<li><a href="#22221-childnoderemove">2.2.2.2.1 childNode.remove()</a></li>
</ul>
</li>
<li><a href="#2223-elementpreviouselementsibling%E5%8F%AA%E8%AF%BB">2.2.2.3 element.previousElementSibling（只读）</a></li>
<li><a href="#2224-elementnextelementsibling%E5%8F%AA%E8%AF%BB">2.2.2.4 element.nextElementSibling（只读）</a></li>
<li><a href="#2225-elementclosestselectors">2.2.2.5 element.closest(selectors)</a></li>
</ul>
</li>
<li><a href="#223-element%E4%B8%8E%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.2.3 element与增加元素对象相关的属性和方法</a>
<ul>
<li><a href="#2231-parentnodeappendnode">2.2.3.1 parentNode.append(...node)</a></li>
<li><a href="#2232-parentnodeprependnode">2.2.3.2 parentNode.prepend(node)</a></li>
<li><a href="#2233-parentnodereplacechildrennewchild-oldchild">2.2.3.3 parentNode.replaceChildren(newChild, oldChild)</a></li>
<li><a href="#2234-childnodereplacewithnode">2.2.3.4 childNode.replaceWith(...node)</a></li>
<li><a href="#2235-childnoderemove">2.2.3.5 childNode.remove()</a></li>
<li><a href="#2236-elementinsertadjacentelementposition-newelement">2.2.3.6 element.insertAdjacentElement(position, newElement)</a></li>
<li><a href="#2236-elementinsertadjacenthtmlposition-text">2.2.3.6 element.insertAdjacentHTML(position, text)</a></li>
</ul>
</li>
<li><a href="#224-element%E4%B8%8E%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%96%B9%E6%B3%95">2.2.4 element与元素属性相关的属性及方法</a>
<ul>
<li><a href="#2241-elementnodenametagname">2.2.4.1 element.nodeName/tagName</a></li>
<li><a href="#2242-elementid">2.2.4.2 element.id</a></li>
<li><a href="#2243-elementattributes%E5%8F%AA%E8%AF%BB">2.2.4.3 element.attributes（只读）</a></li>
<li><a href="#2244-elementinnerhtml">2.2.4.4 element.innerHTML</a></li>
<li><a href="#2245-elementouterhtml">2.2.4.5 element.outerHTML</a>
<ul>
<li><a href="#22411-%E7%94%A8%E4%BA%8E%E6%9B%BF%E6%8D%A2%E5%BD%93%E5%89%8D%E7%9A%84%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1">2.2.4.1.1 用于替换当前的元素对象</a></li>
</ul>
</li>
<li><a href="#2246-elementinnertext">2.2.4.6 element.innerText</a></li>
<li><a href="#2247-elementclassname">2.2.4.7 element.className</a></li>
<li><a href="#2248-elementclasslist%E5%8F%AA%E8%AF%BB">2.2.4.8 element.classList（只读）</a>
<ul>
<li><a href="#22431-classlistaddclassvalue">2.2.4.3.1 classList.add(...classValue)</a></li>
<li><a href="#22432-classlistremoveclassvalue">2.2.4.3.2 classList.remove(...classValue)</a></li>
<li><a href="#22433-classlisttoggleclassvalue">2.2.4.3.3 classList.toggle(classValue)</a></li>
</ul>
</li>
<li><a href="#2249-elementgetattributeattrnamestring%E5%8F%AA%E8%AF%BB">2.2.4.9 element.getAttribute(attrName:string)（只读）</a></li>
<li><a href="#22410-elementgetattributenames">2.2.4.10 element.getAttributeNames()</a></li>
<li><a href="#22411-elementhasattributeattrnamestring">2.2.4.11 element.hasAttribute(attrName:string)</a></li>
<li><a href="#22411-elementremoveattributeattrnamestring">2.2.4.11 element.removeAttribute(attrName:string)</a></li>
<li><a href="#22412-elementsetattributeattrnamestring-attrvaluestring">2.2.4.12 element.setAttribute(attrName:string, attrValue:string)</a></li>
<li><a href="#22413-elementtoggleattributeattrname-force">2.2.4.13 element.toggleAttribute(attrName[, force])</a></li>
</ul>
</li>
<li><a href="#225-element%E4%B8%8E%E6%A0%B7%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.2.5 element与样式相关的属性和方法</a>
<ul>
<li><a href="#2251-elementclientheight-width%E5%8F%AA%E8%AF%BB">2.2.5.1 element.client[Height, Width]（只读）</a></li>
<li><a href="#2252-elementclientleft-top%E5%8F%AA%E8%AF%BB">2.2.5.2 element.client[Left, Top]（只读）</a></li>
<li><a href="#2253-elementscrollheight-width%E5%8F%AA%E8%AF%BB">2.2.5.3 element.scroll[Height, Width]（只读）</a></li>
<li><a href="#2254-elementscrollleft-top">2.2.5.4 element.scroll[Left, Top]</a></li>
<li><a href="#2255-elementattname-%E8%8E%B7%E5%8F%96%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7">2.2.5.5 element.[attName] （获取内联样式属性）</a>
<ul>
<li><a href="#22551-elementvalue">2.2.5.5.1 element.value</a></li>
</ul>
</li>
<li><a href="#2256-elementstyleattrname">2.2.5.6 element.style.[attrName]</a>
<ul>
<li><a href="#22561-elementstylebackgroundcolor">2.2.5.6.1 element.style.backgroundColor</a></li>
</ul>
</li>
<li><a href="#2257-%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%98%AF%E5%90%A6%E5%88%B0%E5%BA%95">2.2.5.7 实现判断滚动条是否到底</a></li>
</ul>
</li>
<li><a href="#22410">2.2.4.10</a></li>
</ul>
</li>
<li><a href="#23-dom%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%82%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98">2.3 DOM的版本适应的问题</a>
<ul>
<li><a href="#6123-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E5%80%BC">6.1.2.3. 获取元素节点对象的行内样式属性值</a>
<ul>
<li><a href="#61233-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F">6.1.2.3.3. 获取元素节点对象的样式表中的样式</a>
<ul>
<li><a href="#612331-%E7%94%B1%E4%BA%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">6.1.2.3.3.1. 由于兼容性，需要自定义一个函数</a></li>
<li><a href="#612332-getcomputedstyleelementobject-pseudoelements">6.1.2.3.3.2. getComputedStyle(elementObject, pseudoElements)</a></li>
<li><a href="#612333-objectelementcurrentstyle%E6%A0%B7%E5%BC%8F%E5%90%8D">6.1.2.3.3.3. objectElement.currentStyle.样式名</a></li>
</ul>
</li>
<li><a href="#61241-%E4%BB%A5%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">6.1.2.4.1. 以父元素为对象的操作</a>
<ul>
<li><a href="#612411-documentcreateelementtagstr">6.1.2.4.1.1. document.createElement(tagStr)</a></li>
<li><a href="#612412-documentcreatetextnodestr">6.1.2.4.1.2. document.createTextNode(str)</a></li>
<li><a href="#612413-fathernodeobjectappendchildchildnodeobject">6.1.2.4.1.3. fatherNodeObject.appendChild(childNodeObject)</a></li>
<li><a href="#612414-fathernodeobjectinsertbeforenewchildobject-oldchildobject">6.1.2.4.1.4. fatherNodeObject.insertBefore(newchildObject, oldchildObject)</a></li>
<li><a href="#612415-fathernodeobjectreplacechildnewchildobject-oldchildobject">6.1.2.4.1.5. fatherNodeObject.replaceChild(newchildObject, oldchildObject)</a></li>
<li><a href="#612416-fathernodeobjectremovechildchildobject">6.1.2.4.1.6. fatherNodeObject.removeChild(childObject)</a></li>
<li><a href="#612417-%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BD%BF%E7%94%A8createelement">6.1.2.4.1.7. 元素对象的增加的步骤（使用createElement）</a></li>
<li><a href="#612418-%E4%BD%BF%E7%94%A8innerhtml%E5%AF%B9%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%8A%A0">6.1.2.4.1.8. 使用innerHTML对元素进行增加</a></li>
<li><a href="#612419-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%BB%93%E5%90%88%E5%AF%B9%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%B7%BB%E5%8A%A0%E6%8E%A8%E8%8D%90">6.1.2.4.1.9. 两种方式结合对元素进行添加(推荐)</a></li>
<li><a href="#6124110-%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A0%E9%99%A4%E7%9A%84%E6%AD%A5%E9%AA%A4%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84">6.1.2.4.1.10. 元素对象的删除的步骤（经常使用的）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-dom%E4%BA%8B%E4%BB%B6">3 DOM事件</a>
<ul>
<li><a href="#30-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86">3.0 事件的一些基本常识</a>
<ul>
<li><a href="#301-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%AC%E5%85%B1%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">3.0.1 事件的公共属性和方法</a>
<ul>
<li><a href="#3011-eventtarget">3.0.1.1 event.target</a></li>
<li><a href="#3012-eventcurrenttarget">3.0.1.2 event.currentTarget</a></li>
<li><a href="#3013-eventbubbles">3.0.1.3 event.bubbles</a></li>
<li><a href="#3014-eventcancelable">3.0.1.4 event.cancelable</a></li>
<li><a href="#3015-eventtype">3.0.1.5 event.type</a></li>
<li><a href="#3016-eventstoppropagation">3.0.1.6 event.stopPropagation()</a></li>
<li><a href="#3017-eventpreventdefault">3.0.1.7 event.preventDefault()</a></li>
</ul>
</li>
<li><a href="#302-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8F%96%E6%B6%88%E7%9A%84%E6%96%B9%E6%B3%95%E6%96%B9%E6%B3%95">3.0.2 事件与元素的绑定和取消的方法方法</a>
<ul>
<li><a href="#3020-%E5%9C%A8%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%B1%9E%E6%80%A7oneventname--callback">3.0.2.0 在内联样式中增加属性on[eventName] = &quot;callback()&quot;</a></li>
<li><a href="#3021-elementoneventname--function-">3.0.2.1 element.on[eventName] = function() {}</a></li>
<li><a href="#3022-elementoneventname--null">3.0.2.2 element.on[eventName] = null</a></li>
<li><a href="#3023-elementaddeventlistenereventnamestring-func-true--false">3.0.2.3 element.addEventListener(eventName:string, func, [true || false])</a></li>
<li><a href="#3024-elementremoveeventlistenereventnamestring-func-true--false">3.0.2.4 element.removeEventListener(eventName:string, func, [true || false])</a></li>
<li><a href="#3025-elementattacheventoneventnamestring-func">3.0.2.5 element.attachEvent(on[eventName]:string, func)</a></li>
<li><a href="#3025-%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">3.0.2.5 通用的事件绑定函数</a></li>
</ul>
</li>
<li><a href="#303-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD">3.0.3 事件的传播</a>
<ul>
<li><a href="#3031-%E9%9D%9E%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6">3.0.3.1 非冒泡事件</a></li>
<li><a href="#3032-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6">3.0.3.2 冒泡事件</a>
<ul>
<li><a href="#30321-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD">3.0.3.2.1 冒泡事件的传播</a></li>
<li><a href="#30322-eventstoppropagation%E7%9A%84%E5%BA%94%E7%94%A8">3.0.3.2.2 event.stopPropagation()的应用</a></li>
<li><a href="#30323-%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE">3.0.3.2.3 利用冒泡事件实现事件委派</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#31-%E5%89%AA%E8%B4%B4%E7%89%88%E4%BA%8B%E4%BB%B6clipboardevent">3.1 剪贴版事件（ClipboardEvent）</a>
<ul>
<li><a href="#311-%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95clipboardevent">3.1.1 剪贴板事件的属性和方法(ClipboardEvent)</a></li>
</ul>
</li>
<li><a href="#32-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6focusevent">3.2 焦点事件(FocusEvent)</a>
<ul>
<li><a href="#321-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95focusevent">3.2.1 焦点事件的属性和方法(FocusEvent)</a></li>
</ul>
</li>
<li><a href="#33-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6">3.3 键盘事件</a>
<ul>
<li><a href="#331-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95keyboardevent">3.3.1 键盘事件的属性和方法(KeyboardEvent)</a></li>
</ul>
</li>
<li><a href="#34-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6">3.4 鼠标事件</a>
<ul>
<li><a href="#341-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95mouseevent">3.4.1 鼠标事件的属性和方法(MouseEvent)</a></li>
</ul>
</li>
<li><a href="#35-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6">3.5 触摸事件</a>
<ul>
<li><a href="#340-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B">3.4.0 触摸事件的类型</a></li>
<li><a href="#341-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95touchevent">3.4.1 触摸事件的属性和方法(TouchEvent)</a></li>
<li><a href="#342-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3.4.2 触摸事件的注意事项</a></li>
</ul>
</li>
<li><a href="#36-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6wheelevent">3.6 滚轮事件（WheelEvent)</a>
<ul>
<li><a href="#361-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95wheelevent">3.6.1 滚轮事件的属性和方法(WheelEvent)</a></li>
<li><a href="#362-wheel%E7%9A%84%E5%8E%86%E5%8F%B2">3.6.2 wheel的历史</a></li>
</ul>
</li>
<li><a href="#37-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A6%81%E5%AD%A6%E4%BC%9A%E7%9A%84%E5%BA%94%E7%94%A8">3.7 事件的一些要学会的应用</a>
<ul>
<li><a href="#371-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%AD%90%E7%9B%92%E5%92%8C%E7%88%B6%E7%9B%92%E7%9A%84%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96">3.7.1 冒泡事件实现子盒和父盒的颜色变化</a>
<ul>
<li><a href="#3711-%E5%88%A9%E7%94%A8eventstoppropagation">3.7.1.1 利用event.stopPropagation()</a></li>
<li><a href="#3712-%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%87%BA%E5%8F%91%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8D%B3eventtarget%E7%9A%84%E4%B8%8D%E5%90%8C">3.7.1.2 利用冒泡事件的出发元素的不同（即event.target的不同）</a></li>
</ul>
</li>
<li><a href="#372-%E5%AE%9E%E7%8E%B0%E5%85%A8%E9%80%89%E6%A1%86">3.7.2 实现全选框</a></li>
<li><a href="#373-%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E6%8B%96%E6%8B%BD">3.7.3 实现元素的拖拽</a>
<ul>
<li><a href="#3731-%E6%8B%96%E6%8B%BD%E6%97%B6%E9%BC%A0%E6%A0%87%E4%BD%8D%E4%BA%8E%E5%B7%A6%E4%B8%8A%E8%A7%92">3.7.3.1 拖拽时鼠标位于左上角</a></li>
<li><a href="#3732-%E6%8B%96%E6%8B%BD%E4%BD%8D%E7%BD%AE%E4%BD%8D%E4%BA%8E%E9%BC%A0%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%88%9A%E5%BC%80%E5%A7%8B%E7%82%B9%E5%87%BB%E7%9A%84%E4%BD%8D%E7%BD%AE">3.7.3.2 拖拽位置位于鼠标位置刚开始点击的位置</a></li>
<li><a href="#3733-%E5%8F%96%E6%B6%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E9%80%A0%E6%88%90%E6%8B%96%E6%8B%BD%E7%9A%84bug">3.7.3.3 取消浏览器的默认行为造成拖拽的bug</a></li>
<li><a href="#3734-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%AA%E6%8B%96%E6%8B%BD%E5%87%BD%E6%95%B0">3.7.3.4 总结一个拖拽函数</a></li>
</ul>
</li>
<li><a href="#374-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E7%94%A8">3.7.4 滚轮事件的运用</a></li>
<li><a href="#375-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E7%94%A8">3.7.5 键盘事件的运用</a>
<ul>
<li><a href="#3751-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%8C%89%E9%94%AE%E7%9A%84%E5%88%A4%E6%96%AD">3.7.5.1 实现两个按键的判断</a></li>
<li><a href="#3672-%E9%99%90%E5%88%B6input%E6%A1%86%E7%9A%84%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9">3.6.7.2 限制input框的输入内容</a></li>
<li><a href="#3673-div%E5%85%83%E7%B4%A0%E7%9A%84%E7%A7%BB%E5%8A%A8">3.6.7.3 div元素的移动</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#38-%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98">3.8 与事件相关的兼容性问题</a>
<ul>
<li><a href="#381-%E8%8E%B7%E5%8F%96%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98">3.8.1 获取样式表中属性值的兼容性问题</a></li>
<li><a href="#382-event%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92">3.8.2 event参数的传递</a></li>
<li><a href="#383-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95">3.8.3 绑定事件的兼容性写法</a></li>
<li><a href="#6131-elementobjectclientwidth-elementobjectclientheight">6.1.3.1. elementObject.clientWidth, elementObject.clientHeight</a></li>
<li><a href="#6132-elementobjectoffsetwidth-elementobjectoffsetheight">6.1.3.2. elementObject.offsetWidth, elementObject.offsetHeight</a></li>
<li><a href="#6133-elementobjectoffsetparent">6.1.3.3. elementObject.offsetParent</a></li>
<li><a href="#6134-elementobjectoffsetleftright-elementobjectoffsettopbuttom">6.1.3.4. elementObject.offset[Left,right], elementObject.offset[Top,buttom]</a></li>
<li><a href="#6135-elementobjectscrollwidth-elementobjectscrollheight">6.1.3.5. elementObject.scrollWidth, elementObject.scrollHeight</a></li>
<li><a href="#6136-elementobjectscrollleft-elementobjectscrolltop">6.1.3.6. elementObject.scrollLeft, elementObject.scrollTop</a></li>
<li><a href="#6137-elementobjectscrollheight-elementobjectscrolltop%E5%92%8Celementobjectclientheight%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">6.1.3.7. elementObject.scrollHeight, elementObject.scrollTop和elementObject.clientHeight的结合使用</a></li>
<li><a href="#6264-elementobjectonmousewheel">6.2.6.4. elementObject.onmousewheel</a></li>
</ul>
</li>
<li><a href="#38-%E6%96%87%E6%A1%A3%E7%9A%84%E5%8A%A0%E8%BD%BD">3.8. 文档的加载</a>
<ul>
<li><a href="#381-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%A1%BA%E5%BA%8F">3.8.1 浏览器加载页面的顺序</a></li>
<li><a href="#382-onload%E4%BA%8B%E4%BB%B6">3.8.2 onload事件</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%AD-js%E7%9A%84bom%E6%93%8D%E4%BD%9C">六 js的BOM操作</a>
<ul>
<li><a href="#61-bombrower-object-model">6.1. BOM(brower Object Model)</a></li>
<li><a href="#62-bom%E7%9A%84%E5%AF%B9%E8%B1%A1">6.2. BOM的对象</a>
<ul>
<li><a href="#621-window">6.2.1. Window</a>
<ul>
<li><a href="#6211-window%E6%96%B9%E6%B3%95">6.2.1.1. Window方法</a>
<ul>
<li><a href="#62111-alertstr">6.2.1.1.1. alert(str)</a></li>
<li><a href="#62112-promptstr">6.2.1.1.2. prompt(str)</a></li>
<li><a href="#62113-comfirmstr">6.2.1.1.3. comfirm(str)</a></li>
<li><a href="#62114-setintervalcallback-time">6.2.1.1.4. setInterval(callback, time)</a></li>
<li><a href="#62115-clearintervalintervalid">6.2.1.1.5. clearInterval(intervalId)</a></li>
<li><a href="#62116-settimeoutcallback-time">6.2.1.1.6. setTimeout(callback, time)</a></li>
<li><a href="#62117-cleartimeouttimeoutid">6.2.1.1.7. clearTimeout(timeoutId)</a></li>
<li><a href="#62118-%E5%BB%B6%E6%97%B6%E8%B0%83%E7%94%A8%E5%92%8C%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB">6.2.1.1.8. 延时调用和定时调用的关系</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#622-navigator">6.2.2. Navigator</a>
<ul>
<li><a href="#6221-navigator%E7%9A%84%E5%B1%9E%E6%80%A7">6.2.2.1. Navigator的属性</a>
<ul>
<li><a href="#72211-navigatoruseragent">7.2.2.1.1. navigator.userAgent</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#623-location">6.2.3. Location</a>
<ul>
<li><a href="#6231-localtion">6.2.3.1. localtion</a>
<ul>
<li><a href="#72311-location%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E4%BC%BCa%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7">7.2.3.1.1. location实现元素对象的类似a标签的属性</a></li>
</ul>
</li>
<li><a href="#6232-location%E7%9A%84%E5%B1%9E%E6%80%A7">6.2.3.2. location的属性</a></li>
<li><a href="#6233-location%E7%9A%84%E6%96%B9%E6%B3%95">6.2.3.3. Location的方法</a>
<ul>
<li><a href="#62331-locationassignurl">6.2.3.3.1. location.assign(URL);</a></li>
<li><a href="#62332-locationreload">6.2.3.3.2. location.reload();</a></li>
<li><a href="#62333-locationreplaceurl">6.2.3.3.3. location.replace(URL)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#624-history">6.2.4. History</a>
<ul>
<li><a href="#6241-history%E7%9A%84%E5%B1%9E%E6%80%A7">6.2.4.1. History的属性</a>
<ul>
<li><a href="#62411-historylength">6.2.4.1.1. history.length</a></li>
</ul>
</li>
<li><a href="#6242-history%E7%9A%84%E6%96%B9%E6%B3%95">6.2.4.2. History的方法</a>
<ul>
<li><a href="#62421-historyback">6.2.4.2.1. history.back()</a></li>
<li><a href="#62422-historyforward">6.2.4.2.2. history.forward()</a></li>
<li><a href="#62423-historygon">6.2.4.2.3. history.go(n)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#625-screen">6.2.5. Screen</a></li>
<li><a href="#626-bom%E7%9A%84%E5%BA%94%E7%94%A8">6.2.6. Bom的应用</a>
<ul>
<li><a href="#6261-%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2">6.2.6.1. 图片切换</a></li>
<li><a href="#6262-%E8%A7%A3%E5%86%B3div%E7%A7%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%AE%E5%92%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%94%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E9%98%B2%E8%AF%AF%E8%A7%A6">6.2.6.2. 解决div移动第一个键和第二个键之间的延迟问题（防误触）</a></li>
<li><a href="#6263-%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0">6.2.6.3. 构造一个简单的动画函数</a></li>
<li><a href="#6264-%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0">6.2.6.4. 轮播图效果的实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%83-js%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">七 js的迭代器</a></li>
<li><a href="#%E5%85%AB-promise">八 Promise</a>
<ul>
<li><a href="#1-promised%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3">1 Promised的基本理解</a>
<ul>
<li><a href="#11-promise%E7%9A%84%E7%90%86%E8%A7%A3">1.1 promise的理解</a></li>
<li><a href="#12-promise%E7%9A%84%E7%8A%B6%E6%80%81">1.2 promise的状态</a></li>
<li><a href="#13-promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">1.3. promise的基本使用流程</a></li>
<li><a href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8promise">1.4. 为什么使用promise</a>
<ul>
<li><a href="#141-%E6%8C%87%E5%AE%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB">1.4.1 指定回调函数的方式更加灵活</a></li>
<li><a href="#142-%E6%94%AF%E6%8C%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E9%97%AE%E9%A2%98">1.4.2 支持链式调用,可以解决回调地狱的问题</a>
<ul>
<li><a href="#1421-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1">1.4.2.1 回调地狱</a></li>
<li><a href="#1422-%E5%88%A9%E7%94%A8promise%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E9%97%AE%E9%A2%98">1.4.2.2 利用Promise的链式调用解决回调地狱的问题</a></li>
<li><a href="#1423-%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E6%9C%80%E7%BB%88%E6%96%B9%E6%A1%88">1.4.2.3 解决回调地狱的最终方案</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-promise%E7%9A%84api">1.5 promise的API</a>
<ul>
<li><a href="#51-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1 基本语法</a></li>
<li><a href="#52-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">5.2 函数对象的方法</a>
<ul>
<li><a href="#521-promisealliterable">5.2.1 Promise.all(iterable))</a></li>
<li><a href="#522-promiseraceiterable">5.2.2 Promise.race(iterable)</a></li>
<li><a href="#523-promiseresolvevalue">5.2.3 Promise.resolve(value)</a></li>
<li><a href="#524-promiserejectreason">5.2.4 Promise.reject(reason)</a></li>
</ul>
</li>
<li><a href="#53-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">5.3 实例对象的方法</a>
<ul>
<li><a href="#531-promiseprototypethenonfulfilled-onrejected">5.3.1 Promise.prototype.then(onFulfilled[, onRejected])</a></li>
<li><a href="#532-promiseprototypecatchonrejected">5.3.2 Promise.prototype.catch(onRejected)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-promise%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98">1.6 promise的几个关键问题</a>
<ul>
<li><a href="#161-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98promise%E7%9A%84%E7%8A%B6%E6%80%81">1.6.1 如何改变promise的状态</a></li>
<li><a href="#162-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E6%95%B0%E6%8D%AE">1.6.2 什么时候可以得到数据?</a></li>
<li><a href="#163-%E7%90%86%E8%A7%A3promise%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5">1.6.3 理解promise中的同步异步</a></li>
<li><a href="#164-promisethen%E8%BF%94%E5%9B%9E%E6%96%B0%E7%9A%84promise%E7%9A%84%E7%BB%93%E6%9E%9C%E7%8A%B6%E6%80%81%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E7%9A%84">1.6.4 promise.then()返回新的promise的结果状态由什么决定的</a></li>
<li><a href="#165-promise%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">1.6.5 promise如何串联多个异步任务</a></li>
<li><a href="#166-promise%E7%9A%84%E5%BC%82%E5%B8%B8%E7%A9%BF%E9%80%8F">1.6.6 promise的异常穿透</a></li>
<li><a href="#167-%E4%B8%AD%E6%96%ADpromise%E9%93%BE">1.6.7 中断promise链</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E6%89%8B%E5%86%99promise">2 手写promise</a>
<ul>
<li><a href="#21-%E5%AE%9A%E4%B9%89%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84">2.1 定义整体结构</a></li>
<li><a href="#22-%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2.2. 定义构造函数</a></li>
</ul>
</li>
<li><a href="#3-async%E5%92%8Cawait%E4%BD%BF%E7%94%A8">3 async和await使用</a>
<ul>
<li><a href="#31-async-%E5%87%BD%E6%95%B0">3.1 async 函数</a></li>
<li><a href="#32-await-%E8%A1%A8%E8%BE%BE%E5%BC%8F">3.2 await 表达式</a></li>
<li><a href="#33-%E6%B3%A8%E6%84%8F">3.3 注意</a></li>
</ul>
</li>
<li><a href="#4-%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97">4 宏队列和微队列</a>
<ul>
<li><a href="#41-%E5%8E%9F%E7%90%86%E5%9B%BE">4.1 原理图</a></li>
<li><a href="#42-js%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%A7%A6%E5%8F%91%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%94%BE%E5%85%A5%E4%BA%86%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97">4.2 js的异步任务的触发函数什么时候放入了对应的异步执行队列？</a></li>
<li><a href="#43-js%E7%9A%84%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">4.3 js的异步执行流程</a></li>
</ul>
</li>
<li><a href="#5-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">5 常见面试题</a>
<ul>
<li><a href="#51-%E8%AE%A4%E6%B8%85%E6%A5%9A%E5%93%AA%E4%BA%9B%E6%98%AF%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%93%AA%E4%BA%9B%E6%98%AF%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81">5.1 认清楚哪些是异步回调函数,哪些是同步代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B9%9D-axios">九 axios</a>
<ul>
<li><a href="#1-http%E7%9A%84%E7%90%86%E8%A7%A3">1 http的理解</a>
<ul>
<li><a href="#11-http%E8%AF%B7%E6%B1%82%E4%BA%A4%E4%BA%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">1.1 http请求交互的基本过程</a></li>
<li><a href="#12-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">1.2 http请求报文</a>
<ul>
<li><a href="#121-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90">1.2.1 请求报文的组成</a>
<ul>
<li><a href="#1211-%E8%AF%B7%E6%B1%82%E8%A1%8C">1.2.1.1 请求行</a>
<ul>
<li><a href="#11111-method%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">1.1.1.1.1 method(请求方法)</a></li>
<li><a href="#11112-url">1.1.1.1.2 URL</a></li>
<li><a href="#11113-%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC">1.1.1.1.3 协议版本</a></li>
</ul>
</li>
<li><a href="#1212-%E8%AF%B7%E6%B1%82%E5%A4%B4">1.2.1.2 请求头</a>
<ul>
<li><a href="#12121-user-agent">1.2.1.2.1 User-Agent</a></li>
<li><a href="#12122-accipt">1.2.1.2.2 Accipt</a></li>
<li><a href="#12123-accept-language">1.2.1.2.3 Accept-Language</a></li>
<li><a href="#12124-accept-encoding">1.2.1.2.4 Accept-Encoding</a></li>
<li><a href="#12125-accept-charset">1.2.1.2.5 Accept-Charset</a></li>
<li><a href="#12126-host">1.2.1.2.6 Host</a></li>
<li><a href="#12127-connection">1.2.1.2.7 connection</a></li>
<li><a href="#12128-cookie">1.2.1.2.8 Cookie</a></li>
</ul>
</li>
<li><a href="#1213-%E7%A9%BA%E8%A1%8C">1.2.1.3 空行</a></li>
<li><a href="#1214-%E8%AF%B7%E6%B1%82%E5%8C%85%E4%BD%93">1.2.1.4 请求包体</a></li>
</ul>
</li>
<li><a href="#122-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8C%85%E4%BD%93content-type%E4%BB%A5%E5%8F%8Aaxios%E7%9A%84config%E7%9A%84%E5%85%B3%E7%B3%BB">1.2.2 请求方法与请求包体Content-type以及axios的config的关系</a></li>
</ul>
</li>
<li><a href="#13-http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">1.3 http响应报文</a>
<ul>
<li><a href="#131-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90">1.3.1 响应报文的组成</a>
<ul>
<li><a href="#1311-%E7%8A%B6%E6%80%81%E8%A1%8C">1.3.1.1 状态行</a>
<ul>
<li><a href="#13111-http%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5">1.3.1.1.1 http协议字段</a></li>
<li><a href="#13112-%E7%8A%B6%E6%80%81%E7%A0%81">1.3.1.1.2 状态码</a></li>
<li><a href="#13113-%E7%8A%B6%E6%80%81%E7%A0%81%E6%8F%8F%E8%BF%B0%E6%96%87%E6%9C%AC">1.3.1.1.3 状态码描述文本</a></li>
</ul>
</li>
<li><a href="#1312-%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8">1.3.1.2 响应头部</a>
<ul>
<li><a href="#13121-location">1.3.1.2.1 Location</a></li>
<li><a href="#13122-server">1.3.1.2.2 Server</a></li>
<li><a href="#13123-vary">1.3.1.2.3 Vary</a></li>
<li><a href="#13124-vary">1.3.1.2.4 Vary</a></li>
<li><a href="#13125-connection">1.3.1.2.5 Connection</a></li>
</ul>
</li>
<li><a href="#1313-%E7%A9%BA%E8%A1%8C">1.3.1.3 空行</a></li>
<li><a href="#1314-%E5%93%8D%E5%BA%94%E5%8C%85%E4%BD%93">1.3.1.4 响应包体</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#14-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">1.4 基础知识补充</a>
<ul>
<li><a href="#141-connection%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">1.4.1 Connection在不同报文中的作用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8F%90%E4%BE%9B%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84api%E5%88%86%E7%B1%BB">2 服务器提供给客户端的API分类</a>
<ul>
<li><a href="#21-%E5%88%86%E7%B1%BB%E4%BE%9D%E6%8D%AE">2.1 分类依据</a></li>
<li><a href="#22-%E7%B1%BB%E5%9E%8B">2.2 类型</a>
<ul>
<li><a href="#221-rest-apirestful">2.2.1 REST API（restful）</a></li>
<li><a href="#222-%E9%9D%9E-rest-apirestless">2.2.2 非 REST API(restless)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E6%90%AD%E5%BB%BA%E5%85%B7%E6%9C%89rest-api%E7%9A%84%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95">3 搭建具有REST API的简单服务器用于测试</a></li>
<li><a href="#4-ajax%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80--xhr">4 AJAX编程的基础--XHR</a>
<ul>
<li><a href="#41-xhr%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">4.1. XHR的基本定义</a></li>
<li><a href="#42-xhr%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">4.2 XHR的基本使用</a>
<ul>
<li><a href="#421-xhr%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.2.1 XHR的构造函数</a></li>
<li><a href="#423-xhr%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%BB%8E%E5%BB%BA%E7%AB%8B%E5%88%B0%E6%8E%A5%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%8F%98%E5%8C%96">4.2.3 XHR实例对象从建立到接收到数据状态以及变化</a></li>
<li><a href="#422-xhr%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BA%8B%E4%BB%B6">4.2.2 XHR实例对象接收数据时事件</a></li>
<li><a href="#423-xhr%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">4.2.3 XHR的属性和方法</a>
<ul>
<li><a href="#4231-%E4%B8%8E%E6%8E%A5%E6%94%B6%E5%88%B0%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7">4.2.3.1 与接收到响应结果相关的属性</a>
<ul>
<li><a href="#42311-xmlhttprequestresponsetype%E5%8F%AA%E8%AF%BB">4.2.3.1.1 XmlHttpRequest#responseType(只读)</a></li>
<li><a href="#42312-xmlhttprequestresponse%E5%8F%AA%E8%AF%BB">4.2.3.1.2 XmlHttpRequest#response(只读)</a></li>
<li><a href="#42313-xmlhttprequeststatus--statustext%E5%8F%AA%E8%AF%BB">4.2.3.1.3 XmlHttpRequest#status / statusText（只读）</a></li>
<li><a href="#42314-xmlhttprequestresponseurl%E5%8F%AA%E8%AF%BB">4.2.3.1.4 XmlHttpRequest#responseURL(只读)</a></li>
<li><a href="#42315-xmlhttprequestresponsetext%E5%8F%AA%E8%AF%BB">4.2.3.1.5 XmlHttpRequest#responseText(只读)</a></li>
<li><a href="#42316-xmlhttprequestresponsexml%E5%8F%AA%E8%AF%BB">4.2.3.1.6 XmlHttpRequest#responseXML(只读)</a></li>
<li><a href="#42317-xmlhttprequestgetallresponseheaders">4.2.3.1.7 XmlHttpRequest#getAllResponseHeaders()</a></li>
<li><a href="#42318-xmlhttprequestgetresponseheadername">4.2.3.1.8 XmlHttpRequest#getResponseHeader(name)</a></li>
</ul>
</li>
<li><a href="#4232-%E4%B8%8E%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7">4.2.3.2 与状态相关的属性</a>
<ul>
<li><a href="#42321-xmlhttprequestreadystate%E5%8F%AA%E8%AF%BB">4.2.3.2.1 XmlHttpRequest#readyState(只读)</a></li>
<li><a href="#42322-xmlhttprequestonreadystatechange--callback">4.2.3.2.2 XmlHttpRequest#onreadystatechange = callback</a></li>
</ul>
</li>
<li><a href="#4233-%E4%B8%8E%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">4.2.3.3 与请求超时相关的属性和方法</a>
<ul>
<li><a href="#42331-xmlhttprequesttimeout">4.2.3.3.1 XmlHttpRequest#timeout</a></li>
<li><a href="#42332-xmlhttprequestontimeout--callback">4.2.3.3.2 XmlHttpRequest#ontimeout = callback</a></li>
</ul>
</li>
<li><a href="#4234-%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95">4.2.3.4 特殊的事件触发有关方法</a>
<ul>
<li><a href="#42341-xmlhttprequestabort">4.2.3.4.1 XmlHttpRequest#abort()</a></li>
</ul>
</li>
<li><a href="#4235-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%9C%89%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">4.2.3.5 发送请求有关的属性和方法</a>
<ul>
<li><a href="#42351-xmlhttprequestopenmethod-url-async-user-password">4.2.3.5.1 XmlHttpRequest#open(method, url[, async[, user[, password]]])</a></li>
<li><a href="#42352-xmlhttprequestsetrequestheaderheadername-value">4.2.3.5.2 XmlHttpRequest#setRequestHeader(headerName, value)</a></li>
<li><a href="#42353-xmlhttprequestsendbody">4.2.3.5.3 XmlHttpRequest#send(body)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E5%88%A9%E7%94%A8xhr%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0axios">5 利用XHR简单实现axios</a></li>
<li><a href="#6-axios%E7%9A%84%E4%BD%BF%E7%94%A8">6 axios的使用</a>
<ul>
<li><a href="#61-axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">6.1 axios的基本定义</a></li>
<li><a href="#62-axios%E7%9A%84%E7%89%B9%E5%BE%81">6.2 axios的特征</a></li>
<li><a href="#63-axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">6.3 axios的基本使用</a>
<ul>
<li><a href="#630-ajax%E8%AF%B7%E6%B1%82%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.0 ajax请求和普通的http请求的区别</a></li>
<li><a href="#631-axios%E7%9A%84config%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E5%90%AB%E4%B9%89">6.3.1 axios的config对应的参数和含义</a></li>
<li><a href="#632-axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F">6.3.2 axios发送请求的三种不同方式</a>
<ul>
<li><a href="#6321-%E5%B0%86axios%E8%A7%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8E%BB%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">6.3.2.1 将axios视为一个对象去向服务器端发送请求</a>
<ul>
<li><a href="#6321-axiosgeturlconfig">6.3.2.1 axios.get(url[,config])</a></li>
<li><a href="#6322-axiosposturl-data">6.3.2.2 axios.post(url ,data)</a></li>
<li><a href="#6323-axiosputurl-data">6.3.2.3 axios.put(url ,data)</a></li>
</ul>
</li>
<li><a href="#6322-%E5%B0%86axios%E8%A7%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8E%BB%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">6.3.2.2 将axios视为一个函数去向服务器端发送请求</a>
<ul>
<li><a href="#6331-axiosconfig">6.3.3.1 axios(config)</a></li>
</ul>
</li>
<li><a href="#6323-%E5%B0%86axios%E8%A7%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%BB%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">6.3.2.3 将axios视为一个构造函数去向服务器端发送请求</a>
<ul>
<li><a href="#63231-axioscreateconfig">6.3.2.3.1 axios.create(config)</a></li>
<li><a href="#63232-axios%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">6.3.2.3.2 axios实例的方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#633-axios%E7%9A%84%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">6.3.3 axios的全局配置</a>
<ul>
<li><a href="#6331-axiosdefaultsconfigkey--value">6.3.3.1 axios.defaults.configKey = value</a></li>
</ul>
</li>
<li><a href="#634-axios%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8">6.3.4 axios的拦截器</a>
<ul>
<li><a href="#6341-axiosinterceptorsrequestusefuncconfig--functionerror-">6.3.4.1 axios.interceptors.request.use(func(config) {}, function(error) {})</a></li>
<li><a href="#6342-axiosinterceptorsresponseusefuncresponse--functionerror-">6.3.4.2 axios.interceptors.response.use(func(response) {}, function(error) {})</a></li>
<li><a href="#6343-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">6.3.4.3 拦截器的运行流程</a></li>
</ul>
</li>
<li><a href="#635-axios%E7%9A%84reponse">6.3.5 axios的reponse</a></li>
<li><a href="#636-axios%E7%9A%84%E5%8F%96%E6%B6%88">6.3.6 axios的取消</a>
<ul>
<li><a href="#6361-%E6%96%B9%E6%B3%951-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%87%BD%E6%95%B0">6.3.6.1 方法1 使用内部的函数</a></li>
<li><a href="#6362-%E6%96%B9%E6%B3%952%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">6.3.6.2 方法2：创建一个对象</a></li>
<li><a href="#6363-%E5%BA%94%E7%94%A8">6.3.6.3 应用</a>
<ul>
<li><a href="#63631-%E7%94%A8%E4%BA%8E%E8%AF%B7%E6%B1%82%E5%BD%93%E5%89%8D%E7%9A%84%E8%AF%B7%E6%B1%82">6.3.6.3.1 用于请求当前的请求</a></li>
<li><a href="#63632-%E7%94%A8%E4%BA%8E%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82">6.3.6.3.2 用于请求上一个请求</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-axios%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">7 axios源码分析</a>
<ul>
<li><a href="#71-axios%E4%B8%8Eaxios%E7%9A%84%E5%85%B3%E7%B3%BB">7.1 axios与Axios的关系</a></li>
<li><a href="#72-axios%E4%B8%8Einstance%E7%9A%84%E5%8C%BA%E5%88%AB">7.2 axios与instance的区别</a></li>
<li><a href="#73-axios%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE">7.3 axios执行的流程图</a></li>
<li><a href="#74-axios%E5%A6%82%E4%BD%95%E6%8A%8Ainterceptor%E5%92%8Crequest%E4%B8%B2%E8%81%94%E8%B5%B7%E6%9D%A5">7.4 axios如何把interceptor和request串联起来</a></li>
<li><a href="#75-axios%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88request%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84">7.5 axios是如何取消request的请求的</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%81-es6%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93">十 ES6增加的内容总结</a>
<ul>
<li><a href="#1-%E7%B1%BB%E7%9A%84%E6%96%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">1. 类的新的定义方式</a>
<ul>
<li><a href="#11-class">1.1. class</a>
<ul>
<li><a href="#111-extends%E5%92%8Csuper">1.1.1. extends和super</a>
<ul>
<li><a href="#1111-extends">1.1.1.1 extends</a></li>
<li><a href="#1112-super">1.1.1.2 super</a></li>
</ul>
</li>
<li><a href="#112-newtarget">1.1.2 new.target</a></li>
<li><a href="#113-static">1.1.3 static</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">2 块级作用域</a>
<ul>
<li><a href="#21-let">2.1 let</a>
<ul>
<li><a href="#211-let-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%89%B9%E7%82%B9">2.1.1. let 关键字的特点</a></li>
<li><a href="#212-let-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8Efor">2.1.2 let 关键字与for</a></li>
</ul>
</li>
<li><a href="#22-const">2.2 const</a>
<ul>
<li><a href="#221-%E7%89%B9%E7%82%B9">2.2.1 特点</a></li>
</ul>
</li>
<li><a href="#23-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%BE%85%E6%9F%A5%E8%AF%81">2.3 块级作用域函数(有待查证)</a></li>
</ul>
</li>
<li><a href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">3 函数的参数的默认值</a></li>
<li><a href="#4-%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95">4 对象字面量的扩展</a>
<ul>
<li><a href="#41-%E7%AE%80%E6%B4%81%E5%B1%9E%E6%80%A7key%E5%80%BC%E5%92%8Cvalue%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D%E7%9B%B8%E5%90%8C">4.1 简洁属性(key值和value的变量名相同)</a></li>
<li><a href="#42-%E7%AE%80%E6%B4%81%E6%96%B9%E6%B3%95">4.2 简洁方法</a></li>
<li><a href="#43-%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%90%8D">4.3 使用计算属性名</a></li>
<li><a href="#44-%E5%85%B3%E8%81%94%E5%8E%9F%E5%9E%8B">4.4 关联原型</a></li>
<li><a href="#45-super%E5%AF%B9%E8%B1%A1">4.5 super对象</a></li>
</ul>
</li>
<li><a href="#5-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">5 解构赋值</a>
<ul>
<li><a href="#51-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84">5.1 数组解构</a></li>
<li><a href="#52-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84">5.2 对象解构</a></li>
<li><a href="#53-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95">5.3 解构赋值的两种写法</a>
<ul>
<li><a href="#531-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E7%9A%84%E5%8F%98%E9%87%8F%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E6%9C%AA%E5%A3%B0%E6%98%8E">5.3.1 用于解构的变量未声明变量未声明</a></li>
<li><a href="#532-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E7%9A%84%E5%8F%98%E9%87%8F%E5%B7%B2%E7%BB%8F%E5%A3%B0%E6%98%8E%E5%89%8D%E9%9D%A2%E6%97%A0%E9%9C%80%E5%8A%A0%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B">5.3.2 用于解构的变量已经声明(前面无需加声明类型)</a></li>
</ul>
</li>
<li><a href="#54-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F">5.4 用于解构变量的数量</a></li>
<li><a href="#55-%E9%87%8D%E5%A4%8D%E8%B5%8B%E5%80%BC">5.5 重复赋值</a></li>
<li><a href="#56-%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0%E5%BD%93%E6%95%B0%E7%BB%84%E6%88%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82">5.6 解构参数（当数组或对象的字面量作为形参）</a></li>
<li><a href="#57-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">5.7 用于解构变量的默认值</a>
<ul>
<li><a href="#571-%E8%A7%A3%E6%9E%84%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%BD%A2%E5%8F%82%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E9%9A%BE%E7%82%B9">5.7.1 解构的默认值和形参的默认值（难点）</a></li>
</ul>
</li>
<li><a href="#58-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95%E7%9A%84%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8">5.8 与其他用法的结合应用</a></li>
</ul>
</li>
<li><a href="#6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">6 展开运算符（...)</a>
<ul>
<li><a href="#61--%E7%94%A8%E4%BA%8Eiteratble%E5%89%8D%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">6.1 ... 用于iteratble前(展开运算符)</a></li>
<li><a href="#62-%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E4%B8%AD%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0">6.2 ...用于函数的形参中（剩余参数）</a></li>
</ul>
</li>
<li><a href="#7-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F">7 模板字面量</a>
<ul>
<li><a href="#71-%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F">7.1 插入字符串字面量</a></li>
<li><a href="#72-%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F">7.2. 标签模板字面量</a></li>
<li><a href="#73-raw%E5%AD%97%E7%AC%A6%E4%B8%B2">7.3. raw字符串</a></li>
</ul>
</li>
<li><a href="#8-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">8  箭头函数</a>
<ul>
<li><a href="#81-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99">8.1 箭头函数的特殊规则</a>
<ul>
<li><a href="#811-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">8.1.1 只有一个变量</a></li>
<li><a href="#812-%E5%8F%AA%E6%9C%89%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81">8.1.2. 只有一行代码</a></li>
</ul>
</li>
<li><a href="#82-%E7%AE%AD%E5%A4%B4this%E6%8C%87%E5%90%91">8.2 箭头this指向</a></li>
<li><a href="#83-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">8.3 箭头函数的应用注意事项</a></li>
</ul>
</li>
<li><a href="#9-forof%E5%BE%AA%E7%8E%AF">9 for...of...循环</a>
<ul>
<li><a href="#91-forof%E5%92%8Cforin%E7%9A%84%E5%8C%BA%E5%88%AB">9.1 for...of和for...in...的区别</a></li>
</ul>
</li>
<li><a href="#10-%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%8B%93%E5%B1%95">10 数字字面量的拓展</a></li>
<li><a href="#11-unicode%E7%BC%96%E7%A0%81%E5%90%8E%E9%9D%A2%E5%86%8D%E8%A1%A5%E5%85%85">11 Unicode编码（后面再补充）</a></li>
<li><a href="#12-%E7%AC%A6%E5%8F%B7symbol">12 符号（symbol）</a>
<ul>
<li><a href="#121-symbol%E7%9A%84%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89">12.1 symbol的创建(自定义)</a></li>
<li><a href="#122-symbol%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">12.2 symbol常用的方法</a>
<ul>
<li><a href="#1221-typeof">12.2.1 typeof</a></li>
<li><a href="#1222-instanceof">12.2.2 instanceof</a></li>
<li><a href="#1223-valueof">12.2.3 valueOf</a></li>
<li><a href="#1224-symboltostring">12.2.4 Symbol#toString</a></li>
<li><a href="#1225-symbolfordesc">12.2.5 Symbol.for(desc)</a></li>
<li><a href="#1226-symbolkeyforsymbol">12.2.6 Symbol.keyFor(symbol)</a></li>
</ul>
</li>
<li><a href="#123-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%BA%94%E7%94%A8">12.3 符号的应用</a>
<ul>
<li><a href="#12231-%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%B3%A8%E5%86%8C">12.2.3.1 符号的注册</a></li>
<li><a href="#12232-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AC%A6%E5%8F%B7">12.2.3.2 作为对象属性的符号</a></li>
<li><a href="#12233-%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7">12.2.3.3 内置符号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">13 Map数据结构</a>
<ul>
<li><a href="#131-map%E7%9A%84%E6%9E%84%E9%80%A0">13.1 Map的构造</a></li>
<li><a href="#132-map%E7%9A%84%E6%96%B9%E6%B3%95">13.2 Map的方法</a>
<ul>
<li><a href="#1321-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">13.2.1 增删改查</a>
<ul>
<li><a href="#13211-mapsetkey-value">13.2.1.1 Map#set(key, value)</a></li>
<li><a href="#13212-mapdeletekey">13.2.1.2 Map#delete(key)</a></li>
<li><a href="#13213-mapclearkey">13.2.1.3 Map#clear(key)</a></li>
<li><a href="#13214-maphaskey">13.2.1.4 Map#has(key)</a></li>
<li><a href="#13215-mapgetkey">13.2.1.5 Map#get(key)</a></li>
</ul>
</li>
<li><a href="#1322-mapsize">13.2.2 Map#size()</a></li>
<li><a href="#1323-mapentries">13.2.3 Map#entries()</a></li>
<li><a href="#1324-mapvalues">13.2.4 Map#values()</a></li>
<li><a href="#1325-mapkeys">13.2.5 Map#keys()</a></li>
</ul>
</li>
<li><a href="#133-weakmap%E6%96%B9%E6%B3%95">13.3 WeakMap方法</a></li>
</ul>
</li>
<li><a href="#14-set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">14 Set数据结构</a>
<ul>
<li><a href="#141-set%E7%9A%84%E6%9E%84%E9%80%A0">14.1. Set的构造</a></li>
<li><a href="#142-set%E7%9A%84%E6%96%B9%E6%B3%95">14.2. Set的方法</a>
<ul>
<li><a href="#1421-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">14.2.1 增删改查</a>
<ul>
<li><a href="#14211-setaddkey-value">14.2.1.1 Set#add(key, value)</a></li>
<li><a href="#14212-setdeletekey">14.2.1.2 Set#delete(key)</a></li>
<li><a href="#14213-setclearkey">14.2.1.3 Set#clear(key)</a></li>
<li><a href="#14214-sethaskey">14.2.1.4 Set#has(key)</a></li>
</ul>
</li>
<li><a href="#1422-setsize">14.2.2 Set#size()</a></li>
<li><a href="#1423-setentries">14.2.3 Set#entries()</a></li>
<li><a href="#1424-setkeys">14.2.4 Set#keys()</a></li>
<li><a href="#1425-setvalues">14.2.5 Set#values()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-array%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">15 Array的扩展方法</a>
<ul>
<li><a href="#151-arrayof">15.1. Array.of()</a></li>
<li><a href="#152-arrayfromarraylikefunc">15.2. Array.from(arraylike,func?)</a></li>
<li><a href="#153-arrayfrom%E5%92%8Carrayof%E5%AF%B9%E4%BA%8E%E5%AD%90%E7%B1%BB%E7%9A%84%E5%BD%B1%E5%93%8D">15.3. Array.from和Array.of对于子类的影响</a></li>
<li><a href="#154-arraycopywithintarget-start-end">15.4. Array#copyWithin(target, start[, end])</a></li>
<li><a href="#155-arrayfillvalue-start-end">15.5. Array#fill(value[, start, end])</a></li>
<li><a href="#156-arrayfindfunc">15.6. Array#find(func)</a></li>
<li><a href="#157-arrayfindindexfunc">15.7. Array#findIndex(func)</a></li>
<li><a href="#158-arrayentries">15.8. Array#entries()</a></li>
<li><a href="#159-arraykeys">15.9. Array#keys()</a></li>
<li><a href="#1510-arrayvalues">15.10. Array#values()</a></li>
</ul>
</li>
<li><a href="#16-object%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">16. Object的扩展方法</a>
<ul>
<li><a href="#161-objectis">16.1. Object.is()</a></li>
<li><a href="#162-objectgetpropertysymbolsobj">16.2. Object.getPropertySymbols(obj)</a></li>
<li><a href="#163-objectsetprototypeofson-father">16.3. Object.setPrototypeOf(son, father)</a></li>
<li><a href="#164-objectassigntarget-source">16.4. Object.assign(target, ...source)</a></li>
</ul>
</li>
<li><a href="#17-number%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">17. Number的扩展方法</a>
<ul>
<li><a href="#171-numberepsilon">17.1 Number.EPSILON</a></li>
<li><a href="#172-numbermax_safe_integer">17.2 Number.MAX_SAFE_INTEGER</a></li>
<li><a href="#173-numbermin_safe_integer">17.3 Number.MIN_SAFE_INTEGER</a></li>
<li><a href="#174-numberisnanval">17.4 Number.isNaN(val)</a></li>
<li><a href="#175-numberisfiniteval">17.5 Number.isFinite(val)</a></li>
<li><a href="#176-numberisintegerval">17.6 Number.isInteger(val)</a></li>
<li><a href="#177-numberissafeintegerval">17.7 Number.isSafeInteger(val)</a></li>
</ul>
</li>
<li><a href="#18-string%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">18. String的扩展方法</a>
<ul>
<li><a href="#181-%E9%92%88%E5%AF%B9unicode%E7%9A%84%E5%87%BD%E6%95%B0%E4%B9%8B%E5%90%8E%E8%A1%A5%E5%85%85">18.1 针对Unicode的函数（之后补充）</a>
<ul>
<li><a href="#1811-stringfromcodepoint">18.1.1 String.fromCodePoint()</a></li>
<li><a href="#1812-stringcodepointat">18.1.2 String#codePointAt()</a></li>
<li><a href="#1813-stringnomalize">18.1.3 String.nomalize()</a></li>
</ul>
</li>
<li><a href="#182-stringraw">18.2 String.raw()</a></li>
<li><a href="#183-stringrepeatn">18.3 String#repeat(n)</a></li>
<li><a href="#184-%E6%96%B0%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95">18.4 新的索引方法</a>
<ul>
<li><a href="#1841-stringstartswithstr-index">18.4.1 String#startsWith(str[, index])</a></li>
<li><a href="#1842-stringendswithstr-index">18.4.2 String#endsWith(str[, index])</a></li>
<li><a href="#1843-stringincludesstr-index">18.4.3 String#includes(str[, index])</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<style>
 table {
   border-collapse: collapse;
 }
 tr, td{
   border: 1px solid #000000;
 }
</style>
<h1 id="%E9%9B%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">零 基础知识</h1>
<h2 id="1-%E5%8D%95%E8%AF%8D">1. 单词</h2>
<table>
  <tr>
    <td>abort</td>
    <td>终止</td>
  </tr>
  <tr>
    <td>interceptor</td>
    <td>拦截器</td>
  </tr>
  <tr>
      <td>pending</td>
      <td>未确定的</td>
  </tr>
  <tr>
      <td>resolved</td>
      <td>已解决的</td>
  </tr>
  <tr>
      <td>rejected</td>
      <td>拒绝的</td>
  </tr>
  <tr>
      <td>iterable</td>
      <td>可迭代的</td>
  </tr>
  <tr>
    <td>parse</td>
    <td>解析</td>
  </tr>
  <tr>
    <td>radix</td>
    <td>基数</td>
  </tr>
  <tr>
    <td>r</td>
    <td>radius 半径</td>
  </tr>
  <tr>
    <td>invoke</td>
    <td>调用</td>
  </tr>
  <tr>
    <td>orient</td>
    <td>朝向</td>
  </tr>
  <tr>
    <td>extend</td>
    <td>延伸，扩展</td>
  </tr>
  <tr>
    <td>derive</td>
    <td>源于，派生</td>
  </tr>
  <tr>
    <td>closure</td>
    <td>闭包</td>
  </tr>
  <tr>
    <td>Regular Expression</td>
    <td>正则表达式</td>
  </tr>
  <tr>
    <td>sibling</td>
    <td>兄弟姐妹</td>
  </tr>
  <tr>
    <td>previous</td>
    <td>以前的</td>
  </tr>
  <tr>
    <td>interval</td>
    <td>间隔</td>
  </tr>
  <tr>
    <td>navigator</td>
    <td>导航员(浏览器类型)</td>
  </tr>
  <tr>
      <td>property</td>
      <td>特性</td>
  </tr>
  <tr>
      <td>extension</td>
      <td>扩展</td>
  </tr>
  <tr>
      <td>configurable</td>
      <td>可配置的</td>
  </tr>
  <tr>
      <td>writable</td>
      <td>可写的</td>
  </tr>
  <tr>
      <td>enumrable</td>
      <td>可枚举的</td>
  </tr>
  <tr>
      <td>seal</td>
      <td>密封</td>
  </tr>
  <tr>
      <td>exponent</td>
      <td>指数</td>
  </tr>
   <tr>
      <td>fraction</td>
      <td>小数</td>
  </tr>
  <tr>
      <td>epsilon</td>
      <td>希腊字母中表示极小值的那个</td>
  </tr>
</table>
<h2 id="2-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AD%E6%B3%95%E5%90%8D%E7%A7%B0%E7%9A%84%E6%9C%AF%E8%AF%AD">2. 常见的语法名称的术语</h2>
<h3 id="121-numeric-literals%E6%95%B0%E5%80%BC%E8%AF%AD%E6%B3%95">1.2.1. Numeric Literals（数值语法）</h3>
<ul>
<li><span id="numeraic-literal">了解什么形式的才是js中的数值语法</span></li>
<li><img src="img/numerical_iteral.JPG" alt="形式"></li>
<li>注意事项
<ul>
<li>DecimalIntegerLiteral
<ul>
<li>0</li>
<li>第一位非0的整数</li>
</ul>
</li>
<li>DecimalDights
<ul>
<li>由整数构成（没要求第一位非0）</li>
</ul>
</li>
<li>DecimalDight
<ul>
<li>差一个s</li>
<li>0~9任意一个</li>
</ul>
</li>
<li>ExpontPart
<ul>
<li>指数部分</li>
<li>科学计数法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="122-%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%E5%8D%81%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AF%AD%E6%B3%95">1.2.2. 重点掌握十进制的语法</h3>
<ul>
<li><img src="./img/decimal.jpg" alt="十进制"></li>
</ul>
<h3 id="123-stringnumericliteral">1.2.3. StringNumericLiteral</h3>
<ul>
<li>strnumberliteral</li>
<li><span id="str_literal">了解什么是字符型的数值语法</span></li>
<li><img src="./img/str_iteral.jpg" alt="字符型的数值语法"></li>
<li>注意事项（与正常的数值语法相比）
<ul>
<li>左右可以包含任意数量的空格或者换行符，但转化的时候可以被忽略</li>
<li>整数的左侧可以有任意数量的0，转化时会被忽略</li>
<li>可以用+、-号表示符号</li>
<li>若字符串为空或者只有空格，则会返回+0</li>
<li>字符串型有Infinity和-Infinity，<a href="#numeraic-literal">Numeric Literals</a></li>
</ul>
</li>
</ul>
<h2 id="3-typeof-instanceof">3 typeof, instanceof</h2>
<ul>
<li>typeof只能分辨基本数据类型和object</li>
<li>instanceof可以用于判断对象类型，即某个对象是不是某个构造对象的实例</li>
</ul>
<h2 id="4-%E7%94%A8%E4%BA%8E%E8%B0%83%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0">4. 用于调试的一些函数</h2>
<h3 id="41-consolelog%E4%B8%8Econsoledir">4.1. console.log()与console.dir()</h3>
<ul>
<li>console.log()会在浏览器控制台打印出信息</li>
<li>console.dir()可以显示一个对象的所有属性和方法</li>
</ul>
<h2 id="5-objectprototypetostringcallobject">5 Object.prototype.toString.call(object)</h2>
<ul>
<li><font color="red">每个对象</font>都默认有toString方法</li>
<li>如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中 type 是对象的类型，返回的类型是string类型</li>
<li>应用</li>
<li>判断对象类型</li>
</ul>
<pre class="hljs"><code><div>	<span class="hljs-comment">// 获取strObject的构造函数类型</span>
	<span class="hljs-keyword">var</span> objectType = <span class="hljs-built_in">Object</span>.prototype.toString.call(strObject);
	<span class="hljs-built_in">console</span>.log(objectType.substring(<span class="hljs-number">8</span>, objectType.length - <span class="hljs-number">1</span>));
</div></code></pre>
<h2 id="6-%E7%90%86%E8%A7%A3%E8%BF%99%E6%AE%B5%E8%AF%9D">6 理解这段话</h2>
<ul>
<li>有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</li>
<li>函数并不是在定义时成为方法，而是在被调用时根据调用位置的不同成为方法（不太准确但可以作为理解）</li>
<li>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用</li>
<li>结论
<ul>
<li>函数是某个对象的方法并不是在定义时决定的，而是在调用时确定的（隐式绑定的时候）</li>
</ul>
</li>
</ul>
<h2 id="7-object%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">7 Object的一些常用函数</h2>
<h3 id="71-objectprototypetostring">7.1 Object.prototype.toString</h3>
<ul>
<li><font color="red">每个对象</font>都默认有toString方法</li>
<li>如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中 type 是对象的类型，返回的类型是string类型</li>
<li>应用</li>
<li>判断对象类型</li>
</ul>
<pre class="hljs"><code><div>	<span class="hljs-comment">// 获取strObject的构造函数类型</span>
	<span class="hljs-keyword">var</span> objectType = <span class="hljs-built_in">Object</span>.prototype.toString.call(strObject);
	<span class="hljs-built_in">console</span>.log(objectType.substring(<span class="hljs-number">8</span>, objectType.length - <span class="hljs-number">1</span>));
</div></code></pre>
<h3 id="72-objectkeysobj">7.2 Object.keys(obj)</h3>
<ul>
<li>ES6新增的方法</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.keys(obj)
</div></code></pre>
<ul>
<li>参数
<ul>
<li>obj: 要返回其枚举自身属性的对象</li>
</ul>
</li>
<li>返回值
<ul>
<li>一个表示给定对象的所有可枚举属性的字符串数组</li>
</ul>
</li>
</ul>
<h3 id="73-objectassign">7.3 Object.assign()</h3>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.assign(target, ...sources)
</div></code></pre>
<ul>
<li>参数
<ul>
<li>target: 目标对象</li>
<li>soures：源对象</li>
</ul>
</li>
<li>返回值
<ul>
<li>目标对象</li>
</ul>
</li>
<li>浅拷贝
<ul>
<li>bject.assign()拷贝的是（可枚举）属性值。假如源值是一个对象的引用，它仅仅会复制其引用值。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> newObj = <span class="hljs-built_in">Object</span>.assign({}, oldObj);
</div></code></pre>
<h2 id="8-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8F%8C%E7%B2%BE%E5%BA%A6%E7%9A%84%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95">8 浮点数双精度的科学计数法</h2>
<ul>
<li>浮点数是用二进制的科学计数法来表示，由于js采用的是双精度的浮点数，以下就以双精度浮点数及64位二进制数来说明</li>
<li><font color=red>双精度浮点数的10进制的精确有效位</font>
<ul>
<li>所以只能保证前15位是精确数字，第16位只是部分精确。
<ul>
<li>大于等于5：不精确，会被舍弃掉</li>
<li>小于5：精确，保留</li>
</ul>
</li>
</ul>
</li>
<li><img src="./img/ex3.jpg" alt="ex3.jpg"></li>
<li>sign(63): 符号位</li>
<li>exponent(52~62): 指数位
<ul>
<li>取值范围
<ul>
<li>原本表示的区间为[0, 2047]</li>
<li>计算最后结果时结果的区间[0-1023, 2047 - 1023]
<ul>
<li>去掉c = 0且c为最大值: [-1022, 1023]</li>
</ul>
</li>
</ul>
</li>
<li>为什么要计算最后结果时减去指数偏移量
<ul>
<li>为了使得改指数形式可以表示出负数</li>
</ul>
</li>
<li>为什么减去的偏移量为1023
<ul>
<li>使得最高为可以类似表示为符号位</li>
</ul>
</li>
</ul>
</li>
<li>fraction(0~51):小数点后的尾数
<ul>
<li>由于是小数部分，所以2的平方根</li>
<li>取值范围:
<ul>
<li>原本表示的区间：
<ul>
<li>$$ [ 0, 1- 2^{-52} ]$$</li>
</ul>
</li>
<li>计算结果表示的范围
<ul>
<li>$$ [ 1, 2- 2^{-52} ]$$</li>
</ul>
</li>
</ul>
</li>
<li>为什么在计算最后的小数部分的时候结果要加1
<ul>
<li>在使用二进制科学计算法表示该数时，要保证二进制形式的小数的整数部分为1，所以实际上fraction表示的只是尾数部分</li>
</ul>
</li>
</ul>
</li>
<li>表示正数最大值：
<ul>
<li>$$ exponent=2046，fraction=1 - 2^{-52} $$</li>
<li>用10进制表示约为
<ul>
<li>$$ 2 \times 10^{308} $$</li>
</ul>
</li>
</ul>
</li>
<li>表示正数最小值
<ul>
<li>$$ exponent=1，fraction= 0$$</li>
<li>用10进制表示约为
<ul>
<li>$$ 2 \times 10^{-308} $$</li>
</ul>
</li>
</ul>
</li>
<li>当exponent=0和exponent=2047的特殊含义</li>
</ul>
<table>
    <thead>
        <tr>
            <th>exponent</th>
            <th>fraction</th>
            <th>result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>=0</td>
            <td>=0</td>
            <td>(+/-)0</td>
        </tr>
        <tr>
            <td>=0</td>
            <td>!=0</td>
            <td>denormalized number 非规格化数</td>
        </tr>
        <tr>
            <td>=2047</td>
            <td>=0</td>
            <td>(+/-)无穷</td>
        </tr>
        <tr>
            <td>=2047</td>
            <td>=0</td>
            <td>NAN</td>
        </tr>
    <tbody>
</table> 
<h3 id="51-%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">5.1 将浮点数转化为二进制科学计数法遇到的问题</h3>
<ul>
<li>一些小数的尾数部分无法使用小数的二进制进行表示，只能近似的进行表示</li>
<li>规格化成浮点数的步骤：
<ul>
<li>将整数部分和小数部分分别格式化成二进制数</li>
<li>整数部分只保留1</li>
<li>根据计算公式求得对应的exponent和fraction</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    类型<span class="hljs-number">1</span>：
    <span class="hljs-number">10.25</span>
    第一步：用二进制形式表示
    <span class="hljs-comment">// 小数部分可以用有限的二进制数表示</span>
    <span class="hljs-number">1010.01</span>
    第二步：整数部分只保留<span class="hljs-number">1</span>
    <span class="hljs-number">1.01001</span> * <span class="hljs-number">2</span> ^ <span class="hljs-number">3</span>;
    第三步：根据公式计算
    exponent = <span class="hljs-number">3</span> + <span class="hljs-number">1023</span> = <span class="hljs-number">1026</span>
    fraction = <span class="hljs-number">01001</span>

    类型<span class="hljs-number">2</span>：
    <span class="hljs-number">10.4</span>
    第一步：用二进制形式表示
    <span class="hljs-comment">// 小数部分无法使用有限的二进制数表示，则要用近似的表示方法，二进制至少要保留52位</span>
    <span class="hljs-number">1010.01100</span> <span class="hljs-number">01100</span> ...(保留<span class="hljs-number">52</span>位)
    第二步：整数部分只保留<span class="hljs-number">1</span>
    <span class="hljs-number">1.010</span> <span class="hljs-number">01100</span> <span class="hljs-number">01100</span> ...(保留<span class="hljs-number">52</span>位) * <span class="hljs-number">2</span> ^ <span class="hljs-number">3</span>
    第三步：根据公式计算
    exponent = <span class="hljs-number">3</span> + <span class="hljs-number">1023</span> = <span class="hljs-number">1026</span>
    fraction = <span class="hljs-number">010</span> <span class="hljs-number">01100</span> <span class="hljs-number">01100</span> ...(保留<span class="hljs-number">52</span>位)
</div></code></pre>
<ul>
<li>由于有些小数并不能用一一对应的二进制形式表示，所以会导致这些小数在表达式的计算中会出现误差，该误差的数量级为
<ul>
<li>$$ 2^{-52} = 2.2 \times 10^{-16}$$</li>
<li>导致10进制小数只能保证15位有效数字，第16位就开使为部分精确</li>
</ul>
</li>
</ul>
<h3 id="52-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A7%A3%E9%87%8A%E5%8E%9F%E5%9B%A0%E9%97%AE%E9%A2%98">5.2 常见的解释原因问题</h3>
<pre class="hljs"><code><div>例<span class="hljs-number">1</span>：
&gt;&gt;&gt; <span class="hljs-number">1.4</span> - <span class="hljs-number">1.1</span>
<span class="hljs-number">0.2999999999999998</span>
为什么不是<span class="hljs-number">0.3</span>？
<span class="hljs-comment">/*
1.4和1.1两个数都不能被精确表示，用[4]的链接可以将浮点数字面量转换成真实存储的值，可以看到1.4被近似成了1.399999999999999，1.1被近似成了1.10000000000000008所以两数相减得到的不是0.3而是0.2999999999999998。
*/</span>
例<span class="hljs-number">2</span>：
<span class="hljs-number">4.0</span> + <span class="hljs-number">1e+16</span> - <span class="hljs-number">1e+16</span>
&gt;&gt;&gt; <span class="hljs-number">4.0</span>
没错。
<span class="hljs-number">5.0</span> + <span class="hljs-number">1e+16</span> - <span class="hljs-number">1e+16</span>
&gt;&gt;&gt; <span class="hljs-number">4.0</span>
为什么<span class="hljs-number">5</span>变成了<span class="hljs-number">4</span>？
<span class="hljs-comment">/*
所以在例2中 ，恰巧第16位有效数字是部分精确的，4可以被精确表示，因为最后一位并不能表示5，所以出现了浮点数误差。
*/</span>
<span class="hljs-number">4.0</span> + <span class="hljs-number">1e+17</span> - <span class="hljs-number">1e+17</span>
&gt;&gt;&gt; <span class="hljs-number">0.0</span>
为什么结果是<span class="hljs-number">0.0</span>？ <span class="hljs-number">4</span>去哪了？
<span class="hljs-comment">/*
4已经在第17位，超出了双精度浮点数的最大有效位数，就被忽略了，所以有[公式] 。
*/</span>
</div></code></pre>
<h2 id="9-%E4%B8%80%E4%BA%9Bjs%E7%9A%84%E7%AE%80%E5%8D%95%E8%A1%A8%E7%A4%BA">9 一些js的简单表示</h2>
<ul>
<li>Object.prototype.func ==&gt; Object#func</li>
</ul>
<h2 id="10-tostring%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%98%93%E9%94%99%E7%82%B9">10 toString函数的一些易错点</h2>
<ul>
<li>基本数据类型
<ul>
<li>null, undefined, NaN -- &quot;null&quot;, &quot;undefined&quot;, &quot;NaN&quot;</li>
<li>boolean -- true: &quot;true&quot;, false: &quot;false&quot;</li>
<li>number, symbol: 为对应的字符串形式</li>
</ul>
</li>
<li>符合数据类型
<ul>
<li><font color="red">数组</font>
<ul>
<li>[null] --&gt; &quot;&quot;(空数组)</li>
<li>[undefined] --&gt; &quot;&quot;（空数组)</li>
<li>[NaN] --&gt; NaN</li>
<li>其他为对应的字符串形式</li>
</ul>
</li>
<li>其他仍然遵照ToString类型</li>
</ul>
</li>
</ul>
<h2 id="11-%E5%8C%BA%E5%88%AB%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">11 区别实例对象与函数对象</h2>
<ul>
<li>实例对象（简称xx对象）：通过new创建一个新的实例对象</li>
<li>函数对象：将函数当作一个对象使用（函数既可以当作一个函数使用，也可以看作一个对象使用）</li>
<li>如何分析一个语句角度
<ul>
<li>从语法：判断是函数还是对象</li>
<li>从功能</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>{

    }
    <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> Fn() 
    <span class="hljs-comment">// 构造函数的确定，是由后面调用决定的，即后面有没有new</span>
    <span class="hljs-built_in">console</span>.log(Fn.prototype)
    <span class="hljs-comment">// 从这可以将Fn理解为一个对象</span>
    <span class="hljs-comment">// 如何看出它的对象特点</span>
    <span class="hljs-comment">// 该函数有属性和方法时，可以看作为对象</span>
    Fn.bind({})
    <span class="hljs-comment">// 所有的函数当时Function的实例，所以对应有bind方法</span>
    $(<span class="hljs-string">"#test"</span>)
    <span class="hljs-comment">// 此时$是一个函数</span>
    $.<span class="hljs-keyword">get</span>("/test")
    // 此时$是一个对象
</div></code></pre>
<h2 id="12-%E7%9C%8B%E6%87%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">12 看懂数据类型</h2>
<pre class="hljs"><code><div>    a.b.c()
    <span class="hljs-comment">// 括号前面的必然是函数即a.b.c为函数</span>
    <span class="hljs-comment">// 其中a,b为对象</span>
</div></code></pre>
<h2 id="13-%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">13 两种类型的回调函数</h2>
<ul>
<li>特征
<ul>
<li>自己拟定</li>
<li>没有调用但是会执行</li>
</ul>
</li>
</ul>
<h3 id="21-%E5%90%8C%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.1 同步回调函数</h3>
<ul>
<li>程序会按照顺序来调用</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    arr.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(item)
    })
    <span class="hljs-built_in">console</span>.log(arr)
    <span class="hljs-comment">// 先输出item，在输出arr</span>
</div></code></pre>
<h3 id="22-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.2 异步回调函数</h3>
<ul>
<li>会根据代码启动异步，将回调函数放入队列之中
<ul>
<li>等触发了异步后再调用</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        ...
    }, <span class="hljs-number">0</span>)
    <span class="hljs-comment">// 执行完后面的函数再执行该异步</span>
</div></code></pre>
<h2 id="14-js%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Berror">14 js常见的内置类型之Error</h2>
<pre class="hljs"><code><div>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(content)
    <span class="hljs-comment">// 显示content的错误</span>
</div></code></pre>
<h3 id="141-error%E7%9A%84%E7%B1%BB%E5%9E%8B">14.1 Error的类型</h3>
<h4 id="1411-referenceerror">14.1.1 ReferenceError</h4>
<ul>
<li>引用变量不存在</li>
</ul>
<h4 id="1412-typeerror">14.1.2 TypeError</h4>
<ul>
<li>数据类型不正确的错误</li>
</ul>
<h4 id="1413-rangeerror">14.1.3 RangeError</h4>
<ul>
<li>数据值不再所允许的范围内</li>
</ul>
<h4 id="1414-syntaxerror">14.1.4 SyntaxError</h4>
<ul>
<li>语法错误</li>
</ul>
<h3 id="142-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">14.2 错误处理</h3>
<h4 id="1421-try%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81catcherror%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">14.2.1 try{执行代码}catch(error){错误处理}</h4>
<ul>
<li>捕获错误,即被动进行错误处理</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> d;
    <span class="hljs-built_in">console</span>.log(d.xxx)
}
<span class="hljs-keyword">catch</span>(error) {
    <span class="hljs-built_in">console</span>.log(error.message);
    <span class="hljs-comment">// console.log(error.stack)</span>
}
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello_world"</span>);
<span class="hljs-comment">// 仍能正常的运行</span>

</div></code></pre>
<h4 id="1422-throw-error">14.2.2 throw error</h4>
<ul>
<li>抛出错误, 主动进行错误处理,并显示自己的语段</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Date</span>.now() % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) 
        alert(<span class="hljs-string">"执行完毕"</span>)
    <span class="hljs-keyword">else</span>{
       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"不能执行"</span>)
    }
</div></code></pre>
<h3 id="143-%E9%94%99%E8%AF%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">14.3 错误对象的属性</h3>
<h4 id="1431-message">14.3.1 message</h4>
<ul>
<li>错误相关的信息</li>
</ul>
<h4 id="1432-stack">14.3.2 stack</h4>
<ul>
<li>函数调用栈的记录信息</li>
</ul>
<h2 id="15-%E7%90%86%E8%A7%A3apply-call-bind">15 理解apply, call, bind</h2>
<h3 id="151-funcapplythisarg-args">15.1 func.apply(thisArg, [args])</h3>
<h4 id="1511-%E7%90%86%E8%A7%A3apply%E7%9A%84%E4%BD%9C%E7%94%A8">15.1.1 理解apply的作用</h4>
<ul>
<li>将func中this所指的属性和方法添加到thisArg的this所指的属性和方法之中，并执行func
<ul>
<li>注意：此时的func所用的this就是thisArg的this即可以理解为thisArg在运行func的内容</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"hello"</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.word = <span class="hljs-string">"world"</span>;
}
fn2Object = <span class="hljs-keyword">new</span> fn2();
fn1.apply(fn2Object)
<span class="hljs-comment">// 执行fn1的代码，并将fn1的this所指的属性和方法加入到fn2Object</span>
<span class="hljs-comment">// </span>
<span class="hljs-built_in">console</span>.dir(fn2Object)
<span class="hljs-built_in">console</span>.dir(fn2)
</div></code></pre>
<h3 id="152-bindfunc1-func2">15.2 bind(func1, func2)</h3>
<ul>
<li>返回值是一个函数wrap</li>
</ul>
<h4 id="231-%E6%BA%90%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3">2.3.1 源码的理解</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// bind函数的理解</span>
<span class="hljs-comment">// 语法上：返回一个函数wrap</span>
<span class="hljs-comment">// 功能上：若是调用warp函数并传入参数</span>
<span class="hljs-comment">//         fn根据传递的参数执行并且thisArg将继承fn的属性和方法</span>
<span class="hljs-comment">//         之后返回值：undefine</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">fn, thisArg</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//根据传入的参数来调用fn</span>
    <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);
    <span class="hljs-built_in">console</span>.log(args);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
      args[i] = <span class="hljs-built_in">arguments</span>[i];
    }
    <span class="hljs-comment">//用apply来实现绑定</span>
    <span class="hljs-keyword">return</span> fn.apply(thisArg, args);
  };
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.word = <span class="hljs-string">"world"</span>;
}
fn2Object = <span class="hljs-keyword">new</span> fn2();
<span class="hljs-built_in">console</span>.log(bind(fn1, fn2Object)(<span class="hljs-string">"hello"</span>))
<span class="hljs-built_in">console</span>.dir(fn2)
<span class="hljs-comment">/*
undefined
fn2
 name: "hello"word: "world" 
*/</span>
</div></code></pre>
<h1 id="%E4%B8%80-javascript%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86">一 javascript的基础认识</h1>
<h2 id="1-%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80">1. 解释型语言</h2>
<ul>
<li>编译型语言
<ul>
<li>C语言-&gt;编译成2进制代码（与操作系统有关）-&gt; 执行</li>
</ul>
</li>
<li>解释型语言
<ul>
<li>一行一行读取，一行一行执行</li>
</ul>
</li>
</ul>
<h2 id="2-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80">2. 动态类型语言</h2>
<ul>
<li>动态类型的语言
<ul>
<li>不能确定一个变量的类型，所以可以在代码执行的过程中动态修改</li>
</ul>
</li>
<li>静态类型的语言
<ul>
<li>在代码执行之前可以确定一个变量（标识符）准确的类型，并且不能修改</li>
</ul>
</li>
</ul>
<h2 id="3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">3. 应用场景</h2>
<ul>
<li>网页的交互</li>
<li>服务器开发(node.js)</li>
<li>命令行工具(node.js)</li>
<li>桌面程序，VSCode使用TypeScript开发</li>
<li>App(React Native)</li>
<li>游戏开发(cocos2d-js)</li>
<li>小程序开发</li>
</ul>
<h2 id="4-%E7%BC%96%E5%86%99%E4%BD%8D%E7%BD%AE">4. 编写位置</h2>
<h3 id="41-%E5%9C%A8html%E5%85%83%E7%B4%A0%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Cjs%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%BB%BA%E8%AE%AE">4.1. 在HTML元素中属性直接执行js代码（不建议）</h3>
<ul>
<li>事件触发属性的双引号内</li>
</ul>
<pre class="hljs"><code><div>  &lt;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">href</span>="" <span class="hljs-selector-tag">onclick</span>="<span class="hljs-selector-tag">alert</span>('<span class="hljs-selector-tag">hello_world</span>')&gt;我是<span class="hljs-selector-tag">a</span>元素&lt;/<span class="hljs-selector-tag">a</span>&gt;
</div></code></pre>
<ul>
<li>非事件触发属性(需要指明javascript)</li>
</ul>
<pre class="hljs"><code><div> &lt;<span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">href</span>="<span class="hljs-selector-tag">javascript</span>: <span class="hljs-selector-tag">alert</span>('<span class="hljs-selector-tag">hello_world</span>')" &gt;我是<span class="hljs-selector-tag">a</span>元素&lt;/<span class="hljs-selector-tag">a</span>&gt;
</div></code></pre>
<h3 id="42-%E4%B9%A6%E5%86%99%E5%88%B0script%E6%A0%87%E7%AD%BE%E4%B8%AD">4.2. 书写到script标签中</h3>
<ul>
<li>一般位于body的最下面</li>
</ul>
<h3 id="43-%E4%BB%8E%E5%A4%96%E9%83%A8%E5%BC%95%E5%85%A5js%E6%96%87%E4%BB%B6">4.3. 从外部引入js文件</h3>
<ul>
<li>引入方法（仍放在body的最后面）</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
</span></span></div></code></pre>
<h3 id="44-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">4.4. 注意事项</h3>
<ul>
<li>在外联js文件时，script标签中不能有js代码，且不用写type类型(text/javascript)</li>
<li>由于html文档加载顺序的原因，推荐将js代码放在body子元素的最后一行
<ul>
<li>html元素加载后才能够与js代码进行关联</li>
</ul>
</li>
<li>js代码严格区分大小写
<ul>
<li>但HTML和CSS代码不区分大小写</li>
</ul>
</li>
</ul>
<h2 id="5-js%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B3%A8%E9%87%8A">5. js代码的注释</h2>
<ul>
<li>单行注释</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-comment">//hello_world</span>
</div></code></pre>
<ul>
<li>多行注释</li>
</ul>
<pre class="hljs"><code><div> <span class="hljs-comment">/*
 hello_world
 */</span>
</div></code></pre>
<ul>
<li>文档注释</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">/*
  * test 函数
  */</span>
</div></code></pre>
<h2 id="6-js%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">6. js的内置数据类型数据类型</h2>
<ul>
<li>基本数据类型
<ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>undefined</li>
<li>null</li>
<li>symbol</li>
</ul>
</li>
<li>复合数据类型
<ul>
<li>object</li>
</ul>
</li>
</ul>
<h2 id="7-%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E7%9A%84%E6%9C%AC%E8%B4%A8">7. 变量存储的本质</h2>
<h3 id="71-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E7%B1%BB">7.1 内存的分类</h3>
<ul>
<li>栈空间</li>
<li>堆空间</li>
<li><img src="./img/storage.jpg" alt="storage"></li>
</ul>
<h3 id="72-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%90%84%E9%83%A8%E5%88%86%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%8D%E7%BD%AE">7.2 代码运行时，各部分存储的位置</h3>
<ul>
<li>代码存储到硬盘中</li>
<li>代码运行时，其中定义的变量是存储在内存中</li>
<li>基本数据类型的变量所对应的值是直接存储在内存栈空间中，当变量的值改变时，是直接修改栈空间中对应位置的变量的值</li>
<li>复合数据类型的变量所对应的值是存储在内存栈空间中，但是存储的变量的值是所在堆空间的地址
<ul>
<li>变量的获取实际上是通过栈空间中存储的对应堆空间的内存地址来找到相应的存储位置</li>
</ul>
</li>
</ul>
<h1 id="%E4%BA%8C-js%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90">二 js内置数据类型与语法解析</h1>
<h2 id="1-js%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">1 js的内置类型</h2>
<ul>
<li>一般认为有七种内置类型
<ul>
<li>null, undefined, boolean, number, string, symbol(符号类型，ES6新增的), object,</li>
</ul>
</li>
</ul>
<h3 id="11-%E4%BD%BF%E7%94%A8typeof%E6%9D%A5%E5%88%86%E8%BE%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">1.1 使用typeof来分辨不同的内置类型</h3>
<ul>
<li>typeof的实质
<ul>
<li><font color="red">得到的不是变量的类型，而是变量所持值的类型</font></li>
<li>js的变量是没有类型的</li>
</ul>
</li>
<li>结果：返回一个string数据的值</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> === <span class="hljs-string">"undefined"</span>; <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">"boolean"</span>; <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span> === <span class="hljs-string">"number"</span>; <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-string">"42"</span> === <span class="hljs-string">"string"</span>; <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">typeof</span> { <span class="hljs-attr">life</span>: <span class="hljs-number">42</span> } === <span class="hljs-string">"object"</span>; <span class="hljs-comment">// true</span>
    <span class="hljs-comment">// ES6中新加入的类型</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>() === <span class="hljs-string">"symbol"</span>; <span class="hljs-comment">// true</span>

    <span class="hljs-comment">// 特殊</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">"function"</span> <span class="hljs-comment">// true</span>
    <span class="hljs-comment">// null比较特殊</span>
    <span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> === <span class="hljs-string">"object"</span>  <span class="hljs-comment">//true</span>
    <span class="hljs-comment">// typeof对于只声明而没有赋值的变量返回undefined，对于没有声明的变量也是返回undefined且不报错</span>
    <span class="hljs-keyword">var</span> a;
    <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">"undefined"</span>  <span class="hljs-comment">//true</span>
    <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">"undefined"</span> <span class="hljs-comment">//true</span>
</div></code></pre>
<ul>
<li>注意
<ul>
<li>typeof还可以用于分辨function，虽然只是object的子类型</li>
<li>null比较特殊，由于历史遗留的原因被typeof认为是object，应该使用以下的方法来判断一个值是否是null</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    !a &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">"object"</span> 
    <span class="hljs-comment">// 若a=null, 返回true</span>
</div></code></pre>
<h3 id="12-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3">1.2 基本类型的理解</h3>
<h4 id="121-undefined">1.2.1 undefined</h4>
<ul>
<li>已在作用域中声明但没有赋值的变量，值是undefined</li>
</ul>
<h4 id="1211-undefined%E5%92%8Cundeclared%E7%9A%84%E5%8C%BA%E5%88%AB">1.2.1.1 undefined和undeclared的区别</h4>
<ul>
<li>undeclared是连声明都没有的变量,js错误描述是</li>
</ul>
<pre class="hljs"><code><div>     ReferenceError: b is not defined
</div></code></pre>
<h3 id="13-%E6%80%BB%E7%BB%93">1.3 总结</h3>
<ul>
<li>JavaScript 有 七 种 内 置 类 型：null、undefined、boolean、number、string、object 和symbol，可以使用 typeof 运算符来查看。</li>
<li>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。</li>
<li>undefined 是值的一种。undeclared 则表示变量还没有被声明过。</li>
<li>JavaScript 却将它们混为一谈，在我们试图访问 &quot;undeclared&quot; 变量时这样报错：ReferenceError: a is not defined，并且 typeof 对 undefined 和 undeclared 变量都返回&quot;undefined&quot;。</li>
</ul>
<h2 id="2-js%E7%9A%84%E5%86%85%E7%BD%AE%E5%80%BC%E7%B1%BB%E5%9E%8B">2 js的内置值类型</h2>
<h3 id="21-js%E7%9A%84%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8Barray">2.1 js的数组类型(Array)</h3>
<ul>
<li>实质上也是一种对象，只是键值为十进制数字类型而已
<ul>
<li>如果一个[]类型变量的键值能转化为十进制，则其会被视为数组</li>
</ul>
</li>
<li>在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组</li>
<li>对数组声明后即可向其中加入值，<font color="red">不需要预先设定大小</font></li>
<li>“稀疏”数组的空白部分
<ul>
<li>区别于空白部分被赋值为undefined</li>
<li>对象执行Get操作时没有从中找到对应的属性，因此返回一个undefined，而并不是空白部分被赋值为undefined</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = [];
    a[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;
    a[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;
    <span class="hljs-built_in">console</span>.log( a[<span class="hljs-number">2</span>] ) <span class="hljs-comment">// undefined</span>
</div></code></pre>
<h4 id="211-%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B">2.1.1 类数组转化为数组类型</h4>
<ul>
<li>类数组
<ul>
<li>有length属性</li>
<li>一组通过数字索引的值</li>
<li>例子
<ul>
<li><font color="red">一些 DOM 查询操作会返回 DOM 元素列表</font></li>
<li>通过 arguments 对象（类数组）将函数的参数当作列表来访问（ES6废除）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2111-arrayslicecallarraylike">2.1.1.1 Array#slice.call(arrayLike)</h4>
<ul>
<li>将类数组强制转化为数组类型，并将数组作为返回值</li>
</ul>
<h4 id="2112-slicecallarraylike">2.1.1.2 [].slice.call(arrayLike)</h4>
<ul>
<li>将类数组强制转化为数组类型,并将数组作为返回值</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
        <span class="hljs-built_in">console</span>.log(arr);
        <span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)
    }
    foo(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);
    <span class="hljs-comment">// ["a", "b", "c"]</span>
    <span class="hljs-comment">// true</span>
</div></code></pre>
<h4 id="2113-arrayfromarraylikefunc">2.1.1.3 Array.from(arrayLike[,func]);</h4>
<ul>
<li>将类数组强制转化为数组类型,并将数组作为返回值</li>
<li>ES6新增的方法</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>);
        <span class="hljs-built_in">console</span>.log(arr);
        <span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)
    }
    foo(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);
    <span class="hljs-comment">// ["a", "b", "c"]</span>
    <span class="hljs-comment">// true</span>
</div></code></pre>
<h3 id="22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8Bstring">2.2 字符串类型(string)</h3>
<ul>
<li>string类型的数值在调用String的方法时，会先自动被初始化String对象，再调用对应的函数</li>
<li>string类型使用String对象进行包装</li>
</ul>
<h4 id="221-%E5%8C%BA%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84">2.2.1 区分字符串和字符数组</h4>
<ul>
<li>都具有length属性, indexOf和concat方法</li>
</ul>
<pre class="hljs"><code><div>   <span class="hljs-keyword">var</span> a = <span class="hljs-string">"hello"</span>;
   <span class="hljs-keyword">var</span> b = [<span class="hljs-string">"h"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"l"</span>, <span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>];

   <span class="hljs-built_in">console</span>.log(a.length);   <span class="hljs-comment">// 5</span>
   <span class="hljs-built_in">console</span>.log(b.length);   <span class="hljs-comment">// 5</span>

   <span class="hljs-built_in">console</span>.log(a.indexOf(<span class="hljs-string">"o"</span>)); <span class="hljs-comment">// 4</span>
   <span class="hljs-built_in">console</span>.log(b.indexOf(<span class="hljs-string">"o"</span>)); <span class="hljs-comment">//4</span>

   a = a.concat(<span class="hljs-string">" world"</span>);
   b = b.concat([<span class="hljs-string">" "</span>, <span class="hljs-string">"w"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"r"</span>, <span class="hljs-string">"l"</span>, <span class="hljs-string">"d"</span>]);

   <span class="hljs-built_in">console</span>.log(a)   <span class="hljs-comment">// "hello world"</span>
   <span class="hljs-built_in">console</span>.log(b)
</div></code></pre>
<ul>
<li>但是区别
<ul>
<li>以前访问对应的字符应该使用charAt(index)来进行访问</li>
<li><font color="red">js中字符串中的值是不可变的</font>
<ul>
<li>字符串不可变是无法对字符串内部的值进行修改
<ul>
<li>需要通过字符串的成员函数对字符串进行修改，但是实质上为创建并返回一个新的字符��，而不是在原字符串上进行修改。</li>
</ul>
</li>
</ul>
</li>
<li>字符数组中的值是可变的</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-string">"hello"</span>
    <span class="hljs-keyword">var</span> b = [<span class="hljs-string">"h"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"l"</span>, <span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>];

    a[<span class="hljs-number">0</span>] = <span class="hljs-string">"H"</span>;
    b[<span class="hljs-number">0</span>] = <span class="hljs-string">"H"</span>

    <span class="hljs-built_in">console</span>.log(a)  <span class="hljs-comment">//"hello"</span>
    <span class="hljs-built_in">console</span>.log(b)  <span class="hljs-comment">//["H", "e", "l", "l", "o"]</span>
</div></code></pre>
<h4 id="222-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%9F%E7%94%A8%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD">2.2.2 字符串借用数组类型的函数来实现功能</h4>
<ul>
<li>各个字母中间插进其他字符</li>
</ul>
<h4 id="2221-arrayprototypejoincallstring-%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E7%9A%84%E5%80%BC">2.2.2.1 Array.prototype.join.call(string, 中间插入的值)</h4>
<ul>
<li>返回一个中间加入值的新的字符串</li>
</ul>
<h5 id="2222-arrayprototypemapcallstring-funcjoin%22%22">2.2.2.2 Array.prototype.map.call(string, func).join(&quot;&quot;)</h5>
<ul>
<li>返回一个中间加入值的新的字符串</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">Array</span>.prototype.join.call( a, <span class="hljs-string">"-"</span> );
    <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Array</span>.prototype.map.call( a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)</span>{
    <span class="hljs-keyword">return</span> v.toUpperCase() + <span class="hljs-string">"."</span>;
    } ).join( <span class="hljs-string">""</span> );
    c; <span class="hljs-comment">// "f-o-o"</span>
    d; <span class="hljs-comment">// "F.O.O."</span>
</div></code></pre>
<ul>
<li>实现字符串的reserve
<ul>
<li>reverve函数是将本身颠倒，而不仅仅是返回一个颠倒的字符串</li>
<li>字符串中没有reserve函数</li>
<li>数组的reserver函数是将本身颠倒，当使用call让字符串调用时，由于字符串本身的值时不变的，所以不能这种方法</li>
</ul>
</li>
<li>可以使用以下步骤
<ul>
<li>将字符串转化称字符数组</li>
<li>将字符数组颠倒</li>
<li>再转化为字符串</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = a.split(<span class="hljs-string">""</span>)
             .reserve()
             .join(<span class="hljs-string">""</span>)
    <span class="hljs-comment">// 但对简单的字符串却完全适用</span>
</div></code></pre>
<h3 id="23-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8Bnumber">2.3 数字类型(number)</h3>
<ul>
<li>js只有一个数字类型number
<ul>
<li>js没有真正意义上的整数，实际上是没有小数点的小数</li>
<li><font color="red">使用双精度的格式来表示number</font>
<ul>
<li>以10进制的形式
<ul>
<li>前15位为精确位</li>
<li>第16位为部分精确位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>number类型的数值在调用Number的方法时，会先自动被初始化Number对象，再调用对应的函数</li>
<li>常见的数字表示法
<ul>
<li>科学计数法: 1.23e-10</li>
<li>二进制: 0b</li>
<li>八进制: 0o</li>
<li>十六进制：0x</li>
</ul>
</li>
</ul>
<h4 id="231-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BE%83%E5%B0%8F%E5%80%BC%E9%97%AE%E9%A2%98">2.3.1 数字类型的较小值问题</h4>
<pre class="hljs"><code><div>    <span class="hljs-built_in">console</span>.log( <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span>) <span class="hljs-comment">// false</span>
    <span class="hljs-comment">// 原因：0.1和0.2都无法规范为有限的浮点数形式</span>
    <span class="hljs-comment">// 前15位为精确的，第16位部分精确</span>
</div></code></pre>
<ul>
<li>使表达式与实际数值相等的判断方法</li>
</ul>
<h5 id="2311-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E8%AF%AF%E5%B7%AE">2.3.1.1 二进制的误差</h5>
<ul>
<li>$$ 2^{-52} = 2.2 \times 10^{-16} $$</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">0.3</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.abs(b - a) &lt; <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">-52</span>))
</div></code></pre>
<h4 id="2312-numberepsilon">2.3.1.2 Number.EPSILON</h4>
<ul>
<li>ES6将上述误差值保存在Number.EPSILON</li>
<li>应用：判断是技术和表达式之间的大小</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">0.3</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.abs(b - a) &lt; <span class="hljs-built_in">Number</span>.EPSLION)
</div></code></pre>
<h4 id="232-number%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.3.2 Number常用的属性和方法</h4>
<h5 id="2321-numberepsilon">2.3.2.1 Number.EPSILON</h5>
<ul>
<li>表达式和实际数之间的最大误差</li>
</ul>
<h5 id="2322-numbermaxsafeinteger">2.3.2.2 Number.MAX_SAFE_INTEGER</h5>
<ul>
<li>被安全呈现的最大整数(正)</li>
</ul>
<h5 id="2323-numberminsafeinteger">2.3.2.3 Number.MIN_SAFE_INTEGER</h5>
<ul>
<li>被安全呈现的最小整数（负）</li>
<li>与上面一起构成了整数的安全范围</li>
</ul>
<h5 id="2324-numbertoexponential">2.3.2.4 Number#toExponential()</h5>
<ul>
<li>返回对应数值的科学计数法的表示</li>
</ul>
<h5 id="2325-numbertofixednum">2.3.2.5 Number#toFixed(num)</h5>
<ul>
<li>返回保留num位小数的值</li>
</ul>
<h5 id="2326-numbertoprecisionnum">2.3.2.6 Number#toPrecision(num)</h5>
<ul>
<li>返回保留num位有效数字的值</li>
</ul>
<h5 id="2326-numberisintegernum">2.3.2.6 Number.isInteger(num)</h5>
<ul>
<li>判断某个数是不是整数</li>
</ul>
<h5 id="2327-numberissafeintegernum">2.3.2.7 Number.isSafeInteger(num)</h5>
<ul>
<li>判断某个数是不是在安全的整数</li>
</ul>
<h4 id="233-%E5%AE%9E%E7%8E%B032%E4%B8%BA%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0">2.3.3 实现32为有符号整数</h4>
<pre class="hljs"><code><div>    number | 0
</div></code></pre>
<ul>
<li>因为位运算符只适用于32位数</li>
</ul>
<h4 id="234-%E7%89%B9%E6%AE%8A%E6%95%B0%E5%AD%97number">2.3.4 特殊数字(number)</h4>
<h5 id="2341-%E4%B8%8D%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97nan">2.3.4.1 不是数字的数字(NaN)</h5>
<ul>
<li>NaN是指“不是一个数字”，但是仍是一种number类型</li>
<li>实质上是一个警戒值，用于指出数字类型中的错误
<ul>
<li>无效数值</li>
<li>失败数值</li>
<li>坏数值</li>
</ul>
</li>
</ul>
<h6 id="23411-nan%E4%B8%8E">2.3.4.1.1 NaN与==、===</h6>
<ul>
<li><font color="red">数值NaN是唯一一个非自反</font>
<ul>
<li>x === x不成立</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>) <span class="hljs-comment">//false</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>) <span class="hljs-comment">//false</span>
</div></code></pre>
<h6 id="23412-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%80%BC%E6%98%AF%E4%B8%8D%E6%98%AFnan%E7%9A%84%E6%96%B9%E6%B3%95----numberisnan">2.3.4.1.2 判断一个值是不是NaN的方法 -- Number.isNaN</h6>
<ul>
<li>运用isNaN，舍弃</li>
<li>只适用于ES6</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-literal">NaN</span>;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.isNaN(a))
</div></code></pre>
<ul>
<li>内部实现的步骤（利用自反的性质）</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Number</span>.isNaN) {
        <span class="hljs-built_in">Number</span>.isNaN = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
            <span class="hljs-keyword">return</span> n !== n
        }
    }
</div></code></pre>
<h5 id="2342-%E6%97%A0%E7%A9%B7%E6%95%B0">2.3.4.2 无穷数</h5>
<ul>
<li>Infinity -Infinity</li>
<li>js中有固定的属性进行定义
<ul>
<li>Number.INFINITY</li>
<li>Number.NAGATIVE_INFINITY</li>
</ul>
</li>
</ul>
<h6 id="23421-js%E4%B8%AD%E9%99%A4%E4%BB%A50%E4%B8%BA%E6%97%A0%E7%A9%B7%E5%80%BC">2.3.4.2.1 js中除以0为无穷值</h6>
<pre class="hljs"><code><div>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>) <span class="hljs-comment">// Infinity</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">-1</span> / <span class="hljs-number">0</span>) <span class="hljs-comment">// -Infinity</span>
</div></code></pre>
<ul>
<li>可以用于分辨(+/-)0</li>
</ul>
<h6 id="23422-js%E4%B8%AD%E5%BD%93%E6%89%80%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%80%BC%E8%B6%85%E8%BF%87numbermaxvalue%E6%97%B6%E4%B8%BA%E6%97%A0%E7%A9%B7%E5%80%BC">2.3.4.2.2 js中当所表示的值超过Number.MAX_VALUE时，为无穷值</h6>
<h6 id="23423-js%E4%B8%AD%E6%97%A0%E7%A9%B7%E9%99%A4%E4%BB%A5%E6%97%A0%E7%A9%B7%E4%B8%BAnan">2.3.4.2.3 js中无穷除以无穷为NaN</h6>
<h5 id="2343-%E9%9B%B6%E5%80%BC">2.3.4.3 零值(+/-)</h5>
<ul>
<li>包含+0和-0</li>
</ul>
<h6 id="23431--0%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%BA%E5%90%88">2.3.4.3.1 -0出现的场合</h6>
<ul>
<li>自己赋值</li>
<li>在一些运算中 0 * 负数  | 0 / 负数
<ul>
<li>加减法不会得到-0</li>
</ul>
</li>
</ul>
<h6 id="23432-%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E5%AF%B9-0%E7%9A%84%E5%A4%84%E7%90%86">2.3.4.3.2 常见函数对-0的处理</h6>
<ul>
<li>-0转化为字符串(不保留符号)</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">-0</span>;
    a.toString(); <span class="hljs-comment">// "0"</span>
    a + <span class="hljs-string">""</span>; <span class="hljs-comment">// "0"</span>
    <span class="hljs-built_in">String</span>( a ); <span class="hljs-comment">// "0"</span>

    <span class="hljs-built_in">JSON</span>.stringify( a ); <span class="hljs-comment">// "0"</span>
</div></code></pre>
<ul>
<li>字符串-0转化为数值</li>
</ul>
<pre class="hljs"><code><div>    +<span class="hljs-string">"-0"</span>; <span class="hljs-comment">// -0</span>
    <span class="hljs-built_in">Number</span>( <span class="hljs-string">"-0"</span> ); <span class="hljs-comment">// -0</span>
    <span class="hljs-built_in">JSON</span>.parse( <span class="hljs-string">"-0"</span> ); <span class="hljs-comment">// -0</span>
</div></code></pre>
<h6 id="23433--0%E4%B8%8E0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB">2.3.4.3.3 -0与0之间的大小关系</h6>
<ul>
<li>==、===结果都返回true</li>
</ul>
<h6 id="23434-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E5%80%BC%E6%98%AF-0">2.3.4.3.4 如何判断数值是-0</h6>
<ul>
<li>法一：构建函数
<ul>
<li>利用-0与-Inifity的关系</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNegZero</span>(<span class="hljs-params">n</span>) </span>{
        n = <span class="hljs-built_in">Number</span>(n);
        <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1</span> / n === -Inifity
    }
</div></code></pre>
<h5 id="2343-%E7%89%B9%E6%AE%8A%E7%AD%89%E5%BC%8Fobjectisv1-v2">2.3.4.3 特殊等式Object.is(v1, v2)</h5>
<ul>
<li>经常用于判断-0以及NaN，其他一般用==或者===</li>
<li>源码</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.is) {
        <span class="hljs-built_in">Object</span>.is = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v1, v2</span>) </span>{
            <span class="hljs-comment">// 判断是否是-0</span>
            <span class="hljs-keyword">if</span> (v1 === <span class="hljs-number">0</span> &amp;&amp; v2 === <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / v1 === <span class="hljs-number">1</span> / v2;
                }
            <span class="hljs-comment">// 判断是否是NaN</span>
            <span class="hljs-keyword">if</span> (v1 !== v1) {
                <span class="hljs-keyword">return</span> v2 !== v2;
            }
            <span class="hljs-comment">// 其他情况</span>
            <span class="hljs-keyword">return</span> v1 === v2;
        };
    }
</div></code></pre>
<h3 id="24-%E4%B8%8D%E6%98%AF%E5%80%BC%E7%9A%84%E5%80%BCundefinednull">2.4 不是值的值(undefined,null)</h3>
<h4 id="241-undefined%E5%92%8Cnull%E7%9A%84%E5%BC%82%E5%90%8C">2.4.1 undefined和null的异同</h4>
<ul>
<li>相同
<ul>
<li>undefined和null：类型只有一个值，即是undefined/null,既是类型也是值</li>
</ul>
</li>
<li>不同
<ul>
<li>null表示空值(empty value)，undefined表示没有值（missing value）
<ul>
<li>空值表示赋过值，但此时值为空</li>
<li>没有值表示没有赋过值</li>
</ul>
</li>
<li>null是一个特殊的关键字，不能进行赋值,<font color="red">undefined可以作为标识符，当作变量来使用和赋值</font></li>
</ul>
</li>
</ul>
<h4 id="242-%E4%BD%9C%E4%B8%BA%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84undefined">2.4.2 作为标识符和变量的undefined</h4>
<ul>
<li>在非严格模式下可以把undefined作为标识符进行赋值，而严格模式下会报TypeError的错误</li>
<li>在非严格和严格模式下可以声明一个局部变量undefined,用它进行计算</li>
<li><font color="red">虽然undefined可以作为标识符或者变量，但是永远不要重新定义undefined</font></li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; 
        <span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span>)
    }
    foo();
    <span class="hljs-comment">// 2</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-string">"use strict"</span>;
        <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// TypeError!</span>
    }
    foo();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-string">"use strict"</span>;
        <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>;
        <span class="hljs-built_in">console</span>.log( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// 2</span>
    }
    foo();
</div></code></pre>
<ul>
<li>与undefined相关的运算符--void</li>
<li>void运算符可以得到undefined标识符的返回值
<ul>
<li>void + 表达式
<ul>
<li>返回值为内置undefined的值即undefined
<ul>
<li>作用：使得表达式的返回值为undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
    <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">void</span> a, a ); <span class="hljs-comment">// undefined 42</span>
</div></code></pre>
<h2 id="3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8">3 数据类型和赋值，引用</h2>
<ul>
<li>变量的赋值和参数的传递两种形式
<ul>
<li>值赋值
<ul>
<li>重新申请一块存储区域，并将值变为和赋的值相同</li>
</ul>
</li>
<li>引用复制
<ul>
<li>只将存储值的地址赋给变量</li>
</ul>
</li>
</ul>
</li>
<li>规则
<ul>
<li>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括null、undefined、字符串、数字、布尔和 ES6 中的 symbol。</li>
<li>复合值（compound value）——对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来赋值 / 传递。</li>
</ul>
</li>
</ul>
<h3 id="31-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F">3.1 函数的参数的值传递方式</h3>
<ul>
<li>函数参数的传递方式仍然符合上面的规则，但是有要注意的地方</li>
<li><font color="red">对引用复制的参数执行赋值操作</font>
<ul>
<li>函数内的参数由于赋值之后指向其他存储地址，但是原来的参数指向的地址并没有改变</li>
<li><img src="./img/ex4.jpeg" alt="ex4.jpeg"></li>
<li>若想要让函数参数指向的是相应的地址，<font color="red">在函数操作的时候不能对传入的参数执行赋值操作</font></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
        x.push( <span class="hljs-number">4</span> );
        x; <span class="hljs-comment">// [1,2,3,4]</span>
        <span class="hljs-comment">// 然后</span>
        x = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
        x.push( <span class="hljs-number">7</span> );
        x; <span class="hljs-comment">// [4,5,6,7]</span>
    }
    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
    foo( a );
    a; <span class="hljs-comment">// 是[1,2,3,4]，不是[4,5,6,7]</span>
</div></code></pre>
<ul>
<li>数组可以采用arr.slice()使得传递的是另一个地址，从而不改变原地址的数组
<ul>
<li>即可以通过传递副本的方法使得不改变原本的值</li>
</ul>
</li>
</ul>
<h3 id="32-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85">3.2 函数的参数的传递封装对象（对基本类型进行封装）</h3>
<ul>
<li>进行表达式的运算时，结果会返回对应的封装对象而不是基本类型</li>
<li>同样不能进行赋值操作，否则会指向新的内存地址</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
        x = x + <span class="hljs-number">1</span>;
        x; <span class="hljs-comment">// 3</span>
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>( a ); <span class="hljs-comment">// Object(a)也一样</span>
    foo( b );
    <span class="hljs-built_in">console</span>.log( b ); <span class="hljs-comment">// 是2，不是3</span>
</div></code></pre>
<h3 id="33-%E6%80%BB%E7%BB%93">3.3 总结</h3>
<ul>
<li>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的行为特征不同，在将字符作为数组来处理时需要特别小心。</li>
<li>JavaScript 中的数字包括“整数”和“浮点型”。</li>
<li>null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之前默认值都是 undefined。void 运算符返回 undefined。</li>
<li>数 字 类 型 有 几 个 特 殊 值， 包 括 NaN（ 意 指“not a number”， 更 确 切 地 说 是“invalid number”）、+Infinity、-Infinity 和 -0。</li>
<li>简单标量基本类型值（字符串和数字等）通过值复制来赋值 / 传递，而复合值（对象等）通过引用复制来赋值 / 传递。</li>
<li>JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不能指向别的变量 / 引用，只能指向值。</li>
</ul>
<h2 id="4-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0">4 原生函数</h2>
<ul>
<li>常见的原生函数 --- 用于构造封装对象
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Array()</li>
<li>Object()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Date()</li>
<li>Error()</li>
<li>Symbol()——ES6 中新加入的！</li>
</ul>
</li>
</ul>
<h3 id="41-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1">4.1 基本类型的封装对象</h3>
<ul>
<li>我们可以先对基本类型封装成对象以来调用对应的方法，但是js并不这样建议，直接使用封装对象来“提前优化”代码反而会降低执行效率。因为返回值都是基本类型，你这样又要进行封装</li>
<li>基本类型在调用相应的函数时，
<ul>
<li>js会自动对基本数据类型进行封装后再调用相应的函数</li>
</ul>
</li>
</ul>
<h3 id="42-%E6%8B%86%E5%B0%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1">4.2 拆封基本类型的封装对象</h3>
<ul>
<li>obj.valueOf()z
<ul>
<li>返回相应的基本类型</li>
</ul>
</li>
<li>隐式拆封
<ul>
<li>在表达式中，有时候需要进行隐式拆分</li>
</ul>
</li>
</ul>
<h3 id="43-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85">4.3 原生函数作为构造函数构建对象进行封装</h3>
<ul>
<li>一般情况下，我们采用的是字面量对数据类型进行定义（包括复杂基本类型）</li>
<li>利用new 原生函数构建的是一个对象而不是对应的值</li>
</ul>
<h4 id="431-array%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.1 Array作为构造函数</h4>
<ul>
<li><font color="red">不要只用一个数字最为Array的构造参数</font></li>
<li>Array可以带不带new都可以</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> );
    <span class="hljs-comment">// 参数列表， arr</span>
    a; <span class="hljs-comment">// [1, 2, 3]</span>
    <span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    b; <span class="hljs-comment">// [1, 2, 3]</span>
</div></code></pre>
<h5 id="4311-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%8F%AA%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E4%BD%9C%E4%B8%BAarray%E7%9A%84%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0">4.3.1.1 为什么不能只用一个数字作为Array的构造参数</h5>
<ul>
<li>该参数会作为该Array的预设长度
<ul>
<li>创建出的数组是空数组，但是有长度</li>
</ul>
</li>
<li>如若一个数组没有任何单元，但它的 length 属性中却显示有单元数量，这样奇特的数据结构会导致一些怪异的行为, 可以用以下的方法来解决这种行为</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Array</span>.apply( <span class="hljs-literal">null</span>, { <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> } );
    <span class="hljs-comment">// 通过该方法来构建长度为3的参数</span>
    <span class="hljs-comment">// 相当于Array(undefined, undefined, undefined)</span>
</div></code></pre>
<h4 id="432-regexp%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%83%85%E5%86%B5">4.3.2 RegExp作为构造函数的情况</h4>
<ul>
<li>强烈建议使用常量形式（如 /^a*b+/g）来定义正则表达式</li>
<li>但是定义动态正则表达式时
<ul>
<li>RegExp(&quot;pattern&quot;,&quot;flags&quot;)
<ul>
<li>pattern可以是string，reg类型</li>
<li>flags
<ul>
<li>g: 全局匹配</li>
<li>i：忽略大小写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Kyle"</span>;
    <span class="hljs-keyword">var</span> namePattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"\\b(?:"</span> + name + <span class="hljs-string">")+\\b"</span>, <span class="hljs-string">"ig"</span> );
    <span class="hljs-keyword">var</span> matches = someText.match( namePattern );
</div></code></pre>
<h4 id="433-date%E5%92%8Cerror%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.3 Date和Error作为构造函数</h4>
<ul>
<li>由于没有对应的常量形式作为体代，所以经常作为构造函数。</li>
<li>创建日期对象必须使用 new Date()。Date(..) 可以带参数，用来指定日期和时间.</li>
</ul>
<h5 id="4331-date%E7%94%A8%E4%BA%8E%E6%A0%B9%E6%8D%AE%E6%97%B6%E9%97%B4%E5%88%9B%E5%BB%BA%E9%9A%8F%E6%9C%BA%E6%95%B0">4.3.3.1 Date用于根据时间创建随机数</h5>
<ul>
<li>Date获取从1970年到现在的毫秒数
<ul>
<li>Date.now()</li>
<li>new Date() .getTime()</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.now)

    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Date</span>.now) {
        <span class="hljs-built_in">Date</span>.now = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
        }
    }
</div></code></pre>
<h5 id="4332-error%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.3.2 Error作为构造函数</h5>
<ul>
<li>带不带new都可以</li>
<li>创建错误对象（error object）主要是为了获得当前运行栈的上下文
<ul>
<li>栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。</li>
</ul>
</li>
</ul>
<h4 id="434-symbol%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.3.4 Symbol作为构造函数</h4>
<ul>
<li>可以自定义Symbol
<ul>
<li>在自定义Symbol属性时，<font color="red">千万不要用new符号</font></li>
</ul>
</li>
<li>可以使用一些已经预定好的symbol
<ul>
<li>Symbol.create</li>
<li>Symbol.iterator</li>
</ul>
</li>
<li>ES6 中新加入了一个基本数据类型 ——符号（Symbol）。</li>
<li>作用
<ul>
<li>符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。</li>
</ul>
</li>
</ul>
<h5 id="4341-symbol%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D">4.3.4.1 Symbol类型作为属性名</h5>
<ul>
<li>符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会显示为诸如 Symbol(Symbol.create) 这样的值。它却主要用于私有或特殊属性。<font color="red">属于无法枚举的属性</font>
<ul>
<li>无法通过Object.keys()获得对应的属性</li>
</ul>
</li>
<li>自定义
<ul>
<li>虽然然符号实际上并非私有属性（通过 Object.getOwnPropertySymbols(..) 便可以公开获得对象中的所有符号）</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> mysym = <span class="hljs-built_in">Symbol</span>( <span class="hljs-string">"my own symbol"</span> );
    mysym; <span class="hljs-comment">// Symbol(my own symbol)</span>
    mysym.toString(); <span class="hljs-comment">// "Symbol(my own symbol)"</span>
    <span class="hljs-keyword">typeof</span> mysym; <span class="hljs-comment">// "symbol"</span>
</div></code></pre>
<ul>
<li>使用已经定义好的Symbol</li>
</ul>
<pre class="hljs"><code><div>    obj[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">/*..*/</span> };
</div></code></pre>
<h6 id="43411-%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84symbol%E5%B1%9E%E6%80%A7">4.3.4.1.1 访问对象的Symbol属性</h6>
<ul>
<li>无法使用Object.keys()得到Symbol属性值，但可以用
<ul>
<li>通过 Object.getOwnPropertySymbols(..) 便可以公开获得对象中的所有符号</li>
</ul>
</li>
<li>访问属性值只能用[]的形式</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> mysym = <span class="hljs-built_in">Symbol</span>( <span class="hljs-string">"my own symbol"</span> );
    mysym; <span class="hljs-comment">// Symbol(my own symbol)</span>
    mysym.toString(); <span class="hljs-comment">// "Symbol(my own symbol)"</span>
    <span class="hljs-keyword">typeof</span> mysym; <span class="hljs-comment">// "symbol"</span>

    <span class="hljs-keyword">var</span> a = { };
    a[mysym] = <span class="hljs-string">"foobar"</span>;
    <span class="hljs-built_in">Object</span>.getOwnPropertySymbols( a );
    <span class="hljs-comment">// [ Symbol(my own symbol) ]</span>
</div></code></pre>
<h3 id="44-objecttostringcallobj">4.4 Object#toString.call(obj)</h3>
<ul>
<li>所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。</li>
<li>返回值为字符串[object, 内部类]</li>
<li>obj为基本类型
<ul>
<li>null和undefined
<ul>
<li>虽然没有对应的内部类，但仍然会返回[object, null] [object, undefined]</li>
</ul>
</li>
<li>其他基本类型
<ul>
<li>得到一个对象的内部属性[object [ Class ]]
<ul>
<li>即会先将用new进行自动封装</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>obj为符合类型
<ul>
<li>得到一个对象的内部属性[object [ Class ]]</li>
<li>Class: 构造函数的名称</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-comment">// 1. undefined和null</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( <span class="hljs-literal">null</span> );
    <span class="hljs-comment">// "[object Null]"</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( <span class="hljs-literal">undefined</span> );
    <span class="hljs-comment">// "[object Undefined]"</span>
    <span class="hljs-comment">// 2. 基本类型</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( <span class="hljs-string">"abc"</span> );
    <span class="hljs-comment">// "[object String]"</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( <span class="hljs-number">42</span> );
    <span class="hljs-comment">// "[object Number]"</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( <span class="hljs-literal">true</span> );
    <span class="hljs-comment">// "[object Boolean]"</span>

    <span class="hljs-comment">// 3. 复合类型</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] );
    <span class="hljs-comment">// "[object Array]"</span>
    <span class="hljs-built_in">Object</span>.prototype.toString.call( <span class="hljs-regexp">/regex-literal/i</span> );
    <span class="hljs-comment">// "[object RegExp]"</span>
</div></code></pre>
<h3 id="45-%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B">4.5 原生函数的原型</h3>
<ul>
<li>原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype
<ul>
<li>字符串值封装为字符串对象之后，就能访问 String.prototype 中定义的方法</li>
</ul>
</li>
<li>所有的函数都可以调用 Function.prototype 中的 apply(..)、call(..) 和 bind(..),来时实现对具体的对象调用对应的方法</li>
<li>原生函数的原型对象只能由其实例来进行调用</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">String</span>#indexOf(..)
    在字符串中找到指定子字符串的位置。
    <span class="hljs-built_in">String</span>#charAt(..)
    获得字符串指定位置上的字符。
    <span class="hljs-built_in">String</span>#substr(..)、<span class="hljs-built_in">String</span>#substring(..) 和 <span class="hljs-built_in">String</span>#slice(..)
    获得字符串的指定部分。
    <span class="hljs-built_in">String</span>#toUpperCase() 和 <span class="hljs-built_in">String</span>#toLowerCase()
    将字符串转换为大写或小写。
    <span class="hljs-built_in">String</span>#trim()
    去掉字符串前后的空格，返回新的字符串。

    <span class="hljs-comment">// 以上方法并不改变原字符串的值，而是返回一个新字符串</span>
</div></code></pre>
<h4 id="451-%E6%9C%89%E4%BA%9B%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AF%B9%E8%B1%A1">4.5.1 有些原型对象并不一定是对象</h4>
<ul>
<li>对应类型的空值
<ul>
<li>Function.prototype
<ul>
<li>函数类型，且为空函数</li>
</ul>
</li>
<li>Array.prototype
<ul>
<li>Array类型，且为空数组</li>
</ul>
</li>
<li>RegExp.prototype
<ul>
<li>RegExp类型，且为空正则表达式</li>
</ul>
</li>
</ul>
</li>
<li>可以用于作为默认值
<ul>
<li>从 ES6 开始，我们不再需要使用 vals = vals || .. 这样的方式来设置默认
值（参见第 4 章），因为默认值可以通过函数声明中的内置语法来设置</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> vals = <span class="hljs-built_in">Array</span>.prototype;
    <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">Function</span>.prototype;
    <span class="hljs-keyword">var</span> rx = <span class="hljs-built_in">RegExp</span>.prototype;
</div></code></pre>
<h3 id="46-%E6%80%BB%E7%BB%93">4.6 总结</h3>
<ul>
<li>JavaScript 为基本数据类型值提供了封装对象，称为原生函数（如 String、Number、Boolean等）。它们为基本数据类型值提供了该子类型所特有的方法和属性（如：String#trim() 和Array#concat(..)）</li>
<li>对于简单标量基本类型值，比如 &quot;abc&quot;，如果要访问它的 length 属性或 String.prototype
方法，JavaScript 引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实现对这些属性和方法的访问。</li>
</ul>
<h2 id="5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5 类型转换</h2>
<ul>
<li>JavaScript 中的强制类型转换总是返回标量基本类型值</li>
</ul>
<h3 id="51-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.1 类型转换和强制类型转换</h3>
<ul>
<li>类型转换
<ul>
<li>显示类型转换</li>
<li>发生在静态类型语言的编译阶段</li>
</ul>
</li>
<li>强制类型转换
<ul>
<li>隐式类型转换</li>
<li>动态类型语言的运行时</li>
</ul>
</li>
</ul>
<h3 id="52-%E6%95%B0%E5%80%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%83%E5%B0%94%E5%80%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99">5.2 数值，字符串，布尔值之间的类型转化规则</h3>
<h4 id="521-tostring%E8%A7%84%E5%88%99">5.2.1 ToString规则</h4>
<ul>
<li>非字符串到字符串的类型转换</li>
<li><img src="./img/toString_rule.jpeg" alt="规则"></li>
<li>规则：
<ul>
<li>基本数据类型：
<ul>
<li>null, undefined
<ul>
<li>null --&gt; &quot;null&quot;，undefined --&gt; &quot;undefined&quot;</li>
</ul>
</li>
<li>boolean
<ul>
<li>true --&gt; &quot;true&quot;, false --&gt; &quot;false&quot;</li>
</ul>
</li>
<li>number
<ul>
<li>n --&gt; &quot;n&quot;</li>
<li>NaN --&gt; &quot;NaN&quot;</li>
<li>极大数和极小数--&gt;转化为科学计数法</li>
</ul>
</li>
<li>symbol
<ul>
<li>sym --&gt; &quot;Symbol(sym)&quot;</li>
</ul>
</li>
</ul>
</li>
<li>对象
<ul>
<li>调用抽象函数ToPrimitive()，是否有valueOf()
<ul>
<li>有valueOf（封装对象）：放回对应的valueOf的值，然后按照基本数据类型的规则进行转化</li>
<li>没有valueOf（非封装对象），是否有toString函数
<ul>
<li>返回toString的值</li>
<li>若没有toString函数，则默认调用有Object.prototype.toString.call(obj), 返回&quot;[ object, [[ Class ]]]&quot;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = {};
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(a));
        <span class="hljs-comment">// [object Object]</span>
    <span class="hljs-keyword">var</span> b = {
        <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">d</span>: <span class="hljs-number">3</span>,
        toString() {
            <span class="hljs-keyword">var</span> str = <span class="hljs-string">""</span>;
            <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">this</span>).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>[key] !== <span class="hljs-string">"function"</span>)
                    str = str + key + <span class="hljs-string">": "</span> + <span class="hljs-keyword">this</span>[key] + <span class="hljs-string">" "</span>;
            })
            <span class="hljs-keyword">return</span> str;
        }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(b));
        <span class="hljs-comment">// c: 2 d: 3 </span>
</div></code></pre>
<ul>
<li>注意：
<ul>
<li>[null] --&gt; &quot;&quot;（空字符串）</li>
<li>[undefined] --&gt; &quot;&quot;（空字符串）</li>
</ul>
</li>
</ul>
<h5 id="5211-jsonstringifyobj">5.2.1.1 JSON.stringify(obj)</h5>
<ul>
<li>不属于强制转换类型，但是结果是返回一个string类型</li>
<li>(1) string，number，null，boolean的 JSON.stringify(..) 规则与 ToString 基本相同。</li>
<li>(2) 若要转化的是对象时
<ul>
<li>判断是否有toJSON函数，调用toJSON函数得到结果</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-number">42</span> ); <span class="hljs-comment">// "42"</span>
    <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-string">"42"</span> ); <span class="hljs-comment">// ""42"" （含有双引号的字符串）</span>
    <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// "null"</span>
    <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-literal">true</span> ); <span class="hljs-comment">// "true"</span>
</div></code></pre>
<ul>
<li>不安全的JSON值
<ul>
<li>undefined、function、symbol（ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON结构标准
<ul>
<li>在对象中遇到 undefined、function 和 symbol 时会自动将其忽略</li>
<li>在数组中遇到 undefined、function 和 symbol 时则会返回 null</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// undefined</span>
    <span class="hljs-built_in">JSON</span>.stringify( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{} ); <span class="hljs-comment">// undefined</span>
    <span class="hljs-built_in">JSON</span>.stringify(
        [<span class="hljs-number">1</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},<span class="hljs-number">4</span>]
    ); <span class="hljs-comment">// "[1,null,null,4]"</span>
    <span class="hljs-built_in">JSON</span>.stringify(
        { <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{} }
    ); <span class="hljs-comment">// "{"a":2}"</span>
</div></code></pre>
<h5 id="52111-jsonstringifyobj%E9%92%88%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1">5.2.1.1.1 JSON.stringify(obj)针对于对象</h5>
<ul>
<li>自定义JSON的输出
<ul>
<li>条件
<ul>
<li>如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的 JSON 值(不会报错)</li>
<li>某些属性不想被JSON化</li>
</ul>
</li>
</ul>
</li>
<li>定义obj.toJSON()函数
<ul>
<li>返回一个能够被字符串化的安全的 JSON 值，再由 JSON.stringify(..) 对其进行字符串化
<ul>
<li>返回的可以是安全的JSON值，即任何类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = {
        <span class="hljs-attr">b</span>: <span class="hljs-number">5</span>,
        <span class="hljs-attr">c</span>: <span class="hljs-number">4</span>
    }
    <span class="hljs-comment">// 只JSON化对象和对应的b属性</span>
    a.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">b</span>: <span class="hljs-keyword">this</span>.b
        }
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(a))
    <span class="hljs-comment">// </span>

</div></code></pre>
<ul>
<li>使用JSON.stringify(obj[, replacer[, space]])
<ul>
<li>参数replacer
<ul>
<li>如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。</li>
<li>如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值</li>
</ul>
</li>
<li>参数space(string/number)
<ul>
<li>键值前面个的空格的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = {
        <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,
        <span class="hljs-attr">c</span>: <span class="hljs-string">"42"</span>,
        <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
    };
    <span class="hljs-built_in">JSON</span>.stringify( a, [<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>] ); <span class="hljs-comment">// "{"b":42,"c":"42"}"</span>
    <span class="hljs-built_in">JSON</span>.stringify( a, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k,v</span>)</span>{
        <span class="hljs-keyword">if</span> (k !== <span class="hljs-string">"c"</span>) <span class="hljs-keyword">return</span> v;
    } );
    <span class="hljs-comment">// "{"b":42,"d":[1,2,3]}"</span>
</div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = {
        <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,
        <span class="hljs-attr">c</span>: <span class="hljs-string">"42"</span>,
        <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
    };
    <span class="hljs-built_in">JSON</span>.stringify( a, <span class="hljs-literal">null</span>, <span class="hljs-string">"-----"</span> );
    <span class="hljs-comment">// "{</span>
    <span class="hljs-comment">// -----"b": 42,</span>
    <span class="hljs-comment">// -----"c": "42",</span>
    <span class="hljs-comment">// -----"d": [</span>
    <span class="hljs-comment">// ----------1,</span>
    <span class="hljs-comment">// ----------2,</span>
    <span class="hljs-comment">// ----------3</span>
    <span class="hljs-comment">// -----]</span>
    <span class="hljs-comment">// }"</span>
</div></code></pre>
<h4 id="522-tonumber%E8%A7%84%E5%88%99">5.2.2 ToNumber规则</h4>
<ul>
<li>非数字类型到数字类型的转化</li>
<li><img src="./img/toNumber_rule.jpeg" alt="toNumber_rule">;</li>
<li>规则
<ul>
<li>基本数据类型
<ul>
<li>true 转换为 1，false 转换为 0。</li>
<li>undefined 转换为 NaN，null 转换为 0</li>
<li>string
<ul>
<li>符合Number语法规则的string，转化为对应的数字</li>
<li>不符合语法规则返回NaN</li>
<li>空字符串，返回0</li>
</ul>
</li>
</ul>
</li>
<li>对象
<ul>
<li>调用抽象操作 ToPrimitive, 检查是否有valueOf()
<ul>
<li>封装对象(有valueOf函数)
<ul>
<li>被转换为相应的基本类型值，如果返回的是非数字的基本类型值，遵循基本数据类型转化</li>
</ul>
</li>
<li>非封装对象（无valueOf函数），检查是否有toString()函数
<ul>
<li>如果有，返回toString函数的值，并且调用string的转化规则</li>
<li>如果没有，则返回TypeError</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(a)) <span class="hljs-comment">// NaN</span>
    <span class="hljs-comment">/**
    *   无valueOf函数
    *   有toString函数："1,3,4"
    *   string不符合Number语法：返回NaN
    */</span>
    <span class="hljs-keyword">var</span> b = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}   <span class="hljs-comment">// NaN</span>
    <span class="hljs-comment">/**
    *   无valueOf函数
    *   有toString函数:Object#toString.call(a) [object, object]
    *   string不符合Number语法：返回NaN
    */</span>
    <span class="hljs-keyword">var</span> c = <span class="hljs-string">"134"</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">console</span>.log(c)) <span class="hljs-comment">// 134</span>

    <span class="hljs-keyword">var</span> d = []
    <span class="hljs-comment">/**
    *   无valueOf函数
    *   有toString函数：""
    *   string为空，返回0
    */</span>
</div></code></pre>
<h4 id="523-toboolean%E8%A7%84%E5%88%99">5.2.3 ToBoolean规则</h4>
<ul>
<li><img src="./img/ex6.jpeg" alt="规则"></li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(a));
    <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">var</span> b = [];
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(b))
    <span class="hljs-comment">// true</span>
</div></code></pre>
<h5 id="4231-%E5%81%87%E5%80%BC">4.2.3.1 假值</h5>
<ul>
<li>假值对象（对以下的情况进行封装的对象）</li>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0、-0 和 NaN</li>
<li>&quot;&quot;</li>
</ul>
<h3 id="53-%E6%98%BE%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.3 显式强制类型转换</h3>
<h4 id="531-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">5.3.1 其他类型转换为字符串</h4>
<h5 id="4311-stringobj">4.3.1.1 String(obj)</h5>
<ul>
<li>运用了ToString规则进行转换为string</li>
</ul>
<h5 id="4312-objtostring">4.3.1.2 obj.toString()</h5>
<ul>
<li>若obj本身有toString函数，则可以用这种形式，返回相应的string</li>
<li>若没有，则采用Object#toString.call(obj)，结果返回[object, [[Class]]]</li>
</ul>
<h4 id="532-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%80%BC">5.3.2 其他类型转换为数值</h4>
<h5 id="5321-numberobj">5.3.2.1 Number(obj)</h5>
<ul>
<li>运用了ToNumber规则进行转换为number</li>
</ul>
<h5 id="5322-objtonumber">5.3.2.2 obj.toNumber()</h5>
<ul>
<li>若obj本身有toString函数，则可以用这种形式，返回相应的string</li>
</ul>
<h5 id="5323-parseintobj-radix-parsefloatobj">5.3.2.3 parseInt(obj, radix), parseFloat(obj)</h5>
<ul>
<li>注意ES5以前要注意写radix</li>
<li>和Number以及obj.toNumber要区别开来</li>
<li>其他过程和toNumber规则类似</li>
<li>区别在于对于string基本类型的处理
<ul>
<li>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(a));
    <span class="hljs-comment">// NaN</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">parseInt</span>(a));
    <span class="hljs-comment">// 1</span>
</div></code></pre>
<ul>
<li>特殊例子</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">parseInt</span>( <span class="hljs-number">0.000008</span> ); <span class="hljs-comment">// 0 ("0" 来自于 "0.000008")</span>
    <span class="hljs-built_in">parseInt</span>( <span class="hljs-number">0.0000008</span> ); <span class="hljs-comment">// 8 ("8" 来自于 "8e-7")</span>
    <span class="hljs-built_in">parseInt</span>( <span class="hljs-literal">false</span>, <span class="hljs-number">16</span> ); <span class="hljs-comment">// 250 ("fa" 来自于 "false")</span>
    <span class="hljs-built_in">parseInt</span>( <span class="hljs-built_in">parseInt</span>, <span class="hljs-number">16</span> ); <span class="hljs-comment">// 15 ("f" 来自于 "function..")</span>
    <span class="hljs-built_in">parseInt</span>( <span class="hljs-string">"0x10"</span> ); <span class="hljs-comment">// 16</span>
    <span class="hljs-built_in">parseInt</span>( <span class="hljs-string">"103"</span>, <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2</span>
</div></code></pre>
<h4 id="533-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">5.3.3 其他类型转换为布尔类型</h4>
<h5 id="5331-boolean">5.3.3.1 Boolean()</h5>
<ul>
<li>运用ToBoolean规则(不常用)</li>
</ul>
<h5 id="5332">5.3.3.2 !!</h5>
<ul>
<li>运用ToBoolean规则，将其他类型转化为boolean，实际上已经是隐式转化了</li>
</ul>
<h4 id="534-%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96">5.3.4 特殊符号的类型转化</h4>
<h5 id="5341">5.3.4.1 +</h5>
<ul>
<li>若+的左右运算数中都是number类型，则正常进行加法运算</li>
<li>若+的左右运算数中存在string类型，则非string类型会进行隐式转化，再进行拼接</li>
<li>若+的左右运算数中除了上述的两种情况，则两个运算数都会隐式转化为string类型，再进行拼接。</li>
</ul>
<h6 id="53411-%E8%BF%90%E7%94%A8%E5%8F%B7%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E5%8C%96">5.3.4.1.1 运用+号进行字符串的转化</h6>
<pre class="hljs"><code><div>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span> + <span class="hljs-string">''</span>)
  <span class="hljs-comment">// string</span>
</div></code></pre>
<h5 id="5342---%E6%95%B4%E6%95%B0">5.3.4.2 ~ + 整数</h5>
<ul>
<li>~符号的隐含操作（补码）
<ul>
<li>转换为32为有符号的整数</li>
<li>-(x + 1)</li>
</ul>
</li>
<li>应用，在查找是否有对应的index过程中, 可以将这样形式的判断转化为真假值的判断
<ul>
<li>如果有，则返回相应的index</li>
<li>没有，则返回-1</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a, value</span>) </span>{
        <span class="hljs-keyword">if</span>(~a.indexOf(value)) {
            <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">" in a"</span>);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Not in"</span>);
        }
    }  
    <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]

    foo(a, <span class="hljs-number">3</span>);
    foo(a, <span class="hljs-number">5</span>);
    <span class="hljs-comment">// 3 in a</span>
    <span class="hljs-comment">// Not in</span>

</div></code></pre>
<h3 id="54-%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.4 隐式强制类型转换</h3>
<h4 id="541-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96">5.4.1 常见的隐式转化</h4>
<h5 id="5411-%E5%9C%A8%E6%9C%89%E8%BF%90%E7%AE%97%E7%AC%A6">5.4.1.1 在有运算符+</h5>
<ul>
<li>隐式和显示是相对的，不是绝对的</li>
<li>+的操作符有一个是字符串类型
<ul>
<li>其他类型会先运用toString规则隐式转化为对应的string类型，再进行拼接</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = []
    <span class="hljs-built_in">console</span>.log([] + <span class="hljs-string">""</span>)
    <span class="hljs-comment">// ""</span>
    <span class="hljs-keyword">var</span> b = {};
    <span class="hljs-built_in">console</span>.log(b + <span class="hljs-string">""</span>)
    <span class="hljs-comment">// [object, Object]</span>
</div></code></pre>
<h5 id="5412-%E5%9C%A8%E6%9C%89%E8%BF%90%E7%AE%97%E7%AC%A6">5.4.1.2 在有运算符-</h5>
<ul>
<li>-的操作符有一个是Number类型
<ul>
<li>其他类型会先运用toNumber规则隐式转化为对应的number，再进行计算</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">100</span> - <span class="hljs-string">"95"</span>);
  <span class="hljs-comment">// 5</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">100</span> - <span class="hljs-string">'abc'</span>);
  <span class="hljs-comment">// NaN</span>
</div></code></pre>
<h5 id="5413-%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%B8%BAboolean%E7%B1%BB%E5%9E%8B">5.4.1.3 隐式转化为Boolean类型</h5>
<ul>
<li>(1) if (..) 语句中的条件判断表达式。</li>
<li>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</li>
<li>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。</li>
<li>(4) ? : 中的条件判断表达式。</li>
<li>(5) 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</li>
<li>(6) ||
<ul>
<li>注意不是返回true或者false，而是true变量的返回值</li>
<li>短路操作</li>
<li>返回值是第一个true的对应的值
<ul>
<li>即先转化为boolean类型判断真假，再返回相应的值</li>
</ul>
</li>
</ul>
</li>
<li>&amp;&amp;
<ul>
<li>短路操作</li>
<li>常用于判断是否存在某个属性，从而能执行相应的函数</li>
</ul>
</li>
</ul>
<h5 id="5414-%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96">5.4.1.4 符号类型的隐式转化</h5>
<ul>
<li>不符合规范</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"hello"</span>)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(a))
    <span class="hljs-comment">// "Symbol(hello)"</span>
    <span class="hljs-built_in">console</span>.log(a + <span class="hljs-string">""</span>) 
    <span class="hljs-comment">// TypeError</span>
</div></code></pre>
<h3 id="55-%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89%E5%92%8C%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E4%B8%8E%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96">5.5 宽松相等和严格相等与隐式转化</h3>
<ul>
<li>区别
<ul>
<li>== 允许在相等比较中进行强制类型转换，而 === 不允许</li>
</ul>
</li>
</ul>
<h4 id="551-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%84%E5%88%99">5.5.1 ==隐式类型转化的一般规则</h4>
<ul>
<li>方法（判断两侧的数据类型）
<ul>
<li>第一步：左右两侧都是对象类型，则判断对象 === 对象</li>
<li>第二步（以下方法存在优先级）
<ul>
<li>
<ol>
<li>存在对象类型，调用toString(obj)</li>
</ol>
</li>
<li>
<ol start="2">
<li>存在字符串类型，调用toNumebr(str)</li>
</ol>
</li>
<li>
<ol start="3">
<li>存在布尔类型，调用toNumber(boolean)</li>
</ol>
</li>
</ul>
</li>
<li>第三步
<ul>
<li>若左右两侧的基本类型相同，则判断左 === 右</li>
<li>若存在undefine，null，NaN则根据特殊规则进行判断</li>
</ul>
</li>
<li>第四步：循环步骤第二步，第三步知道左右两端的类型相同为止</li>
<li>采用查表的方式
<ul>
<li><img src="./img/equal.JPG" alt="比较表格"></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-number">2</span> == [<span class="hljs-number">2</span>]; <span class="hljs-comment">// true</span>
    <span class="hljs-comment">/**
    * 数值 == 对象
    * 2 == ToString([2]) --&gt; "2"
    * 数值 == 字符串
    * 2 == ToNumber("2") --&gt; 2
    *    true
    */</span>
    <span class="hljs-string">""</span> == [<span class="hljs-literal">null</span>]; <span class="hljs-comment">// true</span>
    <span class="hljs-comment">/**
    * 字符串 == 对象
    * "" == ToString([null]) --&gt; ""
    *    true
    */</span>

    <span class="hljs-number">42</span> == <span class="hljs-string">"43"</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    * 数值 == 字符串
    * 42 == ToNumber("43") --&gt; 43s
    *    false
    */</span>
    <span class="hljs-number">42</span> == <span class="hljs-string">"foo"</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    * 数值 == 字符串
    * 42 == ToNumber("foo") --&gt; NaN
    *    false
    */</span>
    <span class="hljs-string">"true"</span> == <span class="hljs-literal">true</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *  字符串 == 布尔值
    * ToNumber("true") --&gt; NaN == ToNumber(true) --&gt; 1
    *    false
    */</span>
    <span class="hljs-string">"foo"</span> == [ <span class="hljs-string">"foo"</span> ]; <span class="hljs-comment">// true</span>
    <span class="hljs-comment">/**
    *  字符串 == 对象
    * "foo" == ToString(["foo"]) --&gt; "foo"
    *    true
    */</span>
    
</div></code></pre>
<h5 id="4511-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E5%AE%BD%E6%9D%BE%E7%9B%B8%E7%AD%89">4.5.1.1 字符串和数字的宽松相等</h5>
<p>(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。
(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</p>
<ul>
<li>利用ToNumber规则将字符串转化为数字进行判断相等</li>
</ul>
<h5 id="4512-%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">4.5.1.2 其他类型和布尔类型</h5>
<p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；
(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p>
<ul>
<li>利用ToNumber将布尔类型转化为数字进行判断（可能还需要再接着转化）</li>
<li>千万不要出现a == true, b == false的形式，而是</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-comment">// 这样的显式用法没问题：</span>
    <span class="hljs-keyword">if</span> (a) {
    <span class="hljs-comment">// ..</span>
    }
    <span class="hljs-comment">// 这样的显式用法更好：</span>
    <span class="hljs-keyword">if</span> (!!a) {
    <span class="hljs-comment">// ..</span>
    }
    <span class="hljs-comment">// 这样的显式用法也很好：</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Boolean</span>( a )) {
    <span class="hljs-comment">// ..</span>
    }
</div></code></pre>
<h5 id="4513-null%E5%92%8Cundefined%E7%9A%84%E6%AF%94%E8%BE%83">4.5.1.3 null和undefined的比较</h5>
<p>(1) 如果 x 为 null，y 为 undefined，则结果为 true。
(2) 如果 x 为 undefined，y 为 null，则结果为 true。</p>
<ul>
<li>条件判断 a == null 仅在 doSomething() 返回非 null 和 undefined 时才成立</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = doSomething();
    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// ..</span>
    }
    <span class="hljs-comment">// 相当于</span>
    <span class="hljs-keyword">var</span> a = doSomething();
    <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span> || a === <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// ..</span>
    }
</div></code></pre>
<h5 id="4514-%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83">4.5.1.4 对象和非对象的比较</h5>
<p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；
(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p>
<ul>
<li>即将对象转化为基本类型再进行比较</li>
</ul>
<h5 id="4515-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5">4.5.1.5 特殊情况</h5>
<pre class="hljs"><code><div>    <span class="hljs-string">"0"</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   字符串 == null
    *   ToNumber("0")--&gt; 0 == null
    *   false
    */</span>
    <span class="hljs-string">"0"</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   字符串 == undefined
    *   ToNumber("0")--&gt; 0 == undefined
    *   false
    */</span>
    <span class="hljs-string">"0"</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">/**
    *   字符串 == 布尔
    *   "0" == ToNumber(false) -&gt; 0
    *   字符串 == 数值
    *   ToNumber("0")--&gt; 0 == 0
    *   True
    */</span>
    <span class="hljs-string">"0"</span> == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   字符串 == NaN
    *   ToNumber("0")--&gt; 0 == NaN
    *   false
    */</span>
    <span class="hljs-string">"0"</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
    <span class="hljs-comment">/**
    *   字符串 ==数值
    *   ToNumber("0")--&gt; 0 == 0
    *   true
    */</span>
    <span class="hljs-string">"0"</span> == <span class="hljs-string">""</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   字符串 == 字符串
    *   false
    */</span>

    <span class="hljs-literal">false</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   布尔值 == null
    *   ToNumber(false)--&gt; 0 == null
    *   false
    */</span>
    <span class="hljs-literal">false</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   布尔值 == undefined
    *   ToNumber(false)--&gt; 0 == undefined
    *   false
    */</span>
    <span class="hljs-literal">false</span> == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   布尔值 == NaN
    *   ToNumber(false)--&gt; 0 == NaN
    *   false
    */</span>
    <span class="hljs-literal">false</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">/**
    *   布尔值 == 数值
    *   ToNumber(false)--&gt; 0 == 0
    *   true
    */</span>
    <span class="hljs-literal">false</span> == <span class="hljs-string">""</span>; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">/**
    *   布尔值 == 字符串
    *   ToNumber(false)--&gt; 0 == ""
    *   数值 == 字符串
    *   0 == ToNumber("") --&gt; 0
    *   true
    */</span>
    <span class="hljs-literal">false</span> == []; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">/**
    *   布尔值 == 对象
    *   ToNumber(false)--&gt; 0 == []
    *   数值 == 字符串
    *   0 == ToNumber([]) --&gt; 0
    *   true
    */</span>
    <span class="hljs-literal">false</span> == {}; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   布尔值 == 对象
    *   ToNumber(false)--&gt; 0 == {}
    *   数值 == 字符串
    *   0 == ToNumber([]) --&gt; [object, Object] --&gt; NaN
    *   false
    */</span>

    <span class="hljs-string">""</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-string">""</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-string">""</span> == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-string">""</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">// toNumber("") -&gt; 0</span>
    <span class="hljs-string">""</span> == []; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">// toNumber("") -&gt; 0 toNumber([]) == 0</span>
    <span class="hljs-string">""</span> == {}; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">// toNumber("") -&gt; 0 toNumber([])</span>

    <span class="hljs-number">0</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-number">0</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-number">0</span> == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span>
    <span class="hljs-number">0</span> == []; <span class="hljs-comment">// true -- 晕！</span>
    <span class="hljs-comment">/**
    *   数值 == 对象
    *   0 == ToNumber([]) --&gt; 0
    *   true
    */</span>
    <span class="hljs-number">0</span> == {}; <span class="hljs-comment">// false</span>
    <span class="hljs-comment">/**
    *   数值 == 对象
    *   0 == ToNumber({}) --&gt; [object, Object] --&gt; NaN
    *   false
    */</span>

    [] == ![] <span class="hljs-comment">// true</span>
    <span class="hljs-comment">// !先执行，将其转化为对应的相反的布尔值：false, [] == false</span>
    <span class="hljs-comment">// 都ToNumber([]) --&gt; 0 == ToNumber(false) == 0</span>

</div></code></pre>
<h4 id="552-%E6%8A%BD%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%AF%94%E8%BE%83">5.5.2 抽象关系比较</h4>
<ul>
<li>=== 是没有对应的抽象关系比较的</li>
<li>a &lt;/&gt; b额隐式强制转化
<ul>
<li>比较双方都是字符串类型
<ul>
<li>如果比较双方都是字符串，则按字母顺序来进行比较</li>
</ul>
</li>
<li>其他情况
<ul>
<li>双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较</li>
</ul>
</li>
</ul>
</li>
<li>/&gt;=, &lt;=的在js中的处理方式</li>
<li>a &gt;= b 的result为 !(a &lt; b)</li>
<li>a &lt;= b 的result为 !(a &gt; b)</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = { <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> };
    <span class="hljs-keyword">var</span> b = { <span class="hljs-attr">b</span>: <span class="hljs-number">43</span> };

    a &lt; b; <span class="hljs-comment">// false</span>
    a == b; <span class="hljs-comment">// false</span>
    a &gt; b; <span class="hljs-comment">// false</span>

    a &lt;= b; <span class="hljs-comment">// true</span>
    <span class="hljs-comment">/*
    *  因为a&gt;b为false，所以取反为true
    */</span>
    a &gt;= b; <span class="hljs-comment">// true</span>
</div></code></pre>
<h4 id="553--%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">5.5.3 == 使用的注意事项</h4>
<ul>
<li>如果两边的值中有true或false，千万不要使用==</li>
<li>如果两边的值中有[],&quot;&quot;或者0, 尽量不要使用==</li>
</ul>
<h3 id="56-%E6%80%BB%E7%BB%93">5.6 总结</h3>
<ul>
<li>强制类型转换：包括显式和隐式</li>
<li>显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维护性。</li>
<li>隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。</li>
</ul>
<h1 id="%E4%B8%89-js%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">三 js的基础语法</h1>
<h2 id="1-%E6%95%B0%E7%BB%84">1. 数组</h2>
<ul>
<li>在js获取一个不存在的索引值，不会保存，结果为undefined</li>
</ul>
<h3 id="11-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95">1.1. 创建数组的两种方法</h3>
<ul>
<li>方法1 new Array(obj) / Array(obj)
<ul>
<li>obj
<ul>
<li>参数列表
<ul>
<li>不推荐只有一个参数,因为该参数是长度，不符合规则</li>
</ul>
</li>
<li>array</li>
</ul>
</li>
</ul>
</li>
<li>方法2 Array.of(obj) --- ES6
<ul>
<li>obj
<ul>
<li>参数列表</li>
<li>只有一个参数，该参数指的是第一个元素</li>
</ul>
</li>
<li>array</li>
</ul>
</li>
<li>方法3：字面量</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
  <span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.of(<span class="hljs-number">3</span>);
  <span class="hljs-keyword">let</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];

  <span class="hljs-built_in">console</span>.log(arr1);
  <span class="hljs-built_in">console</span>.log(arr2);
  <span class="hljs-built_in">console</span>.log(arr3);

  <span class="hljs-comment">// [1, 2, 3]</span>
  <span class="hljs-comment">// [3]</span>
  <span class="hljs-comment">// [1, 2, 4]</span>
</div></code></pre>
<h3 id="12-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">1.2 数组元素的增删改查</h3>
<h4 id="121-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%B7%BB%E5%8A%A0">1.2.1 数组元素的添加</h4>
<h4 id="1211-%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0">1.2.1.1 利用索引直接添加</h4>
<ul>
<li>js数组可以直接通过索引添加数组，其他没有被添加的数组则默认为undefined</li>
</ul>
<h4 id="1212-arraypushval">1.2.1.2 Array#push(...val)</h4>
<ul>
<li>向数组的后面添加val元素，返回undefined</li>
</ul>
<h4 id="1213-arrayunshiftval">1.2.1.3 Array#unshift(...val)</h4>
<ul>
<li>向数组的前面添加val元素，返回undefined</li>
</ul>
<h4 id="1214-arrayfillvalstart-end">1.2.1.4 Array#fill(val[start[, end]]);</h4>
<ul>
<li>填充[start, end)的元素为val
<ul>
<li>若没有start，则填充全部</li>
<li>若没有end，则从start开始填充到最后</li>
</ul>
</li>
</ul>
<h4 id="122-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4">1.2.2 数组元素的删除</h4>
<h4 id="1212-arraypop">1.2.1.2 Array#pop()</h4>
<ul>
<li>删除数组的最后一个元素，返回该元素，若数组为空，则返回undefined</li>
</ul>
<h4 id="1213-arrayunshift">1.2.1.3 Array#unshift()</h4>
<ul>
<li>删除数组的最前面一个元素，返回该元素，若数组为空，则返回undefined</li>
</ul>
<h4 id="123-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BF%AE%E6%94%B9">1.2.3 数组元素的修改</h4>
<h4 id="124-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE">1.2.4 数组元素的访问</h4>
<h5 id="1241-index">1.2.4.1 [index]</h5>
<ul>
<li>通过索引访问第index元素</li>
</ul>
<h5 id="1242-arrayindexofval">1.2.4.2 Array#indexOf（val)</h5>
<ul>
<li>返回值为val的元素的序列
<ul>
<li>若不存在，则返回-1</li>
</ul>
</li>
</ul>
<h3 id="13-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">1.3 数组的常用函数</h3>
<h4 id="131-arraylength">1.3.1 Array.length</h4>
<ul>
<li>返回数组当前的长度</li>
</ul>
<h4 id="132-arrayjoinseparator">1.3.2 Array#join([separator])</h4>
<ul>
<li>参数
<ul>
<li>sparator: 指定一个字符串来分隔数组的每个元素
<ul>
<li>默认值为','</li>
</ul>
</li>
</ul>
</li>
<li>返回用其分割的字符串</li>
</ul>
<h4 id="133-arraytostring">1.3.3 Array#toString()</h4>
<ul>
<li>返回以逗号分割的字符串</li>
</ul>
<h4 id="134-arrayslicebegin-end">1.3.4 Array#slice([begin, [end]])</h4>
<ul>
<li>参数
<ul>
<li>没有begin：截取整一个数组</li>
<li>begin: 从begin开始截取该数组
<ul>
<li>若没有end
<ul>
<li>begin为正数，从begin开始到最后</li>
<li>begin为负数，从倒数第i个到最后一个</li>
</ul>
</li>
</ul>
</li>
<li>end
<ul>
<li>到end结束，不包括end</li>
</ul>
</li>
</ul>
</li>
<li>返回[start,end)截取的数组</li>
</ul>
<h6 id="1341-%E4%BD%BF%E7%94%A8arrayslice%E5%B0%86%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84">1.3.4.1 使用Array#slice将类数组转化为数组</h6>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">list</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-comment">// return [].slice.call(arguments)</span>
  }

  <span class="hljs-keyword">var</span> list1 = list(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span>
</div></code></pre>
<h4 id="135-arraysplicestart-deletecount-item1-item2">1.3.5 Array#splice(start[, deleteCount[, item1[, item2[, ...]]]])</h4>
<ul>
<li>通过删除或替换现有元素或者原地添加新的元素来修改数组</li>
<li>返回
<ul>
<li>数组形式返回原数组中被修改的内容。</li>
</ul>
</li>
<li>参数
<ul>
<li>start：开始的index</li>
<li>deletCounet：删除的数量</li>
<li>item[1-n]:添入的元素</li>
</ul>
</li>
</ul>
<h5 id="1351-arraysplice%E7%9A%84%E5%BA%94%E7%94%A8">1.3.5.1 Array#splice的应用</h5>
<pre class="hljs"><code><div>  <span class="hljs-comment">// 1. 用于替换数组中的第index元素</span>
  <span class="hljs-comment">// Array#splice(index, 1, replacement)</span>
  <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"arr: "</span>, arr);
  arr.splice(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"arr: "</span>, arr);
<span class="hljs-comment">// [1, 2, 4]  [1, 3, 4]</span>

  <span class="hljs-comment">// 2. 用于向index插入元素</span>
  <span class="hljs-comment">// Array#splice(index, 0, addition)</span>
  <span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"arr1: "</span>, arr1);
  arr1.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"arr1: "</span>, arr1);
<span class="hljs-comment">// [1, 2, 4]  [1, 5]</span>

  <span class="hljs-comment">// 3. 删除index之后(包含index）的元素</span>
  <span class="hljs-comment">// Array#splice(index, Array.lenght - index)</span>
  <span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"arr2: "</span>, arr2);
  arr2.splice(<span class="hljs-number">1</span>, arr2.lenght - <span class="hljs-number">1</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"arr2: "</span>, arr2);
<span class="hljs-comment">// [1, 2, 4]  [1]</span>

</div></code></pre>
<h4 id="136-arraysortfunc">1.3.6 Array#sort([func])</h4>
<ul>
<li>排序后的数组。请注意，数组已原地排序，并且不进行复制。</li>
<li>func(ele1, ele2)
<ul>
<li>按照func函数进行排列
<ul>
<li>return 1 -- ele1,ele2的位置需要改变</li>
<li>return -1 -- ele1,ele2的位置是不需要改变</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>(value) {
      <span class="hljs-keyword">this</span>.value = value;
    }
  }
  <span class="hljs-keyword">const</span> arr = [<span class="hljs-keyword">new</span> Foo(<span class="hljs-number">3</span>), <span class="hljs-keyword">new</span> Foo(<span class="hljs-number">5</span>), <span class="hljs-keyword">new</span> Foo(<span class="hljs-number">4</span>)];
  <span class="hljs-comment">/*无法进行排序
  arr.sort();
  console.log(arr);
  */</span>
  arr.sort(<span class="hljs-function">(<span class="hljs-params">ele1, ele2</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span>(ele1.value &lt; ele2.value)
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  });
  <span class="hljs-built_in">console</span>.log(arr);

  <span class="hljs-comment">// 3，4，5</span>
</div></code></pre>
<h4 id="137-arrayreverse">1.3.7 Array#reverse()</h4>
<ul>
<li>返回颠倒后的数组</li>
</ul>
<h4 id="138-arrayconcatvalue1-value2--valuen">1.3.8 Array#concat(value1[, value2[, ...[, valueN]]])</h4>
<ul>
<li>参数
<ul>
<li>value[1-n]: 值或者数组</li>
</ul>
</li>
<li>返回连接后的数组
<ul>
<li>使用的是浅拷贝</li>
</ul>
</li>
</ul>
<h3 id="14-%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B">1.4 数组的函数编程</h3>
<h4 id="141-arrayforeachcallbackcurrentvalue--index--array-thisarg">1.4.1 Array#forEach(callback(currentValue [, index [, array]])[, thisArg])</h4>
<ul>
<li>遍历数组对象</li>
<li>返回undefined
<ul>
<li>里面的修改会影响原arr</li>
</ul>
</li>
<li>参数
<ul>
<li>callback
<ul>
<li>遍历的回调函数</li>
<li>注意三者的顺序</li>
</ul>
</li>
<li>thisArg
<ul>
<li>回调函数中this的指向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="142-arraymapcallbackcurrentvalue--index--array-thisarg">1.4.2 Array#map(callback(currentValue [, index [, array]])[, thisArg])</h4>
<ul>
<li>遍历数组对象并返回经过回调函数筛选（即结果为true）的数组
<ul>
<li>里面的修改不会影响原arr</li>
</ul>
</li>
<li>参数
<ul>
<li>callback
<ul>
<li>遍历的回调函数</li>
<li>注意三者的顺序</li>
</ul>
</li>
<li>thisArg
<ul>
<li>回调函数中this的指向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="143-arrayfiltercallbackcurrentvalue--index--array-thisarg">1.4.3 Array#filter(callback(currentValue [, index [, array]])[, thisArg])</h4>
<ul>
<li>遍历数组对象并返回经过回调函数筛选后的数组
<ul>
<li>里面的修改不会影响原arr</li>
</ul>
</li>
<li>参数
<ul>
<li>callback
<ul>
<li>遍历的回调函数，必须返回布尔值</li>
<li>注意三者的顺序</li>
</ul>
</li>
<li>thisArg
<ul>
<li>回调函数中this的指向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="144-arraysomecallbackelement-index-array-thisarg">1.4.4 Array#some(callback(element[, index[, array]])[, thisArg])</h4>
<ul>
<li>遍历数组对象并返回经过回调函数后的布尔值
<ul>
<li>若里面每一个都满足回调函数的条件，则返回true</li>
<li>里面的修改不会影响原arr</li>
</ul>
</li>
<li>参数
<ul>
<li>callback
<ul>
<li>遍历的回调函数，必须返回布尔值</li>
<li>注意三者的顺序</li>
</ul>
</li>
<li>thisArg
<ul>
<li>回调函数中this的指向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="145-arrayeverycallbackelement-index-array-thisarg">1.4.5 Array#every(callback(element[, index[, array]])[, thisArg])</h4>
<ul>
<li>遍历数组对象并返回经过回调函数后的布尔值
<ul>
<li>若里面存在满足回调函数的条件，则返回true</li>
<li>里面的修改不会影响原arr</li>
</ul>
</li>
<li>参数
<ul>
<li>callback
<ul>
<li>遍历的回调函数，必须返回布尔值</li>
<li>注意三者的顺序</li>
</ul>
</li>
<li>thisArg
<ul>
<li>回调函数中this的指向</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="146-arrayreducecallbackaccumulator-currentvalue-index-array-initialvalue">1.4.6 Array#reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</h4>
<ul>
<li>遍历数组对象并归约数组，并返回最后的结果
<ul>
<li>里面的修改不会影响原arr</li>
</ul>
</li>
<li>参数
<ul>
<li>callback
<ul>
<li>遍历的回调函数，必须返回布尔值</li>
<li>第一个参数为preValue</li>
</ul>
</li>
<li>initialValue
<ul>
<li>初始值，默认为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...argv</span>) </span>{
    <span class="hljs-keyword">return</span> argv.reduce(<span class="hljs-function">(<span class="hljs-params">preValue, currentValue</span>) =&gt;</span> preValue + currentValue, <span class="hljs-number">0</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mul</span>(<span class="hljs-params">...argv</span>) </span>{
    <span class="hljs-keyword">return</span> argv.reduce(<span class="hljs-function">(<span class="hljs-params">preValue, currentValue</span>) =&gt;</span> preValue * currentValue, <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
  <span class="hljs-built_in">console</span>.log(sum(...arr));
  <span class="hljs-built_in">console</span>.log(mul(...arr));
  <span class="hljs-comment">//   15 120</span>
</div></code></pre>
<h3 id="15-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84">1.5. 遍历数组</h3>
<ul>
<li>方法1：
<ul>
<li>Array#forEach((value, index) =&gt; {...})</li>
</ul>
</li>
<li>方法2：
<ul>
<li>for...in...
<ul>
<li>遍历index</li>
</ul>
</li>
</ul>
</li>
<li>方法3：
<ul>
<li>for...of...
<ul>
<li>遍历value</li>
</ul>
</li>
</ul>
</li>
<li>方法4
<ul>
<li>for(let i = 0;i &lt; arr.length;i ++)</li>
</ul>
</li>
</ul>
<h3 id="16-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">1.6. 注意事项</h3>
<h4 id="161-%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E8%B5%8B%E5%80%BC">1.6.1. 数组名的赋值</h4>
<ul>
<li>不要直接给数组名赋值，否则数组指向的堆的内存会被垃圾处理代码清空</li>
</ul>
<h2 id="2-%E5%AF%B9%E8%B1%A1">2. 对象</h2>
<h3 id="21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B">2.1. 面向对象的编程</h3>
<h4 id="211-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8Bpopprocess-oriented-programming">2.1.1 面向过程的编程(POP)(Process-oriented programming)</h4>
<ul>
<li>分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候在一个一个依次调用即可</li>
</ul>
<h4 id="212-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boopoject-oriented-programming">2.1.2. 面向对象编程(OOP)(Oject-oriented programming)</h4>
<ul>
<li>把事务分解成一个个对象，然后对象之间分工与合作</li>
<li>特点
<ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
</li>
</ul>
<h3 id="22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E7%BB%B4%E7%89%B9%E7%82%B9">2.2. 面向对象编程的思维特点</h3>
<ul>
<li>抽取（抽象）对象共用的属性和行为组成（封装）成一个类（模板）</li>
<li>对类进行实例化，获取类的对象</li>
</ul>
<h3 id="23-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">2.3. 对象的基本组成</h3>
<h4 id="231-%E5%B1%9E%E6%80%A7">2.3.1. 属性</h4>
<p>事物的特征，在对象中用属性来表示</p>
<h4 id="232-%E6%96%B9%E6%B3%95">2.3.2. 方法</h4>
<p>对象的行为，在对象中用方法来表示</p>
<h3 id="24-%E5%AF%B9%E8%B1%A1">2.4 对象</h3>
<h4 id="241-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F">2.4.1 对象的定义形式</h4>
<ul>
<li>声明/文字形式
<ul>
<li>添加多个键值对</li>
</ul>
</li>
<li>构造形式
<ul>
<li>逐个添加属性</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-comment">// 文字形式</span>
    <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-comment">// 构造形式</span>
    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
    myObj.key = value;
</div></code></pre>
<h4 id="242-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB">2.4.2 对象的分类</h4>
<ul>
<li>根据对象的定义形式，可以分为两类</li>
</ul>
<h5 id="2421-%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1">2.4.2.1 普通对象</h5>
<ul>
<li>方法1：直接通过字面量进行定义</li>
<li>方法2：通过new Object()来进行定义
<ul>
<li>实际上也可以成为Object的实例对象，但这里暂且不这么认为</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">a</span>: <span class="hljs-number">4</span>;
  }

  <span class="hljs-keyword">let</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
</div></code></pre>
<h5 id="2422-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">2.4.2.2 类的实例对象</h5>
<ul>
<li>方法1：通过new和构造函数创建对象</li>
<li>方法2：对象委派
<ul>
<li>Object.create(o)</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> Foo();

  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(Foo.prototype)
  <span class="hljs-comment">// 实例对象的__proto__指向类的原型对象</span>
</div></code></pre>
<h4 id="243-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9">2.4.3 对象的属性访问和修改</h4>
<ul>
<li>在对象中，<font color="red">属性名永远都是字符串</font>。如果你使用 string（字面量）以外的其他值作为属性名，那<font color="red">它首先会被转换为一个字符串</font>,即使是数字也不例外</li>
</ul>
<h5 id="2431-%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">2.4.3.1 属性访问</h5>
<ul>
<li>只能使用对应的属性值才能进行访问</li>
<li>若不是访问而是赋值
<ul>
<li>可以用于添加新的属性和值（必须有两者）</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> myObject - {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>
    }
    <span class="hljs-built_in">console</span>.log(myObject.a)
</div></code></pre>
<h5 id="2432-%E9%94%AE%E5%80%BC%E8%AE%BF%E9%97%AE">2.4.3.2 键值访问</h5>
<ul>
<li>要求键值的规范
<ul>
<li>而 [&quot;..&quot;] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名</li>
<li>可以使用字符串的变量来进行访问</li>
<li>ES6增加了可计算属性名，即可以使用表达式来作为[]内的字符串</li>
</ul>
</li>
<li>若不是访问而是赋值
<ul>
<li>可以用于添加新的属性和值（必须有两者）</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> myObject - {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>
    }
    <span class="hljs-built_in">console</span>.log(myObject[<span class="hljs-string">"a"</span>])
</div></code></pre>
<h4 id="244-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%93%8D%E4%BD%9C">2.4.4 理解对象属性访问的默认操作</h4>
<h5 id="2441--get">2.4.4.1 <a href="%E7%94%A8%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%BF%E9%97%AE">[ Get ]</a></h5>
<ul>
<li>myObject.a 在 myObject 上实际上是实现了 [[ Get ]] 操作
<ul>
<li>对象默认的内置 [[Get]] 操作首先在当前对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。</li>
<li>如果没有找到遍历可能存在的 [[Prototype]] 链，也就是原型链</li>
<li>还是没有找到，放回undefined</li>
</ul>
</li>
<li>这种方法和访问变量时是不一样的。如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常：</li>
</ul>
<h5 id="2442--put-%E7%94%A8%E4%BA%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%A2%9E%E5%92%8C%E4%BF%AE%E6%94%B9">2.4.4.2 [[ Put ]]（用于属性的新增和修改）</h5>
<ul>
<li>[[Put]] 算法大致会检查下面这些内容。
<ul>
<li>
<ol>
<li>属性是否是访问描述符？如果是并且存在 setter 就调用 setter。</li>
</ol>
</li>
<li>
<ol start="2">
<li>属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果都不是，将该值设置为属性的值。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="2443-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%85%B7%E6%9C%89%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7">2.4.4.3 如何判断是否具有某个属性</h5>
<ul>
<li>方法一：使用属性访问，若<font color="red">实例对象和原型链中</font>没有该属性，则返回undefined</li>
</ul>
<pre class="hljs"><code><div>    obj.a <span class="hljs-comment">//返回undefined</span>
</div></code></pre>
<ul>
<li>使用</li>
<li>方法二：使用in，若<font color="red">实例对象和原型链中</font>没有该属性，则返回false</li>
</ul>
<pre class="hljs"><code><div>    prop <span class="hljs-keyword">in</span> obj
</div></code></pre>
<ul>
<li>方法3 若<font color="red">实例对象中</font>没有该属性，则返回false
<ul>
<li>注意不检查原型链</li>
<li>Object.prototype.hasOwnProperty.call(obj, prop) 或者</li>
<li>obj.hasOwnProperty(prop)</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    obj.hasOwnProperty(prop)
</div></code></pre>
<h4 id="245-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6">2.4.5 对象的复制</h4>
<ul>
<li>对象的存储
<ul>
<li>obj[key]即对应的value
<ul>
<li>基本类型：存储该值</li>
<li>复杂类型：存储该复杂类型数据所在堆中的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2451-%E6%B5%85%E5%A4%8D%E5%88%B6">2.4.5.1 浅复制</h5>
<ul>
<li>基本数据类型有进行复制
<ul>
<li>Object.assign(target, ...sources)</li>
</ul>
</li>
<li>复杂数据类型只是指向对应的堆的地址，没有对其进行赋值</li>
</ul>
<h5 id="2452-%E6%B7%B1%E5%A4%8D%E5%88%B6">2.4.5.2 深复制</h5>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> newObj = {}
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span>(<span class="hljs-params">oldObj, newObj</span>) </span>{
        <span class="hljs-built_in">Object</span>.keys(oldObj).forEach(<span class="hljs-function">(<span class="hljs-params">key, index</span>) =&gt;</span> {
            <span class="hljs-keyword">let</span> value = oldObj[key];
            <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
                newObject[key] = [];
                deepCopy(value, newObject[key]);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) {
                newObject[key] = {};
                deepCopy(value, newObject[key]);
            }
            <span class="hljs-keyword">else</span> {
                newObject[key] = value;
            }
        })
    }
</div></code></pre>
<h4 id="246-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6">2.4.6 对象的属性描述符</h4>
<ul>
<li>对象属性对应的值实际上是一个对象
<ul>
<li>value
<ul>
<li>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。</li>
<li>默认为undefined</li>
</ul>
</li>
<li>后面三个对应了该属性的一些特性（即属性描述符）
<ul>
<li>writable
<ul>
<li>当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。</li>
<li>默认值为false</li>
</ul>
</li>
<li>configurable
<ul>
<li>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</li>
<li>默认值为false</li>
</ul>
</li>
<li>enumerable
<ul>
<li>当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。</li>
<li>默认值为false</li>
</ul>
</li>
<li>get
<ul>
<li>属性的 getter 函数。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</li>
<li>默认为undefined</li>
</ul>
</li>
<li>set
<ul>
<li>属性的 setter 函数。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。</li>
<li>默认为undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>若在不允许的情况下对相应的属性描述符或者属性值进行修改，则会返回TypeError</li>
</ul>
<pre class="hljs"><code><div>    {
        <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>;
        configurable: <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>;
        enumerable: <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>;
        <span class="hljs-comment">// 在访问该属性时调用</span>
        <span class="hljs-keyword">get</span>() {
            <span class="hljs-comment">// ...</span>
            <span class="hljs-keyword">return</span> 
        }
        <span class="hljs-comment">// 在修改该属性时调用</span>
        <span class="hljs-keyword">set</span>() {
            <span class="hljs-comment">// ...</span>
        }
    }
</div></code></pre>
<h5 id="2461-%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%89%B9%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C">2.4.6.1 对对象属性特性的操作</h5>
<h6 id="24611-objectdefineproperty">2.4.6.1.1 Object.defineProperty()</h6>
<ul>
<li>给obj添加/修改一个普通的属性并显式指定/修改了一些特性</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.defineProperty(obj, prop, descriptor)
</div></code></pre>
<ul>
<li>参数
<ul>
<li>obj：要定义属性的对象</li>
<li>prop: 要定义或修改的属性的名称或 Symbol</li>
<li>descriptor: 要定义或修改的属性描述符。(使用对象)</li>
</ul>
</li>
<li>返回值
<ul>
<li>被传递给函数的对象。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> obj = {};
    <span class="hljs-built_in">Object</span>.definePropety(obj, <span class="hljs-string">"a"</span>, {
        <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
    })
</div></code></pre>
<h5 id="2462-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7">2.4.6.2 对象属性的不变性</h5>
<h6 id="24621-%E5%AF%B9%E8%B1%A1%E5%B8%B8%E9%87%8F">2.4.6.2.1 对象常量</h6>
<ul>
<li>将对象属性特性
<ul>
<li>writable: false</li>
<li>configurable: false</li>
</ul>
</li>
</ul>
<h5 id="2463-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7">2.4.6.3 对象的不变性</h5>
<h6 id="24631-objectpreventextensionsobj">2.4.6.3.1 Object.preventExtensions(obj)</h6>
<ul>
<li>禁止对一个对象增添新的属性并且保存已有的属性
<ul>
<li>Object.preventExtensions()仅阻止添加自身的属性。但其对象类型的原型依然可以添加新的属性。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.preventExtensions(obj);
    <span class="hljs-built_in">Object</span>.isExtensions(obj)
    <span class="hljs-comment">// 判断一个对象是否是不可扩展的对象</span>
</div></code></pre>
<ul>
<li>参数
<ul>
<li>obj：将要变得不可扩展的对象。</li>
</ul>
</li>
<li>返回值
<ul>
<li>已经不可扩展的对象。</li>
</ul>
</li>
</ul>
<h6 id="24632-objectsealobj">2.4.6.3.2 Object.seal(obj)</h6>
<ul>
<li><strong>proto</strong> (  ) 属性的值也会不能修改。</li>
<li>Object.preventExtensions(obj) + configurable: false</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.seal(obj);
</div></code></pre>
<ul>
<li>参数
<ul>
<li>obj：将要变得不可扩展的对象。</li>
</ul>
</li>
<li>返回值
<ul>
<li>已经不可扩展的对象。</li>
</ul>
</li>
</ul>
<h6 id="24633-objectfreezeobj">2.4.6.3.3 Object.freeze(obj)</h6>
<ul>
<li><strong>proto</strong> (  ) 属性的值也会不能修改。</li>
<li>Object.seal(obj) + wriable: false</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.freeze(obj);
</div></code></pre>
<ul>
<li>参数
<ul>
<li>obj：将要变得不可扩展的对象。</li>
</ul>
</li>
<li>返回值
<ul>
<li>已经不可扩展的对象。</li>
</ul>
</li>
</ul>
<h5 id="2464-%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98">2.4.6.4 不可枚举属性的问题</h5>
<ul>
<li>常见的不可枚举的属性
<ul>
<li>symbol属性</li>
<li>constructor属性</li>
<li><strong>proto</strong>, prototype</li>
<li>可枚举属性值为false</li>
</ul>
</li>
</ul>
<h6 id="24641-objpropertyisenumerableprop">2.4.6.4.1 obj.propertyIsEnumerable(prop)</h6>
<ul>
<li>会检查给定的属性名是否直接存在于对象中</li>
</ul>
<pre class="hljs"><code><div>    obj.propertyIsEnumerable(prop);
</div></code></pre>
<h6 id="24642-objectgetpropertysymbolsobj">2.4.6.4.2 Object.getPropertySymbols(obj)</h6>
<ul>
<li>以数组形式返回对象中的symbol属性</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">Object</span>.getPropertySymbols(obj)
</div></code></pre>
<h4 id="247-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86">2.4.7 对象的遍历</h4>
<ul>
<li>利用枚举函数</li>
</ul>
<h5 id="2471-objectkeysobj">2.4.7.1 Object.keys(obj)</h5>
<ul>
<li>会返回一个数组，包含所有可枚举属性</li>
<li>属性只是当前对象的属性，不包含原型链</li>
</ul>
<h5 id="2472-objectgetownpropertynamesobj">2.4.7.2 Object.getOwnPropertyNames(obj)</h5>
<ul>
<li>会查找对象直接包含的属性(包括不可枚举类型)</li>
<li>属性只是当前对象的属性，不包含原型链</li>
</ul>
<h5 id="2473-forinkey">2.4.7.3 for...in...(key)</h5>
<ul>
<li>可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）</li>
</ul>
<h5 id="2474-forofvalue">2.4.7.4 for...of...(value)</h5>
<ul>
<li>遍历属性的值</li>
<li>本质
<ul>
<li>循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值</li>
</ul>
</li>
</ul>
<h4 id="248-%E6%80%BB%E7%BB%93">2.4.8 总结</h4>
<ul>
<li>JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = new Array(..)）。字面形式更常用</li>
<li>对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</li>
<li>对象就是键 / 值对的集合。可以通过 .propName 或者 [&quot;propName&quot;] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[sGet]] 操作（在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链</li>
<li>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。</li>
<li>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</li>
<li>你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</li>
</ul>
<h3 id="25-%E7%B1%BB">2.5 类</h3>
<h4 id="251-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0">2.5.1. 类的构造</h4>
<h5 id="2511-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2.5.1.1 通过函数构造类（构造函数）</h5>
<ul>
<li>对象属性
<ul>
<li>定义
<ul>
<li>this.attrName = ...</li>
<li>子类会创建一个新的内存空间来存储这些属性</li>
</ul>
</li>
</ul>
</li>
<li>类的原型对象方法
<ul>
<li>定义：
className.prototype.funcName = function(argv) {...}</li>
<li>置于原型链之中, 在定义时，可以通过this调用其他函数</li>
<li>通过实例对象才能调用的方法（实际上是通过原型链进行调用）
<ul>
<li>classObj.funcName(argv)</li>
</ul>
</li>
</ul>
</li>
<li>类方法
<ul>
<li>定义：
<ul>
<li>className.funcName = function(argv) {...}</li>
</ul>
</li>
<li>通过类名能够调用的方法, 不能被实例对象所调用
<ul>
<li>className.funcName(argv)</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">name</span>) </span>{
      <span class="hljs-keyword">this</span>.name = name;  
  }
  Foo.sayKeyWord = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello world"</span>);
  }
  Foo.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
  }

  <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> Foo(<span class="hljs-string">"bulumrcai"</span>);
  obj.sayName();
  Foo.sayKeyWord();

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"sayKeyWord can be excuted by obj :"</span>, obj.sayKeyWord);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"sayName can be excuted by Foo :"</span>, Foo.sayName);
  <span class="hljs-comment">/*
  bulumrcai
  hello world
  sayKeyWord can be excuted by obj : undefined
  sayName can be excuted by Foo : undefined
  */</span>
</div></code></pre>
<h5 id="2512-%E9%80%9A%E8%BF%87class%E6%9E%84%E9%80%A0%E7%B1%BB">2.5.1.2 通过class构造类</h5>
<ul>
<li>对象属性（在构造函数constructor中定义）
<ul>
<li>定义
<ul>
<li>this.attrName = ...</li>
<li>子类会创建一个新的内存空间来存储这些属性</li>
</ul>
</li>
</ul>
</li>
<li>类的原型对象方法
<ul>
<li>直接在class内部定义：
<ul>
<li>funcName(argv) {...}</li>
</ul>
</li>
<li>置于原型链之中, 在定义时，可以通过this调用其他函数</li>
<li>通过实例对象才能调用的方法（实际上是通过原型链进行调用）
<ul>
<li>classObj.funcName(argv)</li>
</ul>
</li>
</ul>
</li>
<li>类方法
<ul>
<li>定义(通过static进行定义）：
<ul>
<li>static funcName(argv) {...}</li>
</ul>
</li>
<li>通过类名能够调用的方法, 不能被实例对象所调用
<ul>
<li>className.funcName(argv)</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">this</span>.name = name; 
    }
    <span class="hljs-keyword">static</span> sayKeyWord() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello world"</span>);
    }
    sayName() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
  }

  <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> Foo(<span class="hljs-string">"bulumrcai"</span>);
  obj.sayName();
  Foo.sayKeyWord();

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"sayKeyWord can be excuted by obj :"</span>, obj.sayKeyWord);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"sayName can be excuted by Foo :"</span>, Foo.sayName);
  <span class="hljs-comment">/*
  bulumrcai
  hello world
  sayKeyWord can be excuted by obj : undefined
  sayName can be excuted by Foo : undefined
  */</span>
</div></code></pre>
<h4 id="252-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E9%80%9A%E8%BF%87new%E6%9E%84%E9%80%A0%E7%9A%84%E5%AF%B9%E8%B1%A1">2.5.2 类的实例对象（通过new构造的对象）</h4>
<ul>
<li>通过new + 构造函数（class）创建原型对象
<ul>
<li>new使构造函数中会做的四件事情：
<ul>
<li>创建一个新的空的对象</li>
<li>这个新对象会执行原型链接
<ul>
<li>obj.<strong>proto</strong> = Object.create(funcName.prototype)</li>
</ul>
</li>
<li>这个新的对象会绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么表达式中的函数调用会自动返回这个新的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2521-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">2.5.2.1. 类的实例对象的成员类型(实例成员，静态成员)</h5>
<ul>
<li>构造函数中的属性和方法被称为成员</li>
<li>实例成员
<ul>
<li>构造函数内部通过this添加的成员（this.sayName = functino(){})或这通过原型对象添加的成员
<ul>
<li>通过this创建的成员在新的实例对象创建时会再存储一次</li>
<li>通过原型对象添加的成员只需存储一次，可以通过原型链进行访问</li>
</ul>
</li>
<li><font color='red'>实例成员只能通过实例化的对象来访问，不可以通过函数来访问实例成员</font></li>
</ul>
</li>
<li>静态成员
<ul>
<li>在构造函数本身上添加成员</li>
<li><font color='red'>静态成员只能通过函数来访问，不能通过对象实例来访问</font></li>
</ul>
</li>
</ul>
<h4 id="253-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E8%B4%A8">2.5.3 类的实例对象的实质</h4>
<ul>
<li>创建新的存储空间来存储构造函数中的this指向的成员</li>
<li>将实例对象的__proto__对象指向构造函数的prototype构成原型链</li>
</ul>
<h4 id="254-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%99">2.5.4. 类的实例对象的方法查询规则</h4>
<ul>
<li>在实例对象查找对应的方法</li>
<li>若没有找到，通过原型链查找对应的方法</li>
</ul>
<h4 id="255-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5 类的继承</h4>
<ul>
<li>类的继承的实质
<ul>
<li>子类构造函数继承了父类构造函数的this指向的静态成员</li>
<li>子类构造函数的prototype对象的__proto__指向父类构造函数的prototype</li>
</ul>
</li>
<li>创建的子类实例对象的特点
<ul>
<li>子类实例对象会为构造函数中的this分配新的存储空间以及赋相应的值</li>
<li>子类实例对象的__proto__会指向Son.prototype,其中Son.prototype的__proto__属性则会指向Father.prototype（父类的原型对象）以及Son.prototype的新增的原型对象的方法</li>
</ul>
</li>
</ul>
<h5 id="2551-%E5%8E%9F%E5%9E%8B%E9%93%BE">2.5.5.1. 原型链</h5>
<ul>
<li>所有普通的原型链最终都会指向内置的 Object.prototype</li>
<li>每个对象都有__proto__属性</li>
<li>当对象是通过构造函数的形式来进行构建的时候，实质上构建的过程包括将对象的__proto__指向构造函数的原型对象（funcName.prototype)</li>
<li>构造函数和构造函数之间的继承关系
<ul>
<li>作为子类的构造函数的原型对象的__proto__属性会指向作为父类的构造函数的原型对象，一般通过以下的方法进行构建</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  Son.prototype = <span class="hljs-built_in">Object</span>.create(Father.prototype);
  Son.constructor = Son;
</div></code></pre>
<h6 id="25511-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%9D%A5%E5%AF%BB%E6%89%BE%E7%9B%B8%E5%BA%94%E7%9A%84%E6%96%B9%E6%B3%95">2.5.5.1.1 实例对象是如何通过原型链来寻找相应的方法?</h6>
<ul>
<li>从实例对象开始的__proto__指向的原型对象</li>
<li>第一类：实例对象
<ul>
<li>实例对象的__proto__属性指向构造函数的原型对象</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>实例对象
  {
    <span class="hljs-comment">// ...其他成员</span>
    <span class="hljs-attr">__proto__</span>: { <span class="hljs-comment">//构造函数的原型对象</span>
      <span class="hljs-attr">__proto__</span>: 父类原型对象，
      <span class="hljs-attr">constructor</span>: 构造函数的名字,
      ...
      <span class="hljs-comment">// ......该构造函数原型的方法</span>
    }
  }
  
</div></code></pre>
<ul>
<li>第二类：构造函数的原型对象
<ul>
<li>构造函数的原型对象的__proto__属性指向父类的原型对象</li>
</ul>
</li>
<li>第三类：父类的原型对象
<ul>
<li>父类原型对象的__proto__属性指向其父类的原型对象</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 父类原型对象</span>
  {
    <span class="hljs-attr">__proto__</span>: 父类原型对象，
    <span class="hljs-attr">constructor</span>: 构造函数的名字,
      ...
    <span class="hljs-comment">// ......该构造函数原型的方法</span>
  }
</div></code></pre>
<ul>
<li>后面的都是第三类的循环</li>
<li>2.7.1.1.2 实例对象的原型链查询</li>
<li>第一步：实例对象会先在属性__proto__对象中寻找相应的方法</li>
<li>第二步：若没有找到相应的方法，则会寻找该__proto__对象中属性__proto__所指向的另一个对象中寻找方法</li>
<li>第三步：循环第二步直至找到为止</li>
<li>这一个过程即形成了原型链查询</li>
<li><img src=".img/ex7.jpg" alt="原型链"></li>
</ul>
<h5 id="2552-%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%BC%95%E8%B5%B7%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%B1%8F%E8%94%BD">2.5.5.2 原型链引起的属性设置和屏蔽</h5>
<h6 id="25521-%E5%B1%9E%E6%80%A7%E5%B1%8F%E8%94%BD">2.5.5.2.1 属性屏蔽</h6>
<ul>
<li>若当前对象myObject有属性prop，其原型链上也有属性prop
<ul>
<li>在访问属性prop的时候，访问的是myObject上的属性值而不是原型链上的属性</li>
</ul>
</li>
<li>此时称该prop为屏蔽属性</li>
</ul>
<h6 id="25522-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%9A%84%E8%BF%87%E7%A8%8Bmyobjectprop--value">2.5.5.2.2 属性设置的过程（myObject.prop = value)</h6>
<ul>
<li>遍历myObject的属性，
<ul>
<li>若该属性在myObject在遍历的属性中，则修改myObject的属性值（要考虑是否writable）</li>
<li>若不在myObject的属性，则往其原型链寻找
<ul>
<li>遍历原型链的属性
<ul>
<li>若该属性不在原型链上，则向myObject添加该属性以及对应的属性值</li>
<li>若该属性在原型链上
<ul>
<li>若该属性在原型链上不是只读的类型，则在myObject上添加该属性以及对应的属性值，<font color="red">此时该属性起到了屏蔽的作用</font></li>
<li>若该属性在原型链上且是只读类型，由于继承的原因，myObject的属性也是只读类型，返回TypeError</li>
<li>如果在原型链上存在该属性并且它是一个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义该属性这个 setter。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="./img/ex2.jpeg">属性设置的过程</a></li>
</ul>
<h6 id="25523-%E5%B1%9E%E6%80%A7%E5%B1%8F%E8%94%BD%E5%92%8C%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9--%E9%9A%90%E5%BC%8F%E5%B1%8F%E8%94%BD">2.5.5.2.3 属性屏蔽和属性设置的易错点--隐式屏蔽</h6>
<ul>
<li>在属性值进行++的过程，会有一个属性设置的过程，即给当前对象新增一个属性</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>
    }
    <span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.create(obj)

    <span class="hljs-built_in">console</span>.log(newObj.a)

    newObj.a ++;
    <span class="hljs-comment">// newObj.a = newObj.a + 1 相当于一个设置属性的过程</span>
    <span class="hljs-built_in">console</span>.log(obj.a)
    <span class="hljs-built_in">console</span>.log(newObj.a)
    <span class="hljs-comment">// 2</span>
    <span class="hljs-comment">// 2</span>
    <span class="hljs-comment">// 3</span>
</div></code></pre>
<ul>
<li>若想要使obj的2增加，必须使用obj.a++</li>
</ul>
<h5 id="2553-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5.3 通过构造函数实现类的继承</h5>
<ul>
<li>称为组合继承</li>
<li>类的继承的实质
<ul>
<li>子类构造函数继承了父类构造函数的this指向的静态成员，<font color="red">借用call来实现显示地改变函数中this指向的对象</font></li>
<li>子类构造函数的prototype对象的__proto__指向父类构造函数的prototype，<font color="red">通过Object.create(Father.prototype)来构建__proto__属性指向Father.prototype的对象</font></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
  }
  Father.welcome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"welcome"</span>);
  }
  Father.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name, label</span>) </span>{
    Father.call(<span class="hljs-keyword">this</span>, name);
    <span class="hljs-keyword">this</span>.label = label;
  }
  Son.prototype = <span class="hljs-built_in">Object</span>.create(Father.prototype);
  <span class="hljs-comment">// Object.create(Father.prototype)</span>
  <span class="hljs-comment">// 创建了一个对象，该对象的__proto__属性指向Father.prototype</span>
  Son.prototype.constructor = Son;

  Son.prototype.sayLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.label);
  }
  <span class="hljs-built_in">console</span>.dir(Son);

  <span class="hljs-keyword">const</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">"bulumrcai"</span>, <span class="hljs-string">"hello world"</span>);
  <span class="hljs-built_in">console</span>.dir(son);
  son.sayLabel();
  son.sayName();
  <span class="hljs-comment">// Son.welcome(); // TypeError</span>
  <span class="hljs-comment">// 若要正常使用静态成员，则需要加上</span>
  Son.prototype.constructor.__proto__ = Father;
  Son.welcome();
</div></code></pre>
<ul>
<li><img src="./img/function_inherit.jpg" alt="result">;</li>
</ul>
<h6 id="25521-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8sonprototypeproto--fatherprototype%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5.2.1 为什么不能使用Son.prototype.<strong>proto</strong> = Father.prototype来实现原型链的继承</h6>
<h6 id="25522-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8sonprototype--new-father">2.5.5.2.2 为什么不能使用Son.prototype = new Father()</h6>
<ul>
<li>new Father()会创建一个Father的实例对象</li>
</ul>
<pre class="hljs"><code><div>  {
    <span class="hljs-comment">// ...Father中this指向的属性</span>
    <span class="hljs-attr">__proto__</span>: Father.prototype
  }
</div></code></pre>
<ul>
<li>会发现该对象的__proto__确是指向Father.prototype,但是会引入Father的其他一些属性，可能会造成意想不到的错误</li>
</ul>
<h6 id="25523-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8sonprototype--father">2.5.5.2.3 为什么不能使用Son.prototype = Father</h6>
<ul>
<li>Father是一个函数而不是一个对象</li>
<li>Father中的__proto__属性指向的是Object.prototype而不是Father.prototype</li>
</ul>
<h6 id="25524-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%BB%A7%E6%89%BF">2.5.5.2.4 如何实现父类静态成员的继承？</h6>
<ul>
<li>为什么通过原型链不能继承
<ul>
<li>静态成员并不位于原型对象之中，因此不能使用原型链继承</li>
</ul>
</li>
<li>经过研究，我发现该静态成员实际上位于构造函数原型对象的constructor的__proto__属性之中，因此用一下的方法来时实现静态成员的继承</li>
</ul>
<pre class="hljs"><code><div>   Son.prototype.constructor.__proto__ = Father;
</div></code></pre>
<h5 id="2554-%E9%80%9A%E8%BF%87class%E4%B8%AD%E7%9A%84extends%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">2.5.5.4 通过class中的extends实现继承</h5>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>{
    <span class="hljs-keyword">constructor</span>(name) {
      <span class="hljs-keyword">this</span>.name = name;
    }
    sayName() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
    <span class="hljs-keyword">static</span> welcome() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"welcome"</span>);
    }
  }

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>{
    <span class="hljs-keyword">constructor</span>(name, label) {
      <span class="hljs-keyword">super</span>(name);
      <span class="hljs-keyword">this</span>.label = label;
    }
    sayLabel() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.label);
    }
  }
  <span class="hljs-built_in">console</span>.dir(Son);

  <span class="hljs-keyword">const</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">"bulumrcai"</span>, <span class="hljs-string">"hello world"</span>);
  <span class="hljs-built_in">console</span>.dir(son);
  son.sayLabel();
  son.sayName();
  Son.welcome(); <span class="hljs-comment">// 能够正常的使用</span>
</div></code></pre>
<ul>
<li><img src="./img/class_inherit.jpg" alt="result">;</li>
</ul>
<h6 id="25531-class%E4%B8%AD%E7%9A%84super%E5%AF%B9%E8%B1%A1">2.5.5.3.1 class中的super对象</h6>
<ul>
<li>在子类的构造函数中，super指的是父类的constuctor函数
<ul>
<li>调用的时候必须在前面，通过super()进行调用</li>
</ul>
</li>
<li>在子类的其他函数中，super指的是原型链上的对象
<ul>
<li>通过super.funcName()进行调用</li>
</ul>
</li>
</ul>
<h6 id="25532-class%E4%B8%AD%E7%9A%84static%E5%87%BD%E6%95%B0">2.5.5.3.2 class中的static函数</h6>
<ul>
<li>即静态成员，只能通过函数名进行调用，且不位于原型链之中。</li>
<li>实际上是位于constructor的__proto__属性之中</li>
</ul>
<h4 id="256-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">2.5.6 类的基本认识</h4>
<ul>
<li>JavaScript 中实际上没有类，由于类是一种设计模式，所以你可以用一些方法（本章之后会介绍）近似实现类的功能。</li>
<li>构造函数
<ul>
<li>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数</li>
<li>类构造函数属于类，而且通常和类同名，构造函数大多需要用 new 来调</li>
</ul>
</li>
<li>类的继承
<ul>
<li>父类</li>
<li>子类</li>
<li>父母的基因特性会被复制给孩子</li>
<li>子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。</li>
</ul>
</li>
<li>多态
<ul>
<li>子类可以重写父类中名字相同的方法，且可以进行调用</li>
<li>在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义
<ul>
<li>会使用实例化对象的方法</li>
</ul>
</li>
</ul>
</li>
<li>混入</li>
</ul>
<h4 id="257-%E7%B1%BB%E7%9A%84%E6%98%93%E6%B7%B7%E7%82%B9">2.5.7 类的易混点</h4>
<ul>
<li>js中并没有所谓的类，只有对象，而是一种类似类的形式</li>
<li>所有的函数都会有一个名为prototype的公有并且不可枚举的属性，该属性的值是一个对象，该对象的__proto__属性的值会指向另一个对象</li>
<li>所有的对象都具有一个名为__proto__的不可枚举的属性，且该属性指向另一个对象</li>
</ul>
<h5 id="2571-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB">2.5.7.1 类的实例对象和类的关系</h5>
<h6 id="25711-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%9C%AC%E8%B4%A8">2.5.7.1.1 类的实例的本质</h6>
<ul>
<li>若根据类的构造函数创建一个实例时,该实例对象的__proto__会指向该构造函数的prototype</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Foo();

    <span class="hljs-built_in">console</span>.log(obj.__proto__ === Foo.prototype)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === Foo.prototype)
    <span class="hljs-comment">// true true</span>
</div></code></pre>
<h6 id="25712-%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF">2.5.7.1.2 原型继承</h6>
<ul>
<li>该实例对象的__proto__会指向该构造函数的prototype，这即是原型继承</li>
<li>对于js中的类的实例，只是通过原型相互关联，而形成了该类的实例，但本质上是一个对象</li>
</ul>
<h6 id="25713-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7constructor%E6%9C%AC%E8%B4%A8">2.5.7.1.3 类的实例对象的不可枚举属性constructor本质</h6>
<ul>
<li>在类/构造函数进行声明的时候，就会有默认的.prototype.constructor的不可枚举属性，该属性指向本身</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-built_in">console</span>.log(Foo === Foo.prototype.constructor)
    <span class="hljs-comment">// true</span>
</div></code></pre>
<ul>
<li>在通过new创建实例时，由于原型继承，所以实例中的不可枚举属性constructor实际上就是通过Get方法寻找的原型链上的constructor</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
    Foo.prototype.constructor = {};
    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Foo();
    <span class="hljs-built_in">console</span>.log(obj.constructor === Foo)
    <span class="hljs-comment">// false</span>
</div></code></pre>
<h5 id="2572-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8">2.5.7.2 构造函数的本质</h5>
<ul>
<li>js中的构造函数实质上是带有new的函数调用，即原本的函数不是构造函数，当且仅当使用new时，函数调用才会变成构造函数的调用</li>
<li>调用的时候函数才能称为构造函数</li>
</ul>
<h5 id="2573-instanceof%E5%88%A4%E6%96%AD%E7%9A%84%E5%AE%9E%E8%B4%A8%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0">2.5.7.3 instanceof判断的实质（对象与函数）</h5>
<ul>
<li>实际上判断的是对象的原型链中是不是有指向函数的原型对象的对象，而不能判断对象与对象之间的关联</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> Father)
    <span class="hljs-comment">// obj的原型链中是否有指向Fahter.prototype</span>
</div></code></pre>
<h5 id="2574-%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B9%8B%E4%B8%AD">2.5.7.4 判断某个对象是否出现在另一个对象的原型链之中</h5>
<pre class="hljs"><code><div>    c.isPrototypeOf(b)
    <span class="hljs-comment">// c对象是否出现在b对象的原型链中</span>

    <span class="hljs-keyword">var</span> obj = {};
    <span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.create(obj);
    <span class="hljs-comment">/*
        {
            __proto__: obj
        }
    */</span>
    <span class="hljs-built_in">console</span>.log(obj.isPrototypeOf(newObj))
    <span class="hljs-comment">// true</span>
</div></code></pre>
<h5 id="2575-%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE">2.5.7.5 获取某个对象的原型链</h5>
<h6 id="25751-objectgetprototypeofobj">2.5.7.5.1 Object.getPrototypeOf(obj)</h6>
<ul>
<li>标准的方法</li>
</ul>
<h6 id="25752-objproto">2.5.7.5.2 obj.<strong>proto</strong></h6>
<ul>
<li>在某些浏览器上并不适用</li>
<li>对象__proto__的实质：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-built_in">Object</span>.defineProperty( <span class="hljs-built_in">Object</span>.prototype, <span class="hljs-string">"__proto__"</span>, {
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getPrototypeOf( <span class="hljs-keyword">this</span> );
    },
    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
    <span class="hljs-comment">// ES6 中的 setPrototypeOf(..)</span>
    <span class="hljs-built_in">Object</span>.setPrototypeOf( <span class="hljs-keyword">this</span>, o );
    <span class="hljs-keyword">return</span> o;
    }
    } );
</div></code></pre>
<h5 id="2576-%E6%80%BB%E7%BB%93">2.5.7.6 总结</h5>
<ul>
<li>如果要访问对象中并不存在的一个属性，[[Get]] 操作（参见第 3 章）就会查找对象内部原型链关联的对象</li>
<li>关联两个对象最常用的方法是使用 new 关键词进行函数调用，即使类和实例的关系</li>
</ul>
<h4 id="258-%E6%B3%A8%E6%84%8F">2.5.8 注意</h4>
<ul>
<li>在生成实例时，new不能够省略，后面的类名一定要加上小括号</li>
<li>ES6类没有变量提升，必须先定义类，才能通过类实例化对象</li>
<li>对象的属性和value的访问方法：
<ul>
<li>已知具体的属性key
<ul>
<li>obj.key</li>
</ul>
</li>
<li>属性attr是一个变量：一般是用keys进行遍历的时候
<ul>
<li>obj[key]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2581-%E4%BC%9A%E6%A3%80%E6%9F%A5%E6%89%80%E6%9C%89%E5%9C%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A%E7%9A%84%E5%B1%9E%E6%80%A7">2.5.8.1 会检查所有在原型链上的属性</h5>
<ul>
<li>...in..
<ul>
<li>for let key in obj</li>
<li>prop in obj</li>
</ul>
</li>
</ul>
<h2 id="3-%E5%87%BD%E6%95%B0">3 函数</h2>
<h3 id="31-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">3.1. 函数的定义</h3>
<h4 id="311-%E5%87%BD%E6%95%B0%E7%9A%84%E5%91%BD%E5%90%8D%E5%86%99%E6%B3%95%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0">3.1.1. 函数的命名写法（命名函数）</h4>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>) </span>{
    函数封装的代码
    ...
  }

  函数名()
</div></code></pre>
<h4 id="312-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">3.1.2. 函数的表达式写法（匿名函数）</h4>
<ul>
<li>命名函数表达式</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>) </span>{
    函数封装代码
    ...
  }

  foo();
</div></code></pre>
<ul>
<li>匿名函数表达式（没有函数名）</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    函数封装代码
    ...
  }

  foo();
</div></code></pre>
<h3 id="32-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">3.2. 函数的参数传递</h3>
<h4 id="321-%E5%BD%A2%E5%8F%82">3.2.1. 形参</h4>
<ul>
<li>定义函数时，小括号中的参数，是用来接收参数用的，在函数的内部作为变量</li>
</ul>
<h4 id="322-%E5%AE%9E%E5%8F%82">3.2.2. 实参</h4>
<ul>
<li>调用函数时，小括号中的参数，是用来把数据传递到函数的内部用的</li>
</ul>
<h4 id="323-%E5%BD%A2%E5%8F%82%E5%8F%98%E9%87%8F%E4%B8%AA%E6%95%B0%E5%92%8C%E5%AE%9E%E5%8F%82%E5%8F%98%E9%87%8F%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">3.2.3. 形参变量个数和实参变量个数的关系</h4>
<ul>
<li>形参变量个数&gt;实参变量个数 没赋值的默认为undefined</li>
<li>形参变量个数&lt;实参变量个数 用arguments对象进行处理</li>
</ul>
<h5 id="3231-arguments%E5%AF%B9%E8%B1%A1%E7%8E%B0%E5%9C%A8%E5%BE%88%E5%B0%91%E7%94%A8%E4%BA%86">3.2.3.1. arguments对象(现在很少用了)</h5>
<h6 id="32311-%E7%89%B9%E7%82%B91">3.2.3.1.1. 特点1</h6>
<ul>
<li>是一个object类型，而不是一个数组(Array类型)，但是和数组的用法类似</li>
<li>伪数组
<ul>
<li>具有数组的length属性</li>
<li>按照索引的方式进行存储的</li>
<li>它没有真正数组的一些方法 pop() push()等等</li>
</ul>
</li>
</ul>
<h6 id="32312-%E7%89%B9%E7%82%B92">3.2.3.1.2. 特点2</h6>
<ul>
<li>是所有非箭头函数中都可用的局部变量</li>
</ul>
<h6 id="32313-%E7%89%B9%E7%82%B93">3.2.3.1.3. 特点3</h6>
<ul>
<li>存放着所有的调用者传递的参数，从0位置开始，依次存放
<ul>
<li>如果调用者传入的参数多余函数接收的参数，可以通过arguments去获取所有的传入的参数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-built_in">console</span>.log(val);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>)
  }

  print(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)
</div></code></pre>
<ul>
<li><img src="./img/res2.jpg" alt="结果验证"></li>
<li>实现多个数的相加</li>
</ul>
<pre class="hljs"><code><div>  fuction sum() {
    <span class="hljs-built_in">arguments</span>.reduce(<span class="hljs-function">(<span class="hljs-params">prevalue, value</span>) =&gt;</span> prevalue + value, <span class="hljs-number">0</span>)
  }
</div></code></pre>
<h4 id="324-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">3.2.4. 函数参数的值传递和引用传递</h4>
<ul>
<li>参数传递的本质
<ul>
<li>实参将栈中的值赋给了函数中对应的形参，形参在函数的栈中开辟新的空间来存储该值</li>
</ul>
</li>
</ul>
<h5 id="3241-%E5%80%BC%E4%BC%A0%E9%80%92">3.2.4.1. 值传递</h5>
<ul>
<li>适用：
<ul>
<li>基本数据类型</li>
</ul>
</li>
<li>特点：
<ul>
<li>形参改变值不能使得实参的值改变</li>
</ul>
</li>
<li>原因：基本类型的数值存储在栈中，开辟新空间来存储该值实际上就是就是对应的数值，所以值改变并不会导致对应的实参的值改变</li>
<li><img src="./img/ex2.jpg" alt="理解"></li>
</ul>
<h5 id="3242-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">3.2.4.2. 引用传递</h5>
<ul>
<li>适用
<ul>
<li>复合数据类型(object)</li>
</ul>
</li>
<li>特点：
<ul>
<li>形参改变值的内容会使得实参的值改变</li>
</ul>
</li>
<li>原因：复合数据类型存储在栈中的值是对应存储内容的堆的地址（即指针），参数传递实际上传的是地址，所以一旦形参改变了内容，则会导致实参指向的内容改变</li>
<li><img src="./img/ex1.jpg" alt="理解"></li>
</ul>
<h3 id="33-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8">3.3. 函数的调用</h3>
<h4 id="331-%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%A0%88">3.3.1. 函数的调用栈</h4>
<ul>
<li>函数的调用过程是一个压栈的过程</li>
<li><img src="./img/function_use.jpg" alt="function_use"></li>
<li><a href="https://www.bilibili.com/video/BV1nJ411J7a2?p=87">视频地址</a></li>
<li>在开发中尽量避免使用递归
<ul>
<li>递归如果没有写好约束条件，意味着会无限调用</li>
<li>递归调用非常占用栈空间的内存</li>
</ul>
</li>
</ul>
<h4 id="332-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8">3.3.2. 普通函数的调用</h4>
<ul>
<li>funcName();</li>
<li>funcName.call();</li>
</ul>
<h4 id="333-%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E7%9A%84%E8%B0%83%E7%94%A8%E5%BD%A2%E5%BC%8F">3.3.3 函数的特殊的调用形式</h4>
<ul>
<li><a href='#template-call' >标签模板字面量的调用</a></li>
</ul>
<h4 id="334-%E9%80%9A%E8%BF%87%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%B0%83iife">3.3.4. 通过立即调用函数进行调（IIFE）</h4>
<ul>
<li>函数定义的同时立即实行函数</li>
<li>特点：执行完函数会立即销毁，对应的函数名在调用之后也会变得没有意义</li>
<li>作用
<ul>
<li>创建一个独立的执行上下文环境，<font color="red">可以避免外界的访问修改内部的变量</font></li>
</ul>
</li>
<li>例子见笔记</li>
</ul>
<h5 id="3341-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A7%84%E8%8C%83">3.3.4.1. 函数声明的立即调用函数规范</h5>
<ul>
<li>可以使用立即调用函数，只是需要在定义加上一个小括号后在加上参数列表</li>
<li>立即调用函数的写法1：</li>
</ul>
<pre class="hljs"><code><div>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1...</span>) </span>{
    函数封装代码
    ...
  } )(arg1...)
</div></code></pre>
<ul>
<li>立即调用函数的写法2</li>
</ul>
<pre class="hljs"><code><div>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1...</span>) </span>{
    函数封装代码
    ...
  }(arg1...) )
</div></code></pre>
<h6 id="32542-%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%90%8E%E9%9D%A2%E5%A2%9E%E5%8A%A0%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%9A%84%E7%AB%8B%E5%8D%B3%E5%AE%9E%E8%A1%8C">3.2.5.4.2. 函数的表达式写法可以在后面增加参数列表从而实现函数的立即实行</h6>
<ul>
<li>返回的是函数执行的最终结果</li>
</ul>
<pre class="hljs"><code><div>   <span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">arg1...</span>) </span>{
    函数封装代码
    ...
  }(arg1...)

   <span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg1...</span>) </span>{
    函数封装代码
    ...
  }(arg1...)
</div></code></pre>
<ul>
<li><font color="red">foo的结果不是一个函数，而是函数的返回值</font></li>
</ul>
<h3 id="34-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">3.4. 函数的返回值</h3>
<ul>
<li>如果函数中没有使用return语句，那么函数有默认返回值undefined</li>
</ul>
<h1 id="%E5%9B%9B-js%E7%9A%84%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">四 JS的知识补充</h1>
<h2 id="1-%E4%BD%9C%E7%94%A8%E5%9F%9F">1 作用域</h2>
<h3 id="11-%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F">1.1 理解作用域</h3>
<h4 id="111-%E8%AE%A4%E8%AF%86%E4%B8%89%E4%B8%AA%E5%AF%B9%E8%AF%9D%E7%9A%84%E9%83%A8%E5%88%86">1.1.1 认识三个对话的部分</h4>
<ul>
<li>引擎
<ul>
<li>从头到尾负责整个js程序的编译及执行过程</li>
</ul>
</li>
<li>编译器
<ul>
<li>负责语法分析即代码生成等等</li>
</ul>
</li>
<li>作用域
<ul>
<li>负责收集并维护所有声明的表示符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</li>
</ul>
</li>
</ul>
<h4 id="112-%E5%AF%B9%E8%AF%9D%E7%9A%84%E8%BF%87%E7%A8%8B">1.1.2 对话的过程</h4>
<ul>
<li>var a = 2的三个部分的对话
<ul>
<li>第一步：编译器查看当前作用域中是否有声明a
<ul>
<li>若有声明，则忽略声明变量过程</li>
<li>若没有声明，在当前作用域下声明该变量</li>
</ul>
</li>
<li>第二步：编译器生成相应的赋值代码，JS引擎执行赋值代码给a赋值</li>
</ul>
</li>
</ul>
<h4 id="113-js%E5%BC%95%E6%93%8E%E6%9F%A5%E8%AF%A2%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95">1.1.3 js引擎查询变量的方法</h4>
<ul>
<li>LHS查询
<ul>
<li>查询变量是否已经声明后并给它赋值</li>
</ul>
</li>
<li><img src="./img/LHS.jpeg" alt="LHS"></li>
<li>RHS查询
<ul>
<li>变量已经赋值，查询变量的值</li>
</ul>
</li>
<li><img src="./img/RHS.jpeg" alt="RHS"></li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>{
        <span class="hljs-built_in">console</span>.log(a)
    }

    foo(<span class="hljs-number">2</span>);
    <span class="hljs-comment">// a = 2 为LHS查询，参数的传递</span>
    <span class="hljs-comment">// console.log(a) 为RHS查询</span>
</div></code></pre>
<ul>
<li>练习</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>{
      <span class="hljs-keyword">var</span> b = a;
      <span class="hljs-keyword">return</span> a + b;
    }
    <span class="hljs-keyword">var</span> c = foo(<span class="hljs-number">2</span>)
    <span class="hljs-comment">/**
    * 三次LHS查询
    *   1 调用函数时，a需要进行LHS引用
    *   2 b需要进行LHS引用
    *   3 c需要进行LHS引用
    * 四次RHS查询
    *   1 调用foo函数：js引擎询问在该作用域当中有没有foo函数
    *   2 赋值b时，js询问a的值
    *   3 在return时，询问a,b的值
    *   4 赋值c时，js询问函数的返回值
    */</span>
</div></code></pre>
<ul>
<li>认清语法LHS和RHS的重要性</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>{
        <span class="hljs-built_in">console</span>.log(a + b);
        b = a;
    }

    foo(<span class="hljs-number">2</span>)
    <span class="hljs-comment">/*
    *b是一个未声明的变量，所以进行RHS查询时无法找到，是一个undefined类型，抛出ReferenceError
    *若RHS查询对变量进行不符合规范的引用，如变量不是函数全被调用成函数, 抛出TypeError
    * 对b进行LHS查询，由于b没有声明，若在非严格模式下，js引擎会自动帮你创建一个全局变量
    *若严格模式下, js引擎会抛出ReferenceError
    */</span>
</div></code></pre>
<h4 id="114-%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE">1.1.4 理解变量的访问</h4>
<ul>
<li>要分清楚是LHS还是RHS从而确认变量的访问作用域</li>
</ul>
<h3 id="12-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97">1.2 作用域嵌套</h3>
<ul>
<li>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。
<ul>
<li>以{}符号作为一个块</li>
</ul>
</li>
<li>遍历作用域链的过程
<ul>
<li>在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止</li>
</ul>
</li>
<li>注意：</li>
<li>var的特殊特性；非块级作用域
<ul>
<li>对于var而言，只有函数的嵌套才存在错用于的嵌套</li>
</ul>
</li>
<li>内部的作用域能够访问外部作用域变量，而外部作用域不能访问内部作用域的变量</li>
</ul>
<h3 id="13-%E6%80%BB%E7%BB%93">1.3 总结</h3>
<ul>
<li>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）</li>
<li>如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。</li>
<li>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：
<ul>
<li>首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。</li>
<li>接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。</li>
</ul>
</li>
<li>遍历作用域链
<ul>
<li>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。</li>
</ul>
</li>
<li>异常抛出
<ul>
<li>不成功的 RHS 引用会导致抛出 ReferenceError 异常。（没有进行声明）</li>
<li>不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。</li>
</ul>
</li>
</ul>
<h3 id="14-%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F">1.4 词法作用域</h3>
<ul>
<li>词法作用域是一种静态作用域，即某个变量在声明的时候就已经确定了其作用域范围，该变量的作用域即是该变量的词法作用域</li>
</ul>
<h4 id="141-%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95">1.4.1 欺骗词法</h4>
<h5 id="1411-eval">1.4.1.1 eval()</h5>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">str, a</span>) </span>{
        <span class="hljs-built_in">eval</span>(str); <span class="hljs-comment">// 欺骗</span>
        <span class="hljs-built_in">console</span>.log(a, b);
    }
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;
    foo(<span class="hljs-string">"var b = 3;"</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 1, 3</span>
    <span class="hljs-comment">// 当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b</span>
</div></code></pre>
<ul>
<li>默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改。</li>
<li>严格模式下,eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">str</span>) </span>{
        <span class="hljs-string">"use strict"</span>
        <span class="hljs-built_in">eval</span>(str)
        <span class="hljs-built_in">console</span>.log(a);
    }
    foo(<span class="hljs-string">"var a = 2"</span>);
    <span class="hljs-comment">// ReferenceError: a is not defined</span>
</div></code></pre>
<h4 id="142-%E6%80%BB%E7%BB%93">1.4.2 总结</h4>
<ul>
<li>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</li>
</ul>
<h3 id="15-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F">1.5 函数作用域</h3>
<ul>
<li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数范围内使用及复用</li>
<li>气泡：在某个作用域下的所有变量</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>{
        <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">// ...</span>
        }
        <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>;
    }
    <span class="hljs-comment">// 全局作用域气泡：foo</span>
    <span class="hljs-comment">// foo函数作用域气泡：a, b, bar, c</span>
    <span class="hljs-comment">// 所以全局无法访问a, b, bar, c</span>
</div></code></pre>
<h4 id="151-%E4%BD%9C%E7%94%A81%E9%9A%90%E8%97%8F%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0">1.5.1 作用1：隐藏内部实现</h4>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">a</span>) </span>{
        b = a + doSomethingElse(a * <span class="hljs-number">2</span>);
        <span class="hljs-built_in">console</span>.log(b * <span class="hljs-number">3</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingElse</span>(<span class="hljs-params">a</span>) </span>{ 
        <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">var</span> b;
    doSomething(<span class="hljs-number">2</span>);
    <span class="hljs-comment">// 在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体实现的“私有”内容</span>
    <span class="hljs-comment">// 由于b在外部没有用到，所以最好是作为函数作用域内的变量，而不是放在外面</span>
</div></code></pre>
<h4 id="152-%E4%BD%9C%E7%94%A82%E8%A7%84%E9%81%BF%E5%86%B2%E7%AA%81">1.5.2 作用2：规避冲突</h4>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">a</span>) </span>{
            i = <span class="hljs-number">3</span>;
            <span class="hljs-built_in">console</span>.log(a + i);
        }

        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i ++) {
            bar(i * <span class="hljs-number">2</span>);
        }
    }
    <span class="hljs-comment">// 会陷入无限的循环</span>
    <span class="hljs-comment">// bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i</span>
    <span class="hljs-comment">// 解决方法：在bar函数内部内部声明一个i变量或者其他变量</span>
    <span class="hljs-comment">// 内部作用域的声明的变量由于嵌套的访问的原因会被优先采用，且不会影响外部同名变量的值</span>
</div></code></pre>
<h4 id="153-%E4%BD%9C%E7%94%A83%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">1.5.3 作用3：全局命名空间</h4>
<ul>
<li>声明一个对象，在对象内部声明变量和函数，该对象就被称为命名空间</li>
</ul>
<h4 id="154-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.5.4 函数声明和函数表达式</h4>
<ul>
<li>区分函数表达式和函数声明
<ul>
<li>函数的声明必须用具名函数</li>
<li>有LRS的引用就可以称之为函数表达式，此时可以用匿名函数或者具名函数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-comment">// 赋值表达式</span>
    <span class="hljs-keyword">const</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-comment">// 函数的参数</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">def</span>) </span>{
        def();
    }
    foo(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    })
    <span class="hljs-comment">// 立即执行函数表达式</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)</span>{
        <span class="hljs-comment">// ...</span>
    })(args)
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
        <span class="hljs-comment">// ...</span>
    }(args))
</div></code></pre>
<h4 id="154-%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.5.4 立即执行函数表达式</h4>
<ul>
<li>IIFE(Immediately Invoked Function Expression)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 法1</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>)</span>{
        <span class="hljs-comment">// ...</span>
    })(args)
<span class="hljs-comment">// 法2</span>
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
        <span class="hljs-comment">// ...</span>
    }(args))
</div></code></pre>
<h3 id="16-%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6 块作用域</h3>
<h4 id="161-var%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8D%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6.1 var声明的变量不具有块级作用域</h4>
<ul>
<li>在用var声明变量的时候，var并不具有块级作用域</li>
</ul>
<pre class="hljs"><code><div>    {
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
    }
    <span class="hljs-built_in">console</span>.log(a);
    <span class="hljs-comment">// 10</span>
    <span class="hljs-comment">// 函数及作用域</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;
    }
    <span class="hljs-built_in">console</span>.log(a);
    <span class="hljs-comment">// undefined referenceError</span>
</div></code></pre>
<h4 id="162-trycatch%E7%9A%84err%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6.2 try...catch的err具有块级作用域</h4>
<pre class="hljs"><code><div>    <span class="hljs-keyword">try</span>{
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-keyword">catch</span>(err) {
        <span class="hljs-built_in">console</span>.log(err)
    }
    <span class="hljs-built_in">console</span>.log(err);
    <span class="hljs-comment">// undefined referenceError</span>
</div></code></pre>
<h4 id="163-letconst%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.6.3 let/const声明的变量具有块级作用域</h4>
<ul>
<li>let/const具有块级作用域</li>
<li>使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”</li>
</ul>
<h5 id="1631-%E5%9C%A8if%E8%AF%AD%E5%8F%A5%E4%B8%AD">1.6.3.1 在if语句中</h5>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span>(foo) {
        <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>;
        <span class="hljs-built_in">console</span>.log(bar);
    }
    <span class="hljs-built_in">console</span>.log(bar);
    <span class="hljs-comment">// 2</span>
    <span class="hljs-comment">// undefined referenceError</span>
</div></code></pre>
<h5 id="1632-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%AD">1.6.3.2 垃圾回收中</h5>
<p>(看书补充)</p>
<h5 id="1633-let%E5%BE%AA%E7%8E%AF">1.6.3.3 let循环</h5>
<ul>
<li>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i ++) {
        <span class="hljs-built_in">console</span>.log(i);
    }
    <span class="hljs-built_in">console</span>.log(i) 
    <span class="hljs-comment">// undefined referenceError</span>
</div></code></pre>
<ul>
<li>for循环的转化理解</li>
</ul>
<pre class="hljs"><code><div>    {
        <span class="hljs-keyword">let</span> j;
        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">10</span>;j ++) {
            <span class="hljs-keyword">let</span> i = j;
            <span class="hljs-built_in">console</span>.log(i);
        }
    }
</div></code></pre>
<h4 id="164-%E6%80%BB%E7%BB%93">1.6.4 总结</h4>
<ul>
<li>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</li>
<li>块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。</li>
<li>ES3 开始，try/catch 结构在 catch 分句中具有块作用域。</li>
<li>在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。</li>
</ul>
<h3 id="17-%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87">1.7 声明的提升</h3>
<ul>
<li>任何声明在某个作用域内的变量，都将附属于这个作用域。</li>
<li><font color="red">包括变量和函数在内的所有声明都会在任何代码被执行前</font>首先被处理。</li>
</ul>
<h4 id="171-%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86">1.7.1 编译器对代码的处理</h4>
<ul>
<li>声明和代码执行的先后关系</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 实际上执行的过程</span>
    <span class="hljs-keyword">var</span> a; <span class="hljs-comment">// 声明阶段</span>
    a = <span class="hljs-number">2</span>; <span class="hljs-comment">// 执行阶段</span>
</div></code></pre>
<ul>
<li>练习</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 练习一</span>
    a = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> a;
    <span class="hljs-built_in">console</span>.log(a);

    <span class="hljs-comment">// 等价于:</span>
    <span class="hljs-keyword">var</span> a;
    a = <span class="hljs-number">2</span>;
    <span class="hljs-built_in">console</span>.log(a);
    <span class="hljs-comment">// 2</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// 练习二</span>
    <span class="hljs-built_in">console</span>.log(a);
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 等价于</span>
    <span class="hljs-keyword">var</span> a;
    <span class="hljs-built_in">console</span>.log(a);
    a = <span class="hljs-number">2</span>;
    <span class="hljs-comment">// undefine;</span>
    <span class="hljs-comment">// 2</span>
</div></code></pre>
<h4 id="172-%E6%8F%90%E5%8D%87">1.7.2 提升</h4>
<ul>
<li><font color="red">当执行的变量在代码执行的时候还没有被声明时,要想到变量提升</font></li>
<li>无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。</li>
<li>将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升</li>
</ul>
<pre class="hljs"><code><div>    foo();
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log( a );
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    }
    <span class="hljs-comment">// 等价于</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> a;
        <span class="hljs-built_in">console</span>.log( a );
        a = <span class="hljs-number">2</span>;
    }
    foo();
    <span class="hljs-comment">// undefined;</span>
</div></code></pre>
<ul>
<li>注意
<ul>
<li>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。</li>
<li>只有函数声明会被提升,<font color="red">函数表达式无法进行提升, 包含具名表达式也无法进行提升</font></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    foo();
    <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-comment">// TypeError </span>
    <span class="hljs-comment">// 等价于</span>
    <span class="hljs-keyword">var</span> foo;
    foo();
    foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
</div></code></pre>
<pre class="hljs"><code><div>    foo();
    bar(); 
    <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-comment">// TypeError </span>
    <span class="hljs-comment">// ReferenceError 没有声明bar()</span>
</div></code></pre>
<h4 id="173-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">1.7.3 函数声明和变量声明的优先级</h4>
<ul>
<li>变量和函数声明同时提升时, 函数声明优先级比较高。</li>
</ul>
<pre class="hljs"><code><div>    foo();
    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);
    }
<span class="hljs-comment">// 1</span>
</div></code></pre>
<h4 id="174-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8D%E5%85%B7%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">1.7.4 函数声明不具有块级作用域</h4>
<ul>
<li>一个普通块内部的函数声明通常会被提升到所在作用域的顶部
<ul>
<li>函数的声明并不具有块级作用域的作用</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    foo();
    <span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span>(a) {
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a"</span> );
        }
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"b"</span> );
        }
    }
    <span class="hljs-comment">// b</span>
</div></code></pre>
<h4 id="175-%E6%80%BB%E7%BB%93">1.7.5 总结</h4>
<ul>
<li>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</li>
<li>无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。</li>
<li>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升</li>
<li>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</li>
</ul>
<h3 id="18-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%97%AD%E5%8C%85">1.8 作用域的闭包</h3>
<ul>
<li>某个函数在其他作用域(不是本身的词法作用域)被调用时,仍然可以访问其词法作用域内的变量(相应变量的值被缓存了下来),即仍然可以引用其所在的词法作用域,该词法作用域就称为闭包.</li>
</ul>
<h4 id="181-%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85">1.8.1 理解闭包</h4>
<ul>
<li>非闭包</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log( a );
        }
        bar();
    }

    foo();
</div></code></pre>
<ul>
<li>由于bar在foo作用域中被执行,不存在闭包的效果</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log( a );
        }
        <span class="hljs-keyword">return</span> bar;
    }

    <span class="hljs-keyword">var</span> baz = foo();
    baz(); <span class="hljs-comment">// 根据调用的位置，该baz应该访问的是baz内部定义的变量，但是它仍可以访问foo内部的变量</span>
</div></code></pre>
<ul>
<li>由于bar在foo中定义,即bar是foo的作用域气泡,即bar正常情况下只能在foo的作用域范围内被执行</li>
<li>但是,在该例子中bar在自己定义的词法作用域以外的地方执行。
<ul>
<li>原因: 由于闭包的原因,bar仍然可以访问它定义时的作用域</li>
</ul>
</li>
</ul>
<h4 id="182-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E8%B4%A8">1.8.2 闭包的实质</h4>
<ul>
<li>foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁, 但闭包阻止了该内部作用域被销毁, 即该作用域仍然被bar所使用, 即bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</li>
<li>某个函数被执行的时候，本来只能访问该函数本身的作用域内部的声明的变量或者全部变量，但是实质上，其可以访问声明位置的作用域内部的变量（声明位置的作用域会被缓存起来）</li>
<li>闭包起效果的条件是，该函数声明位置的函数又被执行</li>
</ul>
<h4 id="183-%E9%97%AD%E5%8C%85%E7%9A%84%E9%80%9A%E5%B8%B8%E5%BD%A2%E5%BC%8F">1.8.3 闭包的通常形式</h4>
<ul>
<li>通过return返回对应的函数</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log( a );
        }
        <span class="hljs-keyword">return</span> bar;
    }

    <span class="hljs-keyword">var</span> baz = foo();
    baz();    
    <span class="hljs-comment">// 2</span>
</div></code></pre>
<ul>
<li>通过参数传递的形式</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log( a );
    }
    baz(bar);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params">fn</span>) </span>{
    fn();
}
foo();
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// bar在baz函数作用域执行,仍然调用其词法作用域的内容</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params">args</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...有用到args</span>
    }, <span class="hljs-number">1000</span>)
}
<span class="hljs-comment">// 在其他作用域调用了timer函数,但仍然可以访问到args</span>
</div></code></pre>
<ul>
<li>通过外部变量传递</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> baz;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log( a );
    }
    baz = bar;
}
foo();
baz();
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// bar在全局作用域执行,仍然调用其词法作用域的内容</span>
</div></code></pre>
<h4 id="184-%E9%97%AD%E5%8C%85%E7%9A%84%E8%BF%90%E7%94%A8">1.8.4 闭包的运用</h4>
<h5 id="1841-%E5%BE%AA%E7%8E%AF%E5%92%8C%E9%97%AD%E5%8C%85">1.8.4.1 循环和闭包</h5>
<pre class="hljs"><code><div>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">5</span>;i ++) {
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(i);
        }, <span class="hljs-number">1000</span>)
    }
<span class="hljs-comment">//  6 6 6 6 6 6</span>
</div></code></pre>
<ul>
<li>原因:在执行完同步代码之后,此时的i为6,而异步执行的setTimeout的回调函数满足条件后被调用时,显然是输出6</li>
<li>解决方法
<ul>
<li>法1: 运用立即函数作用域的闭包给每个循环创建一个新的作用域</li>
<li>法2: 利用块级作用域</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">5</span>;i ++) {
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> j = i;
            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(j);
            }, <span class="hljs-number">1000</span>)
        })()
    }
</div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">5</span>;i ++) {
        (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) </span>{
            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(j);
            }, <span class="hljs-number">1000</span>)
        })(i)
    }
</div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">5</span>;i ++) {
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(i);
        }, <span class="hljs-number">1000</span>)
    }
</div></code></pre>
<h5 id="1842-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97">1.8.4.2 实现模块</h5>
<ul>
<li>必须有<font color="red">外部的封闭函数</font>，该函数必须至少被调用一次（每次调用都会建一个新的模块实例）。</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li>
<li>模块的基本形式</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> something = <span class="hljs-string">"cool"</span>;
        <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(something);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAnother</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(another);
        }
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">doSomething</span>: doSomething,
            <span class="hljs-attr">doAnother</span>: doAnother
        }
    }

    <span class="hljs-keyword">var</span> CoolModule = foo();
    CoolModule.doSomething();
    CoolModule.doAnther();
</div></code></pre>
<ul>
<li>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包</li>
<li>IIFE模块</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> args = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
        <span class="hljs-keyword">var</span> something = <span class="hljs-string">"cool"</span>;
        <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(something);
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAnother</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(another);
        }
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">doSomething</span>: doSomething,
            <span class="hljs-attr">doAnother</span>: doAnother
        }
    })(args)
    module1.doSomething();
    module1.doAnother();
</div></code></pre>
<h4 id="185-%E6%80%BB%E7%BB%93">1.8.5 总结</h4>
<ul>
<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</li>
<li>模块有两个主要特征：
<ul>
<li>（1）为创建内部作用域而调用了一个包装函数；</li>
<li>（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>
</ul>
</li>
</ul>
<h2 id="2-this%E7%9A%84%E7%90%86%E8%A7%A3">2 this的理解</h2>
<ul>
<li>this是在<font color="red">运行时进行绑定,而不是编写时绑定</font>,它的上下文取决于函数调用时的各种条件.</li>
<li>this的绑定和函数声明的位置没有任何关系,只取决于函数的调用方式</li>
</ul>
<h3 id="21-this%E7%9A%84%E5%AE%9E%E8%B4%A8">2.1 this的实质</h3>
<ul>
<li>当一个函数被调用时,会创建一个活动记录(有时候被称为执行上下文).这个记录会包含在调用栈中,函数调用栈中有函数的调用方法,传入的参数等信息.this就是记录其中一个属性,会在函数执行的过程中用到.</li>
</ul>
<h3 id="22-%E7%A1%AE%E5%AE%9Athis%E6%89%80%E6%8C%87%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">2.2 确定this所指的对象的方法</h3>
<h4 id="221-%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%AF%BB%E6%89%BE%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%BD%93%E5%89%8D%E7%9A%84%E8%B0%83%E7%94%A8%E6%A0%88">2.2.1 第一步：寻找调用位置和当前的调用栈</h4>
<ul>
<li>调用位置:函数在代码中被调用的位置</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">/*
         * 第二步
         * 当前的调用栈是:baz
         * 当前的调用位置是全局作用域
        */</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"baz"</span>);
        bar(); <span class="hljs-comment">// 第三步: bar的调用位置</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">/*
         * 第四步
         * 当前的调用栈是:baz -&gt; bar
         * 当前的调用位置是baz中
        */</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"bar"</span>);
        foo(); <span class="hljs-comment">// 第五步: foo的调用位置</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">/*
         * 第六步
         * 当前的调用栈是:baz -&gt; bar -&gt; foo
         * 当前的调用位置是bar中
        */</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"foo"</span>);
    }

    baz();  <span class="hljs-comment">// 第一步:baz的调用位置</span>
</div></code></pre>
<ul>
<li>调用栈的倒数第二个即为调用位置</li>
</ul>
<h4 id="222-%E7%AC%AC%E4%BA%8C%E6%AD%A5%E6%A0%B9%E6%8D%AEthis%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99%E6%9D%A5%E7%A1%AE%E5%AE%9A%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AF%B9%E8%B1%A1">2.2.2 第二步：根据this的绑定规则来确定绑定的对象</h4>
<ul>
<li><font color="red">this的绑定规则</font>
<ul>
<li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。
<ul>
<li>var bar = new foo()</li>
</ul>
</li>
<li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。
<ul>
<li>var bar = foo.call(obj2)</li>
</ul>
</li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。
<ul>
<li>var bar = obj1.foo()</li>
</ul>
</li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。
<ul>
<li>var bar = foo()</li>
</ul>
</li>
</ul>
</li>
<li><img src="./img/this_bind.jpeg" alt="this_bind"></li>
</ul>
<h5 id="2221-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A">2.2.2.1 默认绑定</h5>
<ul>
<li>默认this指向全局对象(window)</li>
<li>常见于独立函数的调用
<ul>
<li>直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    foo();

    <span class="hljs-comment">// 2</span>
</div></code></pre>
<ul>
<li>注意
<ul>
<li><font color="red">在严格模式下,this是没有指向全局对象的,而是绑定到undefined</font></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-string">"use strict"</span>;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    foo();
    <span class="hljs-comment">// TypeError: this is undefined</span>
</div></code></pre>
<h5 id="2222-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A">2.2.2.2 隐式绑定</h5>
<ul>
<li>是<font color="red">调用位置</font>是否有上下文对象，或者说是否被某个对象拥有或者包含，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象</li>
<li>指向调用的对象</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> obj2 = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,
        <span class="hljs-attr">foo</span>: foo
    }
    <span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,
        <span class="hljs-attr">obj2</span>:obj2
    }
    obj1.obj2.foo() 
    <span class="hljs-comment">// 42</span>
</div></code></pre>
<h6 id="22221-%E9%9A%90%E5%BC%8F%E4%B8%A2%E5%A4%B1">2.2.2.2.1 隐式丢失</h6>
<ul>
<li><font color="red">使用函数别名进行调用</font>
<ul>
<li>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 相当于这种形式</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">foo</span>: foo
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">"hello world"</span>
    <span class="hljs-keyword">var</span> bar = obj1.foo;
    bar();
    <span class="hljs-comment">//true "hello world"</span>
</div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
        }
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">"hello world"</span>
    <span class="hljs-keyword">var</span> bar = obj1.foo;
    bar();
    <span class="hljs-comment">//true "hello world"</span>
</div></code></pre>
<ul>
<li>传入回调函数的参数
<ul>
<li>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，与上面的结果一样</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">foo</span>: foo
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFunc</span>(<span class="hljs-params">fn</span>) </span>{
        fn();
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">"hello world"</span>
    doFunc(obj1.foo);
    <span class="hljs-comment">//true "hello world"</span>
    <span class="hljs-comment">// setTimeout的回调函数也有类似的作用</span>
</div></code></pre>
<h5 id="2223-%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A">2.2.2.3 显示绑定</h5>
<ul>
<li>方法1：使用call, apply进行显示调用</li>
<li>方法2：<font color="red">使用bind进行硬绑定</font>
<ul>
<li>使得obj1中的this指向foo的this,
<ul>
<li>若foo中有this的属性,方法,则都变成了obj1的方法</li>
<li>foo的this是obj1的this</li>
</ul>
</li>
<li>解决使用函数别名进行调用</li>
</ul>
</li>
<li>方法3：API调用的上下文
<ul>
<li>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">foo</span>: foo
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-string">"hello world"</span>
    <span class="hljs-keyword">var</span> bar = foo.bind(obj1);
    bar();
    <span class="hljs-comment">// false 2</span>
</div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> obj = {
        <span class="hljs-attr">id</span>: <span class="hljs-string">"awesome"</span>
    };
    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
        <span class="hljs-built_in">console</span>.log( el, <span class="hljs-keyword">this</span>.id );
    }, obj );
    <span class="hljs-comment">/*
    1 awesome
    2 awesome
    3 awesome
    */</span>
</div></code></pre>
<h5 id="2224-new%E7%BB%91%E5%AE%9A">2.2.2.4 new绑定</h5>
<ul>
<li>四步走
<ul>
<li>创建一个新的空的对象</li>
<li>这个新对象会执行原型链接
<ul>
<li>obj.<strong>proto</strong> = Object.create(funcName.prototype)</li>
</ul>
</li>
<li>这个新的对象会绑定到函数调用的this</li>
<li>如果函数没有返回其他对象，那么表达式中的函数调用会自动返回这个新的对象</li>
</ul>
</li>
</ul>
<h3 id="23-this%E7%9A%84%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96">2.3 this的绑定例外</h3>
<h4 id="231-%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84this">2.3.1 被忽略的this</h4>
<ul>
<li>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</li>
<li>在使用call,apply,bind有时候只需要运用传输参数,此时的this应该指向一个空的对象,使用以下的方法更加安全
<ul>
<li>创建一个“DMZ”（demilitarized-zone，非军事区）对象——它就是一个空的非委托的对象</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>{
        <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a:"</span> + a + <span class="hljs-string">", b:"</span> + b );
    }
    <span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
    <span class="hljs-comment">// 把数组展开成参数</span>
    foo.apply( ø, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3</span>
    <span class="hljs-comment">// 使用 bind(..) 进行柯里化</span>
    <span class="hljs-keyword">var</span> bar = foo.bind( ø, <span class="hljs-number">2</span> );
    ar( <span class="hljs-number">3</span> );   
</div></code></pre>
<h4 id="232-%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%8C%85%E6%8B%AC%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92">2.3.2 间接引用(包括函数参数的传递)</h4>
<ul>
<li><font color="red">创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</font></li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a);
    }
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> o = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>,
        <span class="hljs-attr">foo</span>: foo
    }
    <span class="hljs-keyword">var</span> p = {
        <span class="hljs-attr">a</span>: <span class="hljs-number">4</span>
    }
    o.foo()
    (p.foo = o.foo) ()
    <span class="hljs-comment">// 间接引用是默认绑定</span>
    <span class="hljs-comment">// 3</span>
    <span class="hljs-comment">// 2</span>
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> obj = {
    foo() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    }
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params">func</span>)</span>{
    func();
  }
  obj.foo();
  baz(obj.foo);
  <span class="hljs-comment">// obj</span>
  <span class="hljs-comment">// window</span>
</div></code></pre>
<ul>
<li>解决方法
<ul>
<li>运用硬绑定</li>
<li>运用软绑定</li>
</ul>
</li>
</ul>
<h4 id="233-%E8%BD%AF%E7%BB%91%E5%AE%9Aobjsoftbind">2.3.3 软绑定(obj.softBind(..))</h4>
<ul>
<li>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this</li>
<li>可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</li>
<li>obj.softBind(..)
<ul>
<li>会对指定的函数进行封装，首先检查调用时的 this，<font color="red">如果 this 绑定到全局对象或者 undefined，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this</font>。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"name: "</span> + <span class="hljs-keyword">this</span>.name);
    }
    <span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">"obj"</span> },
    obj2 = { <span class="hljs-attr">name</span>: <span class="hljs-string">"obj2"</span> },
    obj3 = { <span class="hljs-attr">name</span>: <span class="hljs-string">"obj3"</span> };
    <span class="hljs-keyword">var</span> fooOBJ = foo.softBind( obj );
    fooOBJ(); <span class="hljs-comment">// name: obj</span>
    obj2.foo = foo.softBind(obj);
    <span class="hljs-comment">// 此时为默认绑定</span>
    obj2.foo(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！</span>
    fooOBJ.call( obj3 ); <span class="hljs-comment">// name: obj3 &lt;---- 看！</span>
    setTimeout( obj2.foo, <span class="hljs-number">10</span> );
    <span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span>
</div></code></pre>
<h4 id="234-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">2.3.4 箭头函数</h4>
<ul>
<li>箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）</li>
</ul>
<h3 id="24-%E6%80%BB%E7%BB%93">2.4 总结</h3>
<ul>
<li>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置,然后再运用规则</li>
<li>this的规则</li>
</ul>
<ol>
<li>由 new 调用？绑定到新创建的对象。</li>
<li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。</li>
<li>由上下文对象调用？绑定到那个上下文对象。</li>
<li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li>
</ol>
<ul>
<li>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。</li>
<li>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）</li>
</ul>
<h2 id="3-%E6%9C%89%E5%85%B3%E7%B1%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">3 有关类的三种不同设计模式</h2>
<h3 id="31-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E5%BC%8F">3.1 使用构造函数的模式</h3>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    Father.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    }

    <span class="hljs-comment">// 继承</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name, label</span>) </span>{
        <span class="hljs-keyword">this</span>.label = label;
        Father.call(<span class="hljs-keyword">this</span>, name);
    }
    Son.prototype = <span class="hljs-built_in">Object</span>.create(Father.prototype);
    Son.prototype.getLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
    }
    Son.prototype.printAll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getName(), <span class="hljs-keyword">this</span>.label)
    }

    <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">"hello world"</span>, <span class="hljs-number">2</span>);
    son.printAll();
    <span class="hljs-built_in">console</span>.log(son.getName());
    <span class="hljs-built_in">console</span>.dir(son);
</div></code></pre>
<h3 id="32-%E4%BD%BF%E7%94%A8class%E6%A8%A1%E5%BC%8F">3.2 使用class模式</h3>
<pre class="hljs"><code><div>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>{
        <span class="hljs-keyword">constructor</span>(name) {
            <span class="hljs-keyword">this</span>.name = name;
        }
        getName() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
        }
    }
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>{
        <span class="hljs-keyword">constructor</span>(name, label) {
        	<span class="hljs-keyword">super</span>(name);
        	<span class="hljs-comment">// super指的是同名的父类函数</span>
            <span class="hljs-keyword">this</span>.label = label;
        }
        getLabel() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
        }
        printAll() {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getName(), <span class="hljs-keyword">this</span>.label)
        }
    }
    <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">"hello world"</span>, <span class="hljs-number">2</span>);
    son.printAll();
    <span class="hljs-built_in">console</span>.log(son.getName());
    <span class="hljs-built_in">console</span>.dir(son)
</div></code></pre>
<h3 id="33-%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE%E7%9A%84%E6%A8%A1%E5%BC%8F">3.3 使用事件委派的模式</h3>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> Father = {
        fatherInit(name) {
            <span class="hljs-keyword">this</span>.name = name;
        },
        getName() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
        }
    }
    <span class="hljs-keyword">var</span> Son = <span class="hljs-built_in">Object</span>.create(Father);
    Son.sonInit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, label</span>) </span>{
        <span class="hljs-keyword">this</span>.label = label;
        <span class="hljs-keyword">this</span>.fatherInit(name);
    }
    Son.getLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
    }
    Son.printAll = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getName(), <span class="hljs-keyword">this</span>.label);
    }
    <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">Object</span>.create(Son);
    son.sonInit(<span class="hljs-string">"hello world"</span>, <span class="hljs-number">2</span>)
    son.printAll();
    <span class="hljs-built_in">console</span>.log(son.getName());
</div></code></pre>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> Father = {
        fatherInit(name) {
            <span class="hljs-keyword">this</span>.name = name;
        },
        getName() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
        }
    }
    <span class="hljs-keyword">var</span> Son = {
        sonInit(name, label) {
            <span class="hljs-keyword">this</span>.label = label;
            <span class="hljs-keyword">this</span>.fatherInit(name);
        },
        getLabel() {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
        },
        printAll() {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.getName(), <span class="hljs-keyword">this</span>.label);
        }
    }
    <span class="hljs-built_in">Object</span>.setPrototypeOf(Son, Father)
    <span class="hljs-keyword">var</span> son = <span class="hljs-built_in">Object</span>.create(Son);
    son.sonInit(<span class="hljs-string">"hello world"</span>, <span class="hljs-number">2</span>)
    son.printAll();
    <span class="hljs-built_in">console</span>.log(son.getName());
</div></code></pre>
<pre class="hljs"><code><div>    	<span class="hljs-comment">// new创建实例的本质</span>
    	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">name</span>) </span>{
    		<span class="hljs-keyword">this</span>.name = name;
    	}
    	<span class="hljs-comment">// 第一步：创建一个原型指向构造函数原型对象的对象</span>
    	<span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(fun.prototype);
    	<span class="hljs-comment">// 第二步：将构造函数的this指向该原型对象</span>
    				<span class="hljs-comment">// 由于此时执行了一次构造函数，所以会创建一个新的作用域，该作用域中的this指向该原型对象</span>
 		fun.call(obj, <span class="hljs-string">"hello"</span>);
 		<span class="hljs-comment">// 第三步：</span>
 		<span class="hljs-built_in">console</span>.log(obj)

 		<span class="hljs-keyword">var</span> newObj = <span class="hljs-keyword">new</span> fun(<span class="hljs-string">"hello"</span>);
 		<span class="hljs-built_in">console</span>.log(newObj)
 		<span class="hljs-comment">// 继承 </span>
 		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name</span>) </span>{
 			<span class="hljs-keyword">this</span>.name = name;
 		}
 		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name, label</span>) </span>{
 			<span class="hljs-keyword">this</span>.label = label;
 			Father.call(<span class="hljs-keyword">this</span>, name);
 			<span class="hljs-comment">// 继承Father的this指向的属性</span>
 		} 
 		<span class="hljs-comment">// 子类的原型对象是指的原型是指向父类原型的对象</span>
 		Son.prototype = <span class="hljs-built_in">Object</span>.create(Father.prototype)
</div></code></pre>
<h2 id="4-%E8%AF%AD%E6%B3%95">4 语法</h2>
<h3 id="41-%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F">4.1 语句和表达式</h3>
<ul>
<li>“句子”（sentence）是完整表达某个意思的一组词，由一个或多个“短语”（phrase）组成，
它们之间由标点符号或连接词（and 和 or 等）连接起来。短语可以由更小的短语组成。有
些短语是不完整的，不能独立表达意思；有些短语则相对完整，并且能够独立表达某个意
思。
<ul>
<li>语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span> * <span class="hljs-number">6</span>;
    <span class="hljs-keyword">var</span> b = a;
    b;
    <span class="hljs-comment">/*
    *  这三行代码都是包含表达式的语句。var a = 3 * 6 和 var b = a 称为“声明语句”
（declaration statement），因为它们声明了变量（还可以为其赋值）。
    *   a = 3 * 6 和 b = a（不带 var）叫作“赋值表达式”。
    *   b既是语句有时表达式，称为表达式语句
    */</span>
</div></code></pre>
<h4 id="411-%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BB%93%E6%9E%9C%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E">4.1.1 语句的结果值的隐式返回</h4>
<ul>
<li>每一个语句都默认有返回值，一般为undefine
<ul>
<li>赋值语句(赋值表达式）的返回值为被赋值的数的值</li>
</ul>
</li>
<li>对于代码块，也默认有返回值
<ul>
<li>最后一个执行语句的返回值</li>
<li>但是由于语法规则规定不允许我们获得语句的结果值并将其赋值给另一个变量</li>
<li>ES7规定可以使用do关键词实现</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">var</span> a;
    <span class="hljs-built_in">console</span>.log(a = <span class="hljs-number">42</span>);
    <span class="hljs-comment">// 42</span>

    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">var</span> b = <span class="hljs-number">42</span>);
    <span class="hljs-comment">// undefined</span>

    <span class="hljs-keyword">var</span> c = <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>) {
            <span class="hljs-keyword">var</span> d;
            d = <span class="hljs-number">100</span>;
        }
    }
    <span class="hljs-built_in">console</span>.log(c)
</div></code></pre>
<h1 id="%E4%BA%94-js%E7%9A%84dom%E6%93%8D%E4%BD%9C">五 js的DOM操作</h1>
<h2 id="1-domdocument-object-model">1. DOM(document Object Model)</h2>
<ul>
<li>文档对象模型(DOM树)</li>
<li>document
<ul>
<li>表示整个html网页文档</li>
</ul>
</li>
<li>object
<ul>
<li>表示将文档的每一个部分转化为一个对象</li>
</ul>
</li>
<li>model
<ul>
<li>使用模型来表示对象之间的关系，以方便获取对象
<ul>
<li>使用的是树的模型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-dom%E6%A0%91">1.2. DOM树</h3>
<ul>
<li>DOM把一个文档表示为一棵家谱树，树是由节点构成的</li>
</ul>
<h3 id="13-%E8%8A%82%E7%82%B9node">1.3. 节点(node)</h3>
<ul>
<li>构成网页的基本元素</li>
</ul>
<h4 id="131-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%86%E7%B1%BB">1.3.1. 节点的分类</h4>
<h5 id="1311-%E6%96%87%E6%A1%A3%E8%8A%82%E7%82%B9document">1.3.1.1. 文档节点(document)</h5>
<ul>
<li>浏览器已经为我们提供了文档节点，可以在页面中直接使用</li>
<li>文档节点代表的是整个网页</li>
</ul>
<h5 id="1311-%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9">1.3.1.1. 元素节点</h5>
<ul>
<li>元素标签</li>
</ul>
<h5 id="1311-%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9">1.3.1.1. 属性节点</h5>
<ul>
<li>元素的属性</li>
</ul>
<h5 id="1311-%E6%96%87%E6%9C%AC%E8%8A%82%E7%82%B9">1.3.1.1. 文本节点</h5>
<ul>
<li>标签内部的文本内容</li>
</ul>
<h4 id="132-%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7">1.3.2. 节点的属性</h4>
<ul>
<li><img src="./img/ex15.jpg" alt="了解"></li>
<li>DOM定义了node的接口以及许多中节点类型来表示XML几点的多个方面</li>
<li><img src="./img/ex14.jpg" alt="理解"></li>
</ul>
<h2 id="2-dom%E6%96%B9%E6%B3%95">2 DOM方法</h2>
<h3 id="21-dom-document%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.1 DOM document属性和方法</h3>
<h4 id="211-document%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">2.1.1 document获取元素对象的方法</h4>
<h5 id="2111-documentgetelementsbyclassnamenames">2.1.1.1 document.getElementsByClassName(names)</h5>
<ul>
<li>返回类名names元素对象的类数组</li>
<li>参数
<ul>
<li>names：类名，是一个字符串</li>
</ul>
</li>
<li>ie8及以下不支持</li>
</ul>
<h5 id="2112-documentgetelementsbytagnametagnames">2.1.1.2 document.getElementsByTagName(tagNames)</h5>
<ul>
<li>返回类名tagNames元素对象的类数组</li>
<li>参数
<ul>
<li>tagNames：标签名，是一个字符串</li>
</ul>
</li>
</ul>
<h5 id="2113-documentgetelementbyidid">2.1.1.3 document.getElementById(id)</h5>
<ul>
<li>返回一个id的元素对象</li>
<li>参数
<ul>
<li>id：id名，是一个字符串</li>
</ul>
</li>
</ul>
<h5 id="2114-documentgetelementsbynamenames">2.1.1.4 document.getElementsByName(names)</h5>
<ul>
<li>返回属性name值为names元素对象的类数组</li>
<li>参数
<ul>
<li>names：name属性的值，是一个字符串</li>
</ul>
</li>
</ul>
<h5 id="2115-documentqueryselectorcssselector">2.1.1.5 document.querySelector(cssSelector)</h5>
<ul>
<li>返回与指定的选择器组匹配的元素的后代的第一个元素对象。</li>
</ul>
<h5 id="2116-documentqueryselectorallcssselector">2.1.1.6 document.querySelectorAll(cssSelector)</h5>
<ul>
<li>返回与指定的选择器组匹配的元素的后代的所有元素对象组成的类数组。</li>
</ul>
<h4 id="212-document%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7">2.1.2 document常用的属性</h4>
<h5 id="2121-documentbody">2.1.2.1 document.body</h5>
<ul>
<li>返回标签名为body的元素对象</li>
</ul>
<h5 id="2122-documentall">2.1.2.2 document.all</h5>
<ul>
<li>以类数组的形式返回整个文档的元素对象</li>
</ul>
<h5 id="2123-documentdoucumentelement">2.1.2.3 document.doucumentElement</h5>
<ul>
<li>返回标签名为html的元素对象</li>
</ul>
<h4 id="213-doucment%E4%B8%8E%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7">2.1.3 doucment与增加元素对象相关的属性</h4>
<h5 id="2131-documentcreateelementtagname">2.1.3.1 document.createElement(tagName)</h5>
<ul>
<li>创建一个标签名为tagName的元素对象</li>
</ul>
<h3 id="22-dom-element%E6%96%B9%E6%B3%95">2.2 DOM Element方法</h3>
<h4 id="221-element%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">2.2.1 element获取元素对象的方法</h4>
<h5 id="2211-elementgetelementsbyclassnamenames">2.2.1.1 element.getElementsByClassName(names)</h5>
<ul>
<li>返回类名names元素对象的类数组</li>
<li>参数
<ul>
<li>names：类名，是一个字符串</li>
</ul>
</li>
</ul>
<h5 id="2212-elementgetelementsbytagnametagnames">2.2.1.2 element.getElementsByTagName(tagNames)</h5>
<ul>
<li>返回类名tagNames元素对象的类数组</li>
<li>参数
<ul>
<li>tagNames：标签名，是一个字符串</li>
</ul>
</li>
</ul>
<h5 id="2113-elementqueryselectorcssselector">2.1.1.3 element.querySelector(cssSelector)</h5>
<ul>
<li>返回与指定的选择器组匹配的元素的后代的第一个元素对象。</li>
<li>IE8及以下浏览器不支持</li>
</ul>
<h5 id="2114-elementmatchescssselector">2.1.1.4 element.matches(cssSelector)</h5>
<ul>
<li>判断当前元素对象是否与cssSelector匹配</li>
</ul>
<h5 id="2114-elementqueryselectorallcssselector">2.1.1.4 element.querySelectorAll(cssSelector)</h5>
<ul>
<li>返回与指定的选择器组匹配的元素的后代的所有元素对象组成的类数组。</li>
<li>IE8及以下浏览器不支持</li>
</ul>
<h4 id="222-element%E4%B8%8E%E7%88%B6%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%AD%90%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%85%84%E5%BC%9F%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.2.2 element与父元素对象，子元素对象，兄弟元素对象有关的属性和方法</h4>
<h5 id="2221-elementparentnode">2.2.2.1 element.parentNode</h5>
<h6 id="22211-parentnodechildelementcount">2.2.2.1.1 parentNode.childElementCount</h6>
<ul>
<li>返回一个当前 ParentNode 所含有的后代数量。</li>
</ul>
<h6 id="22212-parentnodechildren">2.2.2.1.2 parentNode.children</h6>
<ul>
<li>返回一个包含 ParentNode 所有后代元素对象的类数组，忽略所有非元素子节点。</li>
</ul>
<h6 id="22213-parentnodefirstelementchild">2.2.2.1.3 parentNode.firstElementChild</h6>
<ul>
<li>返回第一个后代元素对象</li>
<li>IE8及以下浏览器不支持</li>
</ul>
<h6 id="22214-parentnodelastelementchild">2.2.2.1.4 parentNode.lastElementChild</h6>
<ul>
<li>返回最后一个后代元素对象</li>
<li>IE8及以下浏览器不支持</li>
</ul>
<h6 id="22215-parentnodeappendnode">2.2.2.1.5 parentNode.append(...node)</h6>
<ul>
<li>在子元素对象的最后插入一个节点</li>
<li>参数
<ul>
<li>node
<ul>
<li>元素对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="22215-parentnodeprependnode">2.2.2.1.5 parentNode.prepend(node)</h6>
<ul>
<li>在子元素对象的最钱买你插入一个节点</li>
<li>参数
<ul>
<li>node
<ul>
<li>元素对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2222-elementchildnode">2.2.2.2 element.childNode</h5>
<h6 id="22221-childnoderemove">2.2.2.2.1 childNode.remove()</h6>
<ul>
<li>删除当前元素对象</li>
</ul>
<h5 id="2223-elementpreviouselementsibling%E5%8F%AA%E8%AF%BB">2.2.2.3 element.previousElementSibling（只读）</h5>
<ul>
<li>该元素的上一个兄弟元素对象，若返回null，则说明不存在</li>
</ul>
<h5 id="2224-elementnextelementsibling%E5%8F%AA%E8%AF%BB">2.2.2.4 element.nextElementSibling（只读）</h5>
<ul>
<li>该元素的下一个兄弟元素对象，若返回null，则说明不存在</li>
</ul>
<h5 id="2225-elementclosestselectors">2.2.2.5 element.closest(selectors)</h5>
<ul>
<li>获取离当前元素对象最近的具有能够匹配selectors的祖先元素</li>
</ul>
<h4 id="223-element%E4%B8%8E%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.2.3 element与增加元素对象相关的属性和方法</h4>
<h5 id="2231-parentnodeappendnode">2.2.3.1 parentNode.append(...node)</h5>
<ul>
<li>在子元素对象的最后插入一个节点</li>
<li>参数
<ul>
<li>node
<ul>
<li>元素对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2232-parentnodeprependnode">2.2.3.2 parentNode.prepend(node)</h5>
<ul>
<li>在子元素对象的最钱买你插入一个节点</li>
<li>参数
<ul>
<li>node
<ul>
<li>元素对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2233-parentnodereplacechildrennewchild-oldchild">2.2.3.3 parentNode.replaceChildren(newChild, oldChild)</h5>
<ul>
<li>用新的子类对象来代替旧的子类对象</li>
</ul>
<h5 id="2234-childnodereplacewithnode">2.2.3.4 childNode.replaceWith(...node)</h5>
<ul>
<li>用node来代替当前的childNode</li>
</ul>
<h5 id="2235-childnoderemove">2.2.3.5 childNode.remove()</h5>
<ul>
<li>删除当前的childNode元素对象</li>
</ul>
<h5 id="2236-elementinsertadjacentelementposition-newelement">2.2.3.6 element.insertAdjacentElement(position, newElement)</h5>
<ul>
<li>将newElement插入相当于当前元素对象某个位置</li>
<li>参数
<ul>
<li>position（理解：begin可以看成当前元素对象的开始标签，end可以看成当前元素对戏那的结束标签）
<ul>
<li>&quot;beforebegin&quot;: 在当前元素对象本身的前面</li>
<li>&quot;afterbegin&quot;: 在当前元素对象中，第一个子元素对象的前面</li>
<li>&quot;beforeend&quot;: 在当前元素对象中，最后一个子元素对象的后面</li>
<li>&quot;afterend&quot;: 在当前元素对象本身的后面</li>
</ul>
</li>
<li>newElement
<ul>
<li>新插入的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2236-elementinsertadjacenthtmlposition-text">2.2.3.6 element.insertAdjacentHTML(position, text)</h5>
<ul>
<li>将text解析成一个新的元素对象，将该对象插入相当于当前元素对象某个位置</li>
<li>参数
<ul>
<li>position（理解：begin可以看成当前元素对象的开始标签，end可以看成当前元素对戏那的结束标签）
<ul>
<li>&quot;beforebegin&quot;: 在当前元素对象本身的前面</li>
<li>&quot;afterbegin&quot;: 在当前元素对象中，第一个子元素对象的前面</li>
<li>&quot;beforeend&quot;: 在当前元素对象中，最后一个子元素对象的后面</li>
<li>&quot;afterend&quot;: 在当前元素对象本身的后面</li>
</ul>
</li>
<li>text
<ul>
<li>以字符串形式表示的HTML</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="224-element%E4%B8%8E%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E6%96%B9%E6%B3%95">2.2.4 element与元素属性相关的属性及方法</h4>
<h5 id="2241-elementnodenametagname">2.2.4.1 element.nodeName/tagName</h5>
<h5 id="2242-elementid">2.2.4.2 element.id</h5>
<h5 id="2243-elementattributes%E5%8F%AA%E8%AF%BB">2.2.4.3 element.attributes（只读）</h5>
<ul>
<li>返回一个与该元素相关的所有属性的类数组</li>
</ul>
<h5 id="2244-elementinnerhtml">2.2.4.4 element.innerHTML</h5>
<ul>
<li>仅获取元素内容的HTML表示形式或替换元素的内容</li>
</ul>
<h5 id="2245-elementouterhtml">2.2.4.5 element.outerHTML</h5>
<ul>
<li>获取描述元素（包括其后代）的序列化HTML片段。（包括自身的标签）</li>
</ul>
<h6 id="22411-%E7%94%A8%E4%BA%8E%E6%9B%BF%E6%8D%A2%E5%BD%93%E5%89%8D%E7%9A%84%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1">2.2.4.1.1 用于替换当前的元素对象</h6>
<h5 id="2246-elementinnertext">2.2.4.6 element.innerText</h5>
<ul>
<li>返回当前元素及其后代的“渲染”文本内容
<ul>
<li>显示最终渲染完的内容，display:none无法获取</li>
</ul>
</li>
</ul>
<h5 id="2247-elementclassname">2.2.4.7 element.className</h5>
<ul>
<li>返回标签的类名值，以空格的形式分开</li>
</ul>
<h5 id="2248-elementclasslist%E5%8F%AA%E8%AF%BB">2.2.4.8 element.classList（只读）</h5>
<ul>
<li>相比将 element.className 作为以空格分隔的字符串来使用，classList 是一种更方便的访问元素的类列表的方法。</li>
<li>虽然是只读属性，但是可以使用以下的方法来进行修改</li>
</ul>
<h6 id="22431-classlistaddclassvalue">2.2.4.3.1 classList.add(...classValue)</h6>
<ul>
<li>类值增加</li>
</ul>
<h6 id="22432-classlistremoveclassvalue">2.2.4.3.2 classList.remove(...classValue)</h6>
<ul>
<li>类值删除</li>
</ul>
<h6 id="22433-classlisttoggleclassvalue">2.2.4.3.3 classList.toggle(classValue)</h6>
<ul>
<li>类值的切换
<ul>
<li>有则删去</li>
<li>没有则添加</li>
</ul>
</li>
</ul>
<h5 id="2249-elementgetattributeattrnamestring%E5%8F%AA%E8%AF%BB">2.2.4.9 element.getAttribute(attrName:string)（只读）</h5>
<ul>
<li>返回当前元素指定属性名的值</li>
</ul>
<h5 id="22410-elementgetattributenames">2.2.4.10 element.getAttributeNames()</h5>
<ul>
<li><font color="red">以数组的形式</font>返回所有具有的属性名称</li>
<li>将 getAttributeNames() 与 getAttribute() 组合使用， 是一种有效替代 Element.attributes 的使用方法.</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">// 遍历elements的元素</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> element.getAttributeNames())
  {
    <span class="hljs-keyword">let</span> value = element.getAttribute(name);
    <span class="hljs-built_in">console</span>.log(name, value);
  }
</div></code></pre>
<h5 id="22411-elementhasattributeattrnamestring">2.2.4.11 element.hasAttribute(attrName:string)</h5>
<ul>
<li>判断是否具有attrName属性，返回一个布尔值</li>
</ul>
<h5 id="22411-elementremoveattributeattrnamestring">2.2.4.11 element.removeAttribute(attrName:string)</h5>
<ul>
<li>删去attrName属性，不存在也不会报错</li>
</ul>
<h5 id="22412-elementsetattributeattrnamestring-attrvaluestring">2.2.4.12 element.setAttribute(attrName:string, attrValue:string)</h5>
<ul>
<li>设置当前属性的值</li>
</ul>
<h5 id="22413-elementtoggleattributeattrname-force">2.2.4.13 element.toggleAttribute(attrName[, force])</h5>
<ul>
<li>存在某个属性则增加，不存在则删除</li>
</ul>
<h4 id="225-element%E4%B8%8E%E6%A0%B7%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">2.2.5 element与样式相关的属性和方法</h4>
<h5 id="2251-elementclientheight-width%E5%8F%AA%E8%AF%BB">2.2.5.1 element.client[Height, Width]（只读）</h5>
<ul>
<li>该元素对象的宽度/高度，返回的是<font color="red">number类型</font></li>
<li><img src="./img/clientWidth-Top.jpg" alt="clientWidth-Top.jpg">
<ul>
<li>组成包括content和padding</li>
</ul>
</li>
</ul>
<h5 id="2252-elementclientleft-top%E5%8F%AA%E8%AF%BB">2.2.5.2 element.client[Left, Top]（只读）</h5>
<ul>
<li>element为非静态元素对象，获取其Left和Top的偏移量
<ul>
<li>子: 以border为边界</li>
<li>父: 以content为边界</li>
</ul>
</li>
</ul>
<h5 id="2253-elementscrollheight-width%E5%8F%AA%E8%AF%BB">2.2.5.3 element.scroll[Height, Width]（只读）</h5>
<ul>
<li>一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。
<ul>
<li>若没有滚动条，则值与element.client[Height, Width]相同</li>
</ul>
</li>
<li>包括content, padding, ::before, ::after</li>
</ul>
<h5 id="2254-elementscrollleft-top">2.2.5.4 element.scroll[Left, Top]</h5>
<ul>
<li><font color="red">读取或设置</font>当前元素滚动条到元素左边/上边的距离
<ul>
<li>如果元素不能滚动（比如：元素没有溢出），那么scroll[Left, Top] 的值是0。</li>
<li>如果给scroll[Left, Top] 设置的值小于0，那么scroll[Left, Top] 的值将变为0。</li>
<li>如果给scroll[Left, Top] 设置的值大于元素内容最大宽度，那么scroll[Left, Top]的值将被设为元素最大宽度。</li>
</ul>
</li>
</ul>
<h5 id="2255-elementattname-%E8%8E%B7%E5%8F%96%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7">2.2.5.5 element.[attName] （获取内联样式属性）</h5>
<ul>
<li>以字符串的形式返回attrName的属性值
<ul>
<li>导致相应的单位也会返回</li>
</ul>
</li>
</ul>
<h6 id="22551-elementvalue">2.2.5.5.1 element.value</h6>
<ul>
<li>一般用于获取或设置input的value</li>
</ul>
<h5 id="2256-elementstyleattrname">2.2.5.6 element.style.[attrName]</h5>
<ul>
<li><font color="red">用于设置内联样式的style属性</font>
<ul>
<li>若在样式表中有以-连接，则应该<font color="red">采取驼峰的形式</font></li>
<li>注意是有单位的字符串</li>
</ul>
</li>
<li>该样式的设置优先级为内联样式的优先级</li>
</ul>
<h6 id="22561-elementstylebackgroundcolor">2.2.5.6.1 element.style.backgroundColor</h6>
<ul>
<li>用于设置背景的颜色</li>
</ul>
<h5 id="2257-%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%98%AF%E5%90%A6%E5%88%B0%E5%BA%95">2.2.5.7 实现判断滚动条是否到底</h5>
<pre class="hljs"><code><div>  <span class="hljs-comment">// 当垂直滚动条滚动到底的时候有</span>
  element.clientHeight === element.scrollHeight - element.scrollTop
</div></code></pre>
<h4 id="22410">2.2.4.10</h4>
<h3 id="23-dom%E7%9A%84%E7%89%88%E6%9C%AC%E9%80%82%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98">2.3 DOM的版本适应的问题</h3>
<h4 id="6123-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7%E5%80%BC">6.1.2.3. 获取元素节点对象的行内样式属性值</h4>
<ul>
<li>元素节点对象.属性</li>
<li><font color="red">class属性不能使用这种方式</font></li>
</ul>
<h5 id="61233-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%BC%8F">6.1.2.3.3. 获取元素节点对象的样式表中的样式</h5>
<h6 id="612331-%E7%94%B1%E4%BA%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">6.1.2.3.3.1. 由于兼容性，需要自定义一个函数</h6>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">obj, name</span>) </span>{
    <span class="hljs-comment">// 判断浏览器版本太麻烦，用什么进行判断？</span>
    <span class="hljs-comment">// 正常浏览器</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle)
      <span class="hljs-keyword">return</span> getComputedStyle(obj, <span class="hljs-literal">null</span>)[name];
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> obj.currentStyle[name];
    <span class="hljs-comment">// ie8浏览器Style</span>
    
  }
</div></code></pre>
<h6 id="612332-getcomputedstyleelementobject-pseudoelements">6.1.2.3.3.2. getComputedStyle(elementObject, pseudoElements)</h6>
<ul>
<li>window方法</li>
<li>pseudoElements = null
<ul>
<li>返回了存储elementObject当前的样式的对象</li>
</ul>
</li>
<li>pseudoElements 伪元素
<ul>
<li>返回了存储elementObject伪元素当前的样式的对象</li>
</ul>
</li>
</ul>
<h6 id="612333-objectelementcurrentstyle%E6%A0%B7%E5%BC%8F%E5%90%8D">6.1.2.3.3.3. objectElement.currentStyle.样式名</h6>
<ul>
<li>获取当前元素对象显示的样式而不仅仅是内联或样式
<ul>
<li>只能ie</li>
</ul>
</li>
<li>区别：ie返回的auto，则上面一个放回的是具体的数值</li>
<li>兼容ie8</li>
</ul>
<h5 id="61241-%E4%BB%A5%E7%88%B6%E5%85%83%E7%B4%A0%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">6.1.2.4.1. 以父元素为对象的操作</h5>
<h6 id="612411-documentcreateelementtagstr">6.1.2.4.1.1. document.createElement(tagStr)</h6>
<ul>
<li>创建元素的标签对象</li>
</ul>
<h6 id="612412-documentcreatetextnodestr">6.1.2.4.1.2. document.createTextNode(str)</h6>
<ul>
<li>创建并初始化文本节点对象</li>
</ul>
<h6 id="612413-fathernodeobjectappendchildchildnodeobject">6.1.2.4.1.3. fatherNodeObject.appendChild(childNodeObject)</h6>
<ul>
<li>向父节点对象内部的最后面增加子节点对象</li>
<li>父节点为对象</li>
</ul>
<h6 id="612414-fathernodeobjectinsertbeforenewchildobject-oldchildobject">6.1.2.4.1.4. fatherNodeObject.insertBefore(newchildObject, oldchildObject)</h6>
<ul>
<li>向旧的子节点对象的前面添加新的子节点对象</li>
<li>父节点为对象</li>
</ul>
<h6 id="612415-fathernodeobjectreplacechildnewchildobject-oldchildobject">6.1.2.4.1.5. fatherNodeObject.replaceChild(newchildObject, oldchildObject)</h6>
<ul>
<li>替换旧的子节点对象为新的子节点对象</li>
</ul>
<h6 id="612416-fathernodeobjectremovechildchildobject">6.1.2.4.1.6. fatherNodeObject.removeChild(childObject)</h6>
<ul>
<li>删除子节点队形</li>
</ul>
<h6 id="612417-%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%AD%A5%E9%AA%A4%E4%BD%BF%E7%94%A8createelement">6.1.2.4.1.7. 元素对象的增加的步骤（使用createElement）</h6>
<pre class="hljs"><code><div>  <span class="hljs-comment">/*
    1. 创建子元素对象
    2. 给子元素对象赋值
    3. 添加到父元素对象中
  */</span>
  <span class="hljs-keyword">let</span> childElement = createElement(<span class="hljs-string">'div'</span>);

  <span class="hljs-keyword">let</span> text = createTextNode(<span class="hljs-string">'hello_world'</span>);
  childElement.appendChild(text);

  fatherElement.appendChild(childElement);
</div></code></pre>
<h6 id="612418-%E4%BD%BF%E7%94%A8innerhtml%E5%AF%B9%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%8A%A0">6.1.2.4.1.8. 使用innerHTML对元素进行增加</h6>
<ul>
<li>缺点:会把整一块替换</li>
</ul>
<pre class="hljs"><code><div>  fatherElement.innerHTML += childHTML
</div></code></pre>
<h6 id="612419-%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%BB%93%E5%90%88%E5%AF%B9%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%B7%BB%E5%8A%A0%E6%8E%A8%E8%8D%90">6.1.2.4.1.9. 两种方式结合对元素进行添加(推荐)</h6>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> childElement = createElement(<span class="hljs-string">'div'</span>);
  childElement.innerHTML = <span class="hljs-string">'hello_world'</span>  <span class="hljs-comment">//一般是比较固定的格式</span>
  fatherElement.appendChild(childElement);
</div></code></pre>
<h6 id="6124110-%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A0%E9%99%A4%E7%9A%84%E6%AD%A5%E9%AA%A4%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84">6.1.2.4.1.10. 元素对象的删除的步骤（经常使用的）</h6>
<pre class="hljs"><code><div><span class="hljs-comment">// 找到父亲节点之后对其进行删除</span>
  childObject.parentNode.removeChild(childObject);
</div></code></pre>
<h2 id="3-dom%E4%BA%8B%E4%BB%B6">3 DOM事件</h2>
<ul>
<li>文档或浏览器窗口中发生的一些特定交互的瞬间</li>
</ul>
<h3 id="30-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86">3.0 事件的一些基本常识</h3>
<h4 id="301-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%AC%E5%85%B1%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">3.0.1 事件的公共属性和方法</h4>
<h5 id="3011-eventtarget">3.0.1.1 event.target</h5>
<ul>
<li>event.target返回的是一个元素对象
<ul>
<li>若该事件不是冒泡事件，则event.target会捕获到当前绑定的元素对象</li>
<li>若该事件是冒泡事件，则event.target会捕获到最底层的触发该事件的元素对象</li>
</ul>
</li>
</ul>
<h5 id="3012-eventcurrenttarget">3.0.1.2 event.currentTarget</h5>
<ul>
<li>与是不是冒泡事件无关，只是返回当前触发的元素</li>
</ul>
<h5 id="3013-eventbubbles">3.0.1.3 event.bubbles</h5>
<ul>
<li>表明当前事件是否会向DOM树上层元素冒泡
<ul>
<li>event.stopPropagation()</li>
</ul>
</li>
</ul>
<h5 id="3014-eventcancelable">3.0.1.4 event.cancelable</h5>
<ul>
<li>表明该事件是否可以被取消
<ul>
<li>event.preventDefault()</li>
</ul>
</li>
</ul>
<h5 id="3015-eventtype">3.0.1.5 event.type</h5>
<h5 id="3016-eventstoppropagation">3.0.1.6 event.stopPropagation()</h5>
<ul>
<li>以前是用event.cancelBubble = true,现在用这个进行代替</li>
<li>阻止捕获和冒泡阶段中在该元素的当前事件中的进一步传播。</li>
</ul>
<h5 id="3017-eventpreventdefault">3.0.1.7 event.preventDefault()</h5>
<ul>
<li>取消当前元素触发事件的默认行为
<ul>
<li><font color="red">在on[ eventName ]的表达式形式定义的回调函数中，可以使用return false来取消事件的默认行为</font></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  elementObject.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    ...
    return <span class="hljs-literal">false</span>;
  }
</div></code></pre>
<h4 id="302-%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8F%96%E6%B6%88%E7%9A%84%E6%96%B9%E6%B3%95%E6%96%B9%E6%B3%95">3.0.2 事件与元素的绑定和取消的方法方法</h4>
<h5 id="3020-%E5%9C%A8%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%B1%9E%E6%80%A7oneventname--%22callback%22">3.0.2.0 在内联样式中增加属性on[eventName] = &quot;callback()&quot;</h5>
<h5 id="3021-elementoneventname--function">3.0.2.1 element.on[eventName] = function() {}</h5>
<ul>
<li>表达式的形式的事件绑定</li>
<li>缺点：
<ul>
<li>只能同时为一个元素的一个事件绑定一个响应函数</li>
<li>不能绑定多个，若绑定了多个，则后面的会覆盖前面的</li>
</ul>
</li>
</ul>
<h5 id="3022-elementoneventname--null">3.0.2.2 element.on[eventName] = null</h5>
<ul>
<li>表达式形式的事件取消绑定</li>
</ul>
<h5 id="3023-elementaddeventlistenereventnamestring-func-true--false">3.0.2.3 element.addEventListener(eventName:string, func, [true || false])</h5>
<ul>
<li>参数
<ul>
<li>事件的字符串，不要on</li>
<li>回调函数，当事件触发</li>
<li><a href="#addEventListener">是否在捕获阶段触发事件</a>，需要一个布尔值，默认是false</li>
</ul>
</li>
<li>优点
<ul>
<li>可以同时为一个元素对象的同一个事件绑定多个响应函数
<ul>
<li>当事件被触发时，响应函数会按照绑定的顺序进行响应</li>
</ul>
</li>
</ul>
</li>
<li>缺点
<ul>
<li>这种方法不支持ie8及以下</li>
</ul>
</li>
</ul>
<h5 id="3024-elementremoveeventlistenereventnamestring-func-true--false">3.0.2.4 element.removeEventListener(eventName:string, func, [true || false])</h5>
<h5 id="3025-elementattacheventoneventnamestring-func">3.0.2.5 element.attachEvent(on[eventName]:string, func)</h5>
<ul>
<li>适用于ie8及以下浏览器</li>
<li>参数
<ul>
<li>事件的字符串，要on</li>
<li>回调函数，当事件触发</li>
</ul>
</li>
<li>优点
<ul>
<li>可以同时为一个元素对象的同一个事件绑定多个响应函数
<ul>
<li>当事件被触发时，响应函数会按照绑定的顺序的倒序进行响应（后绑定先执行）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3025-%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">3.0.2.5 通用的事件绑定函数</h5>
<pre class="hljs"><code><div>  <span class="hljs-comment">/*
  * 参数
  * 1. obj 要绑定的事件对象
  * 2. eventName：事件名称
  * 3. callback: 回调函数
  */</span>
  <span class="hljs-comment">// addEventListener()中的callback函数中的this，是绑定事件对象</span>
  <span class="hljs-comment">// attachEvent()中的allback函数中的this是window， 所以需要修改callback的this对象</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">obj, eventName, callback</span>)</span>{
    <span class="hljs-keyword">if</span>(obj.addEventListener)
      obj.addEventListener( eventName, callback, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">else</span>
      obj.attachEvent(<span class="hljs-string">'on'</span> + eventName,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      callback.call(obj); <span class="hljs-comment">//将call的this指向obj</span>
    });
  }
  <span class="hljs-comment">// callback.bind(obj)</span>
</div></code></pre>
<h4 id="303-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD">3.0.3 事件的传播</h4>
<ul>
<li>事件的传播途径有两种
<ul>
<li>以非冒泡的形式实现事件的传播</li>
<li>以冒泡的形式实现事件的传播</li>
</ul>
</li>
</ul>
<h5 id="3031-%E9%9D%9E%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6">3.0.3.1 非冒泡事件</h5>
<ul>
<li>假设当前绑定事件的元素有子元素，且此时事件触发</li>
<li>非冒泡事件执行
<ul>
<li>并不会向其子元素传播触发的事件</li>
<li>该元素触发了事件</li>
</ul>
</li>
</ul>
<h5 id="3032-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6">3.0.3.2 冒泡事件</h5>
<ul>
<li>假设当前绑定事件的元素有子元素，且此时事件触发</li>
<li>冒泡事件的执行过程
<ul>
<li>该元素检查是否触发事件的回调函数</li>
<li>向其子元素传递该事件，导致其子元素都会检查是否触发事件的回调函数（捕获事件）</li>
<li>执行一次该事件触发的回调函数
<ul>
<li>若子元素满足回调函数的条件，则执行该子元素的事件触发回调函数，其父元素的回调函数不能再执行</li>
<li>若子元素都不满足回调函数的条件，则执行该元素的回调函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="30321-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD">3.0.3.2.1 冒泡事件的传播</h6>
<ul>
<li>ie8及以下没有捕获阶段</li>
<li>将冒泡事件分成三个阶段
<ul>
<li>捕获阶段
<ul>
<li>在捕获阶段时，从外层的祖先元素，向目标元素进行事件捕获，但是默认此时不会触发事件</li>
</ul>
</li>
<li>目标阶段
<ul>
<li>捕获到目标元素，捕获结束，开始在目标元素上触发事件</li>
</ul>
</li>
<li>冒泡阶段
<ul>
<li>事件从目标元素向它的祖先元素传递，只会触发一次相应的事件</li>
</ul>
</li>
</ul>
</li>
<li><img src="./img/ex15.jpg" alt="事件理解"></li>
<li><span id="addEventListener">addEventListener的第三个参数</span>
<ul>
<li>默认值为false
<ul>
<li>即事件的回调函数在冒泡阶段才会被触发，即子元素触发优先于祖先元素触发</li>
</ul>
</li>
<li>若设置为true
<ul>
<li>即事件的回调函数在捕获阶段被触发，即祖先元素触发优先于子元素的触发</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="30322-eventstoppropagation%E7%9A%84%E5%BA%94%E7%94%A8">3.0.3.2.2 event.stopPropagation()的应用</h6>
<ul>
<li>阻止捕获和冒泡阶段中在该元素的当前事件中的进一步传播。</li>
<li>解释
<ul>
<li>若其父元素触发的事件是一个冒泡事件，当该冒泡事件被触发时，会向子元素传播</li>
<li>在向子元素传播时，会根据子元素触发事件中是否有event.stopPropagation()以及是否触发了相同事件决定是否往下传播
<ul>
<li>若存在，则不传播且不触发任何回调函数</li>
<li>若不存在，则继续往下传播，直至底层再冒泡起来执行</li>
</ul>
</li>
</ul>
</li>
<li>使用event.stopPropagation()实现冒泡事件click父元素后不向子元素传播</li>
<li><a href="#stopPropagation">例子见下面</a></li>
</ul>
<h6 id="30323-%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE">3.0.3.2.3 利用冒泡事件实现事件委派</h6>
<ul>
<li>指将冒泡事件统一绑定给元素的共同祖先，当冒泡事件被触发，会通过事件冒泡传递给子元素且触发相应的回调函数
<ul>
<li>减少事件的绑定从而提高性能</li>
</ul>
</li>
</ul>
<h3 id="31-%E5%89%AA%E8%B4%B4%E7%89%88%E4%BA%8B%E4%BB%B6clipboardevent">3.1 剪贴版事件（ClipboardEvent）</h3>
<table>
  <thead>
    <tr>
      <th>事件名称</th>
      <th>事件基本信息</th>
      <th>事件触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>copy</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: 获得焦点的元素（即是能够编辑内容的元素)<br/>
        返回的接口类型(eventType):keyboardEvent 
      </td>
      <td>当用户通过浏览器UI（例如，使用 Ctrl/⌘+C  键盘快捷方式或从菜单中选择“复制”）</td>
    </tr>
    <tr>
      <td>cut</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: element <br/>
        返回的接口类型(eventType):keyboardEvent 
      </td>
      <td>在将选中内容从文档中删除并将其添加到剪贴板后触发。</td>
    </tr>
    <tr>
      <td>paste</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: element <br/>
        返回的接口类型(eventType):keyboardEvent 
      </td>
      <td>当用户在浏览器用户界面发起“粘贴”操作时，会触发paste事件。</td>
    </tr>
  </tbody>
</table>
<h4 id="311-%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95clipboardevent">3.1.1 剪贴板事件的属性和方法(ClipboardEvent)</h4>
<table>
  <thead>
    <tr>
      <th>事件属性</th>
      <th>属性的功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ClipboardEvent.clipboardData</td>
      <td>是一个 DataTransfer 对象，它包含了由用户发起的 cut  、 copy  和 paste  操作影响的数据,可以通过.getData(fomat)方法得到数据(fomat: "text/plain"，text/"uri-list")</td>
    </tr>
  </tbody>
</table>
<h3 id="32-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6focusevent">3.2 焦点事件(FocusEvent)</h3>
<ul>
<li>你点击某个input的时候,页面中的输入框就会变成可以输入的样子,这就叫做获取焦点</li>
</ul>
<table>
  <thead>
    <tr>
      <th>事件名称</th>
      <th>事件基本信息</th>
      <th>事件触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>blur</td>
      <td>
        Bubbles: No <br/>
        Cancelable: No <br/>
        Target: element<br/>
        返回的接口类型(eventType):FocusEvent 
      </td>
      <td>当一个元素失去焦点的时候 blur 事件被触发</td>
    </tr>
    <tr>
      <td>focus</td>
      <td>
        Bubbles: No <br/>
        Cancelable: No <br/>
        Target: element <br/>
        返回的接口类型(eventType):FocusEvent 
      </td>
      <td>focus事件在元素获取焦点时触发</td>
    </tr>
    <tr>
      <td>focusout</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: No <br/>
        Target: element <br/>
        返回的接口类型(eventType):FocusEvent  
      </td>
      <td>当元素即将失去焦点时，focusout 事件被触发</td>
    </tr>
    <tr>
      <td>focusin</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: No <br/>
        Target: element <br/>
        返回的接口类型(eventType):FocusEvent 
      </td>
      <td>focusin事件在元素获取焦点时触发</td>
    </tr>
  </tbody>
</table>
<h4 id="321-%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95focusevent">3.2.1 焦点事件的属性和方法(FocusEvent)</h4>
<table>
  <thead>
    <tr>
      <th>事件属性</th>
      <th>属性的功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FocusEvent.relatedTarget</td>
      <td>补充</td>
    </tr>
  </tbody>
</table>
<ul>
<li>focus/blur 和 focusin/focusout区别
<ul>
<li>前两个不触发冒泡事件，而后两个触发冒泡事件</li>
</ul>
</li>
</ul>
<h3 id="33-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6">3.3 键盘事件</h3>
<table>
  <thead>
    <tr>
      <th>事件名称</th>
      <th>事件基本信息</th>
      <th>事件触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>keyup</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: 键盘 <br/>
        返回的接口类型(eventType):KeyboardEvent </br> 
      </td>
      <td>当一个按钮按下后被释放时触发</td>
    </tr>
    <tr>
      <td>keydown</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: 元素 <br/>
        返回的接口类型(eventType):KeyboardEvent 
      </td>
      <td>当一个按钮被按下时触发</td>
    </tr>
  </tbody>
</table>
<h4 id="331-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95keyboardevent">3.3.1 键盘事件的属性和方法(KeyboardEvent)</h4>
<table>
  <thead>
    <tr>
      <th>事件属性</th>
      <th>属性的功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>KeyboardEvent.ctrlKey（只读）</td>
      <td>返回一个Boolean, 如果按键事件ctrl被按下，则为true</td>
    </tr>
    <tr>
      <td>KeyboardEvent.ctrlKey（只读）</td>
      <td>返回一个Boolean, 如果按键事件产生ctrl被按下，则为true</td>
    </tr>
    <tr>
      <td>KeyboardEvent.AltKey（只读）</td>
      <td>返回一个Boolean, 如果按键事件产生Alt被按下，则为true</td>
    </tr>
    <tr>
      <td>KeyboardEvent.shiftKey（只读）</td>
      <td>返回一个Boolean, 如果按键事件产生shift被按下，则为true</td>
    </tr>
    <tr>
      <td>KeyboardEvent.metaKey（只读）</td>
      <td>返回一个Boolean, 如果按键事件产生窗口按钮被按下，则为true</td>
    </tr>
    <tr>
      <td>KeyboardEvent.code（只读）</td>
      <td>返回一个DOMString, code代表事件触发的物理按键</td>
    </tr>
    <tr>
      <td>KeyboardEvent.repeat（只读）</td>
      <td>返回一个Boolean, 如果按键一直被按住，则返回true</td>
    </tr>
  </tbody>
</table>
<h3 id="34-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6">3.4 鼠标事件</h3>
<table>
  <thead>
    <tr>
      <th>事件名称</th>
      <th>事件基本信息</th>
      <th>事件触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>click</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮在一个元素对象上按下和放开时触发</td>
    </tr>
    <tr>
      <td>dblclick</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮在一个元素对象上短时间内两次按下和放开时触发</td>
    </tr>
    <tr>
      <td>mousedown</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮在一个元素对象上被（连续）按下时触发</td>
    </tr>
    <tr>
      <td>mouseup</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮在一个元素对象上被松开时触发</td>
    </tr>
    <tr>
      <td>mouseenter</td>
      <td>
        Bubbles: No <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮进入一个元素对象的区域时触发</td>
    </tr>
    <tr>
      <td>mouseleave</td>
      <td>
        Bubbles: No <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮离开一个元素对象的区域时触发</td>
    </tr>
    <tr>
      <td>mouseover</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮进入一个元素对象的区域时触发</td>
    </tr>
    <tr>
      <td>mouseout</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮离开一个元素对象的区域时触发</td>
    </tr>
    <tr>
      <td>mousemove</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):MouseEvent </br> 
      </td>
      <td>当定点设备的按钮在一个元素对象上移动时触发</td>
    </tr>
  </tbody>
</table>
<ul>
<li>mouseenter和mouseover的区别</li>
<li>mouseenter不能产生冒泡事件</li>
<li>mouseover有冒泡事件</li>
</ul>
<h4 id="341-%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95mouseevent">3.4.1 鼠标事件的属性和方法(MouseEvent)</h4>
<ul>
<li><span id="MouseEvent">鼠标事件</span></li>
</ul>
<table>
  <thead>
    <tr>
      <th>事件属性</th>
      <th>属性的功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MouseEvent.ctrlKey（只读）</td>
      <td>返回一个Boolean, 如果鼠标事件ctrl被按下，则为true</td>
    </tr>
    <tr>
      <td>MouseEvent.ctrlKey（只读）</td>
      <td>返回一个Boolean, 如果鼠标事件产生ctrl被按下，则为true</td>
    </tr>
    <tr>
      <td>MouseEvent.AltKey（只读）</td>
      <td>返回一个Boolean, 如果鼠标事件产生Alt被按下，则为true</td>
    </tr>
    <tr>
      <td>MouseEvent.shiftKey（只读）</td>
      <td>返回一个Boolean, 如果鼠标事件产生shift被按下，则为true</td>
    </tr>
    <tr>
      <td>MouseEvent.metaKey（只读）</td>
      <td>返回一个Boolean, 如果鼠标事件产生窗口按钮被按下，则为true</td>
    </tr>
    <tr>
      <td>MouseEvent.detail（只读）</td>
      <td>返回在短时间内元素对象被连续点击的次数（long)</td>
    </tr>
    <tr>
      <td>MouseEvent.screenX（只读）</td>
      <td>返回点击位置对应屏幕的x轴坐标</td>
    </tr>
    <tr>
      <td>MouseEvent.screenY（只读）</td>
      <td>返回点击位置对应屏幕的y轴坐标</td>
    </tr>
    <tr>
      <td>MouseEvent.clientX（只读）</td>
      <td>返回点击位置对应浏览器窗口的x轴坐标，当存在滚动条时，只表示在当前窗口的位置</td>
    </tr>
    <tr>
      <td>MouseEvent.clientY（只读）</td>
      <td>返回点击位置对应浏览器窗口的y轴坐标，当存在滚动条时，只表示在当前窗口的位置</td>
    </tr>
    <tr>
      <td>MouseEvent.movementX（只读）</td>
      <td>它提供了当前事件和上一个mousemove事件之间鼠标在水平方向上的移动值。相当于currentEvent.movementX = currentEvent.screenX - previousEvent.screenX</td>
    </tr>
    <tr>
      <td>MouseEvent.movementY（只读）</td>
      <td>它提供了当前事件和上一个mousemove事件之间鼠标在垂直方向上的移动值。相当于currentEvent.movementY = currentEvent.screenY - previousEvent.screenY</td>
    </tr>
    <tr>
      <td>MouseEvent.pageX（只读）</td>
      <td>返回的相对于整个文档的x（水平）坐标，要和clientX区分开来，当具有滚动条时，表示的是整个页面的鼠标位置，对于ie8及以下不兼容</td>
    </tr>
    <tr>
      <td>MouseEvent.pageY（只读）</td>
      <td>返回的相对于整个文档的y（水平）坐标，要和clientY区分开来，当具有滚动条时，表示的是整个页面的鼠标位置，对于ie8及以下不兼容</td>
    </tr>
    <tr>
      <td>MouseEvent.button（只读）</td>
      <td>返回点击按钮(long)，0为鼠标左键，1为鼠标中间的按钮，2为鼠标右键</td>
    </tr>
    <tr>
      <td>MouseEvent.buttons（只读）</td>
      <td>返回多个点击按钮,通过加号进行计算（long），1为鼠标的左键，2为鼠标的右键，4为鼠标的滚轮，8为浏览器的后退按钮，16为浏览器的前进按钮</td>
    </tr>
  </tbody>
</table>
<h3 id="35-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6">3.5 触摸事件</h3>
<table>
  <thead>
    <tr>
      <th>事件名称</th>
      <th>事件基本信息</th>
      <th>事件触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>touchcancel</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: No <br/>
        Target: Element <br/>
        返回的接口类型(eventType):TouchEvent </br> 
      </td>
      <td>当触摸点被中断时会触发 touchcancel 事件，中断方式基于特定实现而有所不同（例如， 创建了太多的触摸点）</td>
    </tr>
    <tr>
      <td>touchstart</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes<br/>
        Target: Element <br/>
        返回的接口类型(eventType):TouchEvent </br> 
      </td>
      <td>当一个或多个触摸点与触控设备表面接触时触发touchstart 事件</td>
    </tr>
    <tr>
      <td>touchmove</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes<br/>
        Target: Element <br/>
        返回的接口类型(eventType):TouchEvent </br> 
      </td>
      <td>当一个或多个触摸点在触控设备表面移动时触发touchstart 事件</td>
    </tr>
    <tr>
      <td>touchend</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes<br/>
        Target: Element <br/>
        返回的接口类型(eventType):TouchEvent </br> 
      </td>
      <td>当一个或多个触摸点与触控设备表面离开时触发touchstart 事件</td>
    </tr>
  </tbody>
</table>
<h4 id="340-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B">3.4.0 触摸事件的类型</h4>
<ul>
<li>触摸事件可以分为三类，可以用TouchEvent.type来查看当前的触摸事件的类型
<ul>
<li>touchstart
<ul>
<li>当用户在触摸平面上放置了一个触点时触发</li>
</ul>
</li>
<li>touchmove
<ul>
<li>当用户在触摸平面上移动触点时触发</li>
</ul>
</li>
<li>touchend
<ul>
<li>当一个触点被用户从触摸平面上移除（即用户的一个手指或手写笔离开触摸平面）时触发。当触点移出触摸平面的边界时也将触发</li>
</ul>
</li>
<li>touchcancel
<ul>
<li>当触点由于某些原因被中断时触发。有几种可能的原因如下（具体的原因根据不同的设备和浏览器有所不同）：
<ul>
<li>由于某个事件出现而取消了触摸：例如触摸过程被弹窗打断。</li>
<li>触点离开了文档窗口，而进入了浏览器的界面元素、插件或者其他外部内容区域。</li>
<li>当用户产生的触点个数超过了设备支持的个数，从而导致 TouchList 中最早的 Touch 对象被取消。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="341-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95touchevent">3.4.1 触摸事件的属性和方法(TouchEvent)</h4>
<table>
  <thead>
    <tr>
      <th>事件属性</th>
      <th>属性的功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TouchEvent.ctrlKey（只读）</td>
      <td>返回一个Boolean, 如果触摸事件ctrl被按下，则为true</td>
    </tr>
    <tr>
      <td>TouchEvent.ctrlKey（只读）</td>
      <td>返回一个Boolean, 如果触摸事件产生ctrl被按下，则为true</td>
    </tr>
    <tr>
      <td>TouchEvent.AltKey（只读）</td>
      <td>返回一个Boolean, 如果触摸事件产生Alt被按下，则为true</td>
    </tr>
    <tr>
      <td>TouchEvent.shiftKey（只读）</td>
      <td>返回一个Boolean, 如果触摸事件产生shift被按下，则为true</td>
    </tr>
    <tr>
      <td>TouchEvent.metaKey（只读）</td>
      <td>返回一个Boolean, 如果触摸事件产生窗口按钮被按下，则为true</td>
    </tr>
    <tr>
      <td>TouchEvent.changedTouches（只读）</td>
      <td>返回一个发生改变的元素对象的类数组, 包含所有被触发的对象（因为可以多只手指来触发）</td>
    </tr>
    <tr>
      <td>TouchEvent.targetTouches（只读）</td>
      <td>返回一个包含所有触点的底层的元素对象的类数组, 包含所有被触发的对象（因为可以多只手指来触发）</td>
    </tr>
    <tr>
      <td>TouchEvent.touches（只读）</td>
      <td>返回一个触点的元素对象的类数组, 包含所有被触发的对象（因为可以多只手指来触发）</td>
    </tr>
  </tbody>
</table>
<h4 id="342-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3.4.2 触摸事件的注意事项</h4>
<ul>
<li>触摸事件和鼠标事件会同时被触发（目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作）。如果你使用了触摸事件，可以调用 event.preventDefault() 来阻止鼠标事件被触发</li>
</ul>
<h3 id="36-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6wheelevent">3.6 滚轮事件（WheelEvent)</h3>
<table>
  <thead>
    <tr>
      <th>事件名称</th>
      <th>事件基本信息</th>
      <th>事件触发条件</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>wheel</td>
      <td>
        Bubbles: Yes <br/>
        Cancelable: Yes <br/>
        Target: Element <br/>
        返回的接口类型(eventType):WheelEvent </br> 
      </td>
      <td>当鼠标的滚轮被滑动时触发</td>
    </tr>
  </tbody>
</table>
<h4 id="361-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95wheelevent">3.6.1 滚轮事件的属性和方法(WheelEvent)</h4>
<ul>
<li><a href="#MouseEvent">继承了鼠标事件的属性和方法</a></li>
</ul>
<table>
  <thead>
    <tr>
      <th>事件属性</th>
      <th>属性的功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>deltaX</td>
      <td>水平滚动量以WheelEvent.deltaMode 为单位</td>
    </tr>
    <tr>
      <td>deltaY</td>
      <td>垂直滚动量以WheelEvent.deltaMode 为单位</td>
    </tr>
    <tr>
      <td>deltaZ</td>
      <td>Z轴滚动量以WheelEvent.deltaMode 为单位</td>
    </tr>
  </tbody>
</table>
<h4 id="362-wheel%E7%9A%84%E5%8E%86%E5%8F%B2">3.6.2 wheel的历史</h4>
<ul>
<li>在之前，该事件是以onmousewheel来触发的</li>
<li>有一个.wheelDelta事件属性的注意事项</li>
<li>获取事件中滚轮滚动的方向
<ul>
<li>正值：向上，与数值无关</li>
<li>负值：向下,与数值无关</li>
</ul>
</li>
<li>属性中火狐不支持
<ul>
<li>使用event.detail
<ul>
<li>正值，向下</li>
<li>负值，向上</li>
</ul>
</li>
</ul>
</li>
<li>实现兼容判断方向</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">if</span>(event.wheelDelta &gt; <span class="hljs-number">0</span> || event.detail &lt; <span class="hljs-number">0</span>){
    ... <span class="hljs-comment">//向上</span>
  }
  <span class="hljs-keyword">else</span>{
    向下
  }
</div></code></pre>
<h3 id="37-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A6%81%E5%AD%A6%E4%BC%9A%E7%9A%84%E5%BA%94%E7%94%A8">3.7 事件的一些要学会的应用</h3>
<h4 id="371-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%AD%90%E7%9B%92%E5%92%8C%E7%88%B6%E7%9B%92%E7%9A%84%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96">3.7.1 冒泡事件实现子盒和父盒的颜色变化</h4>
<ul>
<li>实现功能
<ul>
<li>点击子盒：盒子颜色变成蓝色</li>
<li>点击父盒：盒子颜色变成黑色</li>
</ul>
</li>
</ul>
<h5 id="3711-%E5%88%A9%E7%94%A8eventstoppropagation">3.7.1.1 利用event.stopPropagation()</h5>
<ul>
<li><span id="stopPropagation">关键点：</span>
<ul>
<li>在子盒的触发事件中增加阻止冒泡的作用
<ul>
<li>当父盒的事件触发且可以满足子盒往下传播的条件时，会被阻止冒泡所阻止，从而导致父盒的回调函数不能被触发</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
      <span class="hljs-selector-class">.container</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
      }
      <span class="hljs-selector-class">.inner</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;
      }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 
    当鼠标进入.inner时，inner变成2s时间蓝色，而container不变色
    当鼠标进入.container时，container变成黑色
   --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params">event, color</span>) </span>{
          alert(event.target.className);
          event.target.style.backgroundColor = color;
        }
        <span class="hljs-keyword">let</span> inner = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".inner"</span>);
        <span class="hljs-keyword">let</span> container = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".container"</span>);
        inner.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
          event = event || <span class="hljs-built_in">window</span>.event;
          event.stopPropagation();
          changeColor(event, <span class="hljs-string">"#0000ff"</span>);
        })
        <span class="hljs-comment">// 使用mouseenter绑定inner -- 非冒泡，且event.target为绑定的事件</span>
        container.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
          event = event || <span class="hljs-built_in">window</span>.event;
          changeColor(event, <span class="hljs-string">"#000000"</span>);
        })
        
      }
	  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h5 id="3712-%E5%88%A9%E7%94%A8%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%87%BA%E5%8F%91%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8D%B3eventtarget%E7%9A%84%E4%B8%8D%E5%90%8C">3.7.1.2 利用冒泡事件的出发元素的不同（即event.target的不同）</h5>
<ul>
<li>在冒泡事件中
<ul>
<li>event.target所得到的元素对象为触发该事件回调函数的事件</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
      <span class="hljs-selector-class">.container</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
      }
      <span class="hljs-selector-class">.inner</span> {
        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;
      }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 
    当鼠标进入.inner时，inner变成2s时间蓝色，而container不变色
    当鼠标进入.container时，container变成黑色
   --&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"inner"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params">event, color</span>) </span>{
          alert(event.target.className);
          event.target.style.backgroundColor = color;
        }
        <span class="hljs-keyword">let</span> container = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".container"</span>);
        container.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
          event = event || <span class="hljs-built_in">window</span>.event;
          <span class="hljs-keyword">if</span>(event.target === container)
            changeColor(event, <span class="hljs-string">"#000000"</span>);
          <span class="hljs-keyword">else</span>
            changeColor(event, <span class="hljs-string">"#0000ff"</span>);
        })
        
      }
	  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h4 id="372-%E5%AE%9E%E7%8E%B0%E5%85%A8%E9%80%89%E6%A1%86">3.7.2 实现全选框</h4>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"option"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"https://www.baidu.com/s?"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"get"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>你的爱好运动是?<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"all-select"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"all-select"</span>&gt;</span>全选/全不选<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hobbies"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"football"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"wd"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"football"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"football"</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"basketball"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"wd"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"basketball"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"basketball"</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"badminton"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"wd"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"badminton"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"badminton"</span>&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ping-pong"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"wd"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ping-pong"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"ping-pong"</span>&gt;</span>乒乓球<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"buttons"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btnSelectAll"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>全选<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btnSelectNone"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>全不选<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"btnSelectNot"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>反选<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">const</span> btnSelectAll = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#option .buttons #btnSelectAll'</span>);
        <span class="hljs-keyword">const</span> btnSelectNone = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#option .buttons #btnSelectNone'</span>);
        <span class="hljs-keyword">const</span> btnSelectNot = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#option .buttons #btnSelectNot'</span>);
        <span class="hljs-keyword">const</span> selectAll = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#option #all-select'</span>);
        <span class="hljs-keyword">const</span> inputsHobbies = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'#option .hobbies input'</span>);
        <span class="hljs-comment">// 思路</span>
        <span class="hljs-comment">/*
            1. 将各个按钮的功能和input选择框单项联系起来
            2. input选择框单项和各个按钮的功能联系起来
            3. 总结和提取相应的函数以简化代码
        */</span>
        <span class="hljs-comment">/*
        *给某一个按钮绑定一个点击事件，用于操作所有的选择框
        *button: 绑定的按钮
        *func： 操作选择框内容的函数
        */</span> 
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick</span>(<span class="hljs-params">button, func</span>) </span>{
            button.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-comment">// 对input框进行操作</span>
                inputsHobbies.forEach(func);
                <span class="hljs-comment">// 判断上面的全选框的结果</span>
                <span class="hljs-comment">// flag用于判断是不是全选</span>
                <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;
                inputsHobbies.forEach(<span class="hljs-function"><span class="hljs-params">btn</span> =&gt;</span> flag = btn.checked &amp;&amp; flag);
                selectAll.checked = flag;
            }
        }
        <span class="hljs-comment">/*绑定三个按钮以及全选择框以及4个input*/</span>
        btnClick(btnSelectAll, inputHobbies =&gt; inputHobbies.checked = <span class="hljs-literal">true</span>)
        btnClick(btnSelectNone, inputHobbies =&gt; inputHobbies.checked = <span class="hljs-literal">false</span>)
        btnClick(btnSelectNot, inputHobbies =&gt; inputHobbies.checked = !inputHobbies.checked)
        btnClick(selectAll, inputHobbies =&gt; inputHobbies.checked = selectAll.checked)

        <span class="hljs-comment">/*由于不需要对每个input执行函数，所以使用了空的函数*/</span>
        inputsHobbies.forEach(<span class="hljs-function"><span class="hljs-params">inputHobbies</span> =&gt;</span> btnClick(inputHobbies, ()=&gt;{}))
        <span class="hljs-comment">// 箭头函数的this是在定义外函数</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h4 id="373-%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E7%9A%84%E6%8B%96%E6%8B%BD">3.7.3 实现元素的拖拽</h4>
<ul>
<li>当鼠标在该拖拽元素按下时，开始拖拽(onmousedown)</li>
<li>当鼠标移动时，被拖拽元素(onmousemove)</li>
<li>当鼠标松开时，拖拽元素固定在当前位置(onmouseup)</li>
</ul>
<h5 id="3731-%E6%8B%96%E6%8B%BD%E6%97%B6%E9%BC%A0%E6%A0%87%E4%BD%8D%E4%BA%8E%E5%B7%A6%E4%B8%8A%E8%A7%92">3.7.3.1 拖拽时鼠标位于左上角</h5>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box1</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
            <span class="hljs-attribute">position</span>: absolute;
        }
        <span class="hljs-selector-class">.box2</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 相同的absolute的层叠现象，后面的覆盖先前的 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">let</span> box1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.box1'</span>);
            box1.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-comment">// alert('开始拖拽')</span>
                <span class="hljs-comment">// 不能给box1绑定，因为鼠标会脱离对应的边缘</span>
                <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                    event = event || <span class="hljs-built_in">window</span>.event;
                    <span class="hljs-keyword">const</span> x = event.clientX
                    <span class="hljs-keyword">const</span> y = event.clientY;
                    <span class="hljs-keyword">const</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;
                    box1.style.left = x + <span class="hljs-string">'px'</span>;
                    box1.style.top = y + scrollTop + <span class="hljs-string">'px'</span>;
                }
                <span class="hljs-comment">// box1.onmouseup</span>
                <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                   <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;
                   <span class="hljs-built_in">document</span>.onmoveup = <span class="hljs-literal">null</span>;
                } 
            }
        }
        <span class="hljs-comment">/* 问题：
            1. 当拖拽元素移动到第二个非拖拽元素的位置时，由于层叠的原因会被覆盖。此时松开鼠标，并没有实现元素的位置固定
             原因：鼠标绑定的是box1，当移动到第二个元素时，松开时触发的是第二个元素mouseup的事件而不是box1，所以无效
             改box1 -&gt; document
            2. 改成document要注意取消该事件。(没有存在意义的事件要取消)

*/</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h5 id="3732-%E6%8B%96%E6%8B%BD%E4%BD%8D%E7%BD%AE%E4%BD%8D%E4%BA%8E%E9%BC%A0%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%88%9A%E5%BC%80%E5%A7%8B%E7%82%B9%E5%87%BB%E7%9A%84%E4%BD%8D%E7%BD%AE">3.7.3.2 拖拽位置位于鼠标位置刚开始点击的位置</h5>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box1</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-comment">/* 相对于body进行定位 */</span>
        }
        <span class="hljs-selector-class">.box2</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00ff00</span>;
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 相同的absolute的层叠现象，后面的覆盖先前的 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">let</span> box1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.box1'</span>);
            box1.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                <span class="hljs-comment">// alert('开始拖拽')</span>
                <span class="hljs-comment">// 不能给box1绑定，因为鼠标会脱离对应的边缘</span>
                <span class="hljs-comment">// offsetX， offsetY为元素和鼠标之间的相对距离</span>
                <span class="hljs-comment">// offsetLeft为定位元素相对于祖先非static的left，且返回一个数值</span>
                <span class="hljs-comment">// .style是用于设置元素的位置，进行计算时记得使用元素对象的属性而不是style的属性</span>
                <span class="hljs-keyword">let</span> offsetX = event.clientX - <span class="hljs-keyword">this</span>.offsetLeft;
                <span class="hljs-keyword">let</span> offsetY = event.clientY - <span class="hljs-keyword">this</span>.offsetTop;

                <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                    event = event || <span class="hljs-built_in">window</span>.event;
                    <span class="hljs-keyword">let</span> x = event.clientX
                    <span class="hljs-keyword">let</span> y = event.clientY;
                    <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;
                    box1.style.left = x - offsetX + <span class="hljs-string">'px'</span>;
                    box1.style.top = y + scrollTop - offsetY + <span class="hljs-string">'px'</span>;
                }
                <span class="hljs-comment">// box1.onmouseup</span>
                <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                   <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;
                   <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
                } 
            }
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h5 id="3733-%E5%8F%96%E6%B6%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E9%80%A0%E6%88%90%E6%8B%96%E6%8B%BD%E7%9A%84bug">3.7.3.3 取消浏览器的默认行为造成拖拽的bug</h5>
<ul>
<li>当我们拖拽一个网页的内容时，浏览器会默认去搜索引擎中搜索内容，这时回导致出现拖拽的bug</li>
<li>方法1: 利用return false取消浏览器的默认行为
<ul>
<li>该方法对ie8及以下没有作用</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  box.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    ...
    return <span class="hljs-literal">false</span>;
  }
</div></code></pre>
<ul>
<li>方法2：利用elementObject.setCapture()和elementObject.releaseCapture();</li>
<li>当一个元素设置了setCapture(),这个元素会把下一次全部相同的事件捕获到自己的身上</li>
<li>当mousedown的时候设置，当mouseup时释放</li>
</ul>
<pre class="hljs"><code><div>  box.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    elementObject.setCapture &amp;&amp; elementObject.setCapture();
    ...
    ...
    box.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      ...
      elementObject.releaseCapture &amp;&amp; elementObject.releaseCapture();
    }
  }
</div></code></pre>
<ul>
<li>方法3： 兼容性写法(利用短路)</li>
</ul>
<pre class="hljs"><code><div>  box.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    elementObject.setCapture();
    ...
    ...
    box.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      ...
      elementObject.releaseCapture();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</div></code></pre>
<h5 id="3734-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%AA%E6%8B%96%E6%8B%BD%E5%87%BD%E6%95%B0">3.7.3.4 总结一个拖拽函数</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drag</span>(<span class="hljs-params">obj</span>) </span>{
  obj.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-comment">// 解决浏览器默认搜索的bug</span>
  obj.setCapture &amp;&amp; obj.setCapture();
      <span class="hljs-comment">// 实现浏览器兼容</span>
  event = event || <span class="hljs-built_in">window</span>.event;
      <span class="hljs-comment">// 得到相对位置，注意在计算过程中是不用style中的值</span>
  <span class="hljs-keyword">let</span> offsetX = event.clientX - <span class="hljs-keyword">this</span>.offsetLeft;
  <span class="hljs-keyword">let</span> offsetY = event.clientY - <span class="hljs-keyword">this</span>.offsetTop;
  <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">let</span> mouseX = event.clientX;
      <span class="hljs-keyword">let</span> mouseY = event.clientY;
      <span class="hljs-comment">// 解决下方出现滚动条的问题</span>
      <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop;
      obj.style.left = mouseX - offsetX + <span class="hljs-string">'px'</span>;
      obj.style.top = mouseY + scrollTop - offsetY + <span class="hljs-string">'px'</span>;
  }
  <span class="hljs-comment">// document防止延迟时鼠标脱离范围导致无法触发</span>
  <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// 对于document的方法，在结束触发时要记得消除；</span>
      <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;
      obj.releaseCapture &amp;&amp; obj.releaseCapture();
      <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">// 同样是取消浏览器的默认行为</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
}
</div></code></pre>
<h4 id="374-%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E7%94%A8">3.7.4 滚轮事件的运用</h4>
<pre class="hljs"><code><div>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .box {
            min-height: 50px;
            height: 100px;
            width: 100px;
            background-color: #ff0000;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 鼠标向下滚动时，div高变大，向上滚动时变小 --&gt;
    &lt;div class="box"&gt;&lt;/div&gt;
    &lt;script&gt;
        const box = document.querySelector('.box');
        
        function bind(obj, eventName, callback) {
            if(obj.addEventListener) {
                obj.addEventListener(obj, eventName, callback);
            }
            else {
                obj.attachEvent(eventName, function() {
                    callback.call(obj);
                })
            }
        }
        // onmousewheel中火狐并不支持，只能使用addEventListener进行绑定，且对应的事件名称为'DOMMouseScroll'
        box.onmousewheel = function (event) {
            // 火狐中并没有event.wheelDelta属性，只有event.detail；
            if(event.wheelDelta &gt; 0 || event.detail &lt; 0){
                box.style.height = box.clientHeight - 10 + 'px';
            }
            else {
                box.style.height = box.clientHeight + 10 + 'px';
            }
            // 当触发该响应函数时，取消滑动鼠标滚轮时浏览器滚动条的默认行为
            event.preventDefault &amp;&amp; event.preventDefault();
            // ie浏览器并不支持这种方式来取消浏览器的默行为
            return false;
        }
        
        bind(box,'DOMMouseScroll', box.onmousewheel);
        
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</div></code></pre>
<ul>
<li>注意
<ul>
<li>取消浏览器的默认行为的两种方法</li>
<li>onmousewheel在两种浏览器的不同写法，以及共用写法。</li>
</ul>
</li>
</ul>
<h4 id="375-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E7%94%A8">3.7.5 键盘事件的运用</h4>
<ul>
<li>利用event.keyCode获得对应键盘的编码</li>
</ul>
<h5 id="3751-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E6%8C%89%E9%94%AE%E7%9A%84%E5%88%A4%E6%96%AD">3.7.5.1 实现两个按键的判断</h5>
<pre class="hljs"><code><div><span class="hljs-comment">// ctrl+y的判断</span>
  <span class="hljs-built_in">document</span>.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">if</span>(event.ctrlKey &amp;&amp; event.keyCode === <span class="hljs-number">17</span>) {
      ...
    }
  }
</div></code></pre>
<h5 id="3672-%E9%99%90%E5%88%B6input%E6%A1%86%E7%9A%84%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9">3.6.7.2 限制input框的输入内容</h5>
<pre class="hljs"><code><div><span class="hljs-comment">// 当input被取消浏览器的默认行为时，则输入的内容不会出现在文本框之中</span>
  input.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    ...
    return <span class="hljs-literal">false</span>;
  }
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// 禁止input框输入数字</span>
        <span class="hljs-keyword">let</span> inputElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input'</span>);
        inputElement.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
            event = event || <span class="hljs-built_in">window</span>.event;
            <span class="hljs-comment">// 利用return false取消默认行为的方法</span>
            <span class="hljs-keyword">if</span>(event.keyCode &gt;= <span class="hljs-number">48</span> &amp;&amp; event.keyCode &lt;= <span class="hljs-number">57</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h5 id="3673-div%E5%85%83%E7%B4%A0%E7%9A%84%E7%A7%BB%E5%8A%A8">3.6.7.3 div元素的移动</h5>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
            <span class="hljs-attribute">position</span>: absolute;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> step = <span class="hljs-number">5</span>;
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">const</span> dir = {
                <span class="hljs-number">38</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>],
                <span class="hljs-number">39</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
                <span class="hljs-number">40</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
                <span class="hljs-number">37</span>: [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>]
            }
            <span class="hljs-keyword">let</span> box = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.box'</span>);
            <span class="hljs-built_in">document</span>.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                <span class="hljs-keyword">if</span> (event.shiftKey &amp;&amp; event.keyCode === <span class="hljs-number">38</span>) {
                    step += <span class="hljs-number">5</span>;
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (event.shiftKey &amp;&amp; event.keyCode === <span class="hljs-number">40</span>) {
                    step = step &gt;= <span class="hljs-number">10</span> ? step - <span class="hljs-number">5</span> : <span class="hljs-number">5</span>;
                    <span class="hljs-keyword">return</span>;
                }
                event = event || <span class="hljs-built_in">window</span>.event;
                <span class="hljs-comment">// 上：38 右：39 下：40 左：37</span>
                <span class="hljs-built_in">console</span>.log(box.offsetLeft)
                box.style.left = box.offsetLeft + step*dir[event.keyCode][<span class="hljs-number">0</span>] + <span class="hljs-string">'px'</span>;
                box.style.top = box.offsetTop + step*dir[event.keyCode][<span class="hljs-number">1</span>] + <span class="hljs-string">'px'</span>;
            }
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h3 id="38-%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98">3.8 与事件相关的兼容性问题</h3>
<h4 id="381-%E8%8E%B7%E5%8F%96%E6%A0%B7%E5%BC%8F%E8%A1%A8%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98">3.8.1 获取样式表中属性值的兼容性问题</h4>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">obj, name</span>) </span>{
  <span class="hljs-comment">// 判断浏览器版本太麻烦，用什么进行判断？</span>
  <span class="hljs-comment">// 正常浏览器</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle)
      <span class="hljs-keyword">return</span> getComputedStyle(obj, <span class="hljs-literal">null</span>)[name];
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> obj.currentStyle[name];
  <span class="hljs-comment">// ie8浏览器Style</span>
}
</div></code></pre>
<h4 id="382-event%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92">3.8.2 event参数的传递</h4>
<ul>
<li>为了解决兼容性的问题，事件在事件函数中传递event常用以下形式
<ul>
<li>ie8以下不传递该参数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  elenmentObject.onevent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">const</span> event = event || <span class="hljs-built_in">window</span>.event
  }
</div></code></pre>
<h4 id="383-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95">3.8.3 绑定事件的兼容性写法</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/*
* 参数
* 1. obj 要绑定的事件对象
* 2. eventName：事件名称
* 3. callback: 回调函数
*/</span>
<span class="hljs-comment">// addEventListener()中的callback函数中的this，是绑定事件对象</span>
<span class="hljs-comment">// attachEvent()中的allback函数中的this是window， 所以需要修改callback的this对象</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">obj, eventName, callback</span>)</span>{
    <span class="hljs-keyword">if</span>(obj.addEventListener)
      obj.addEventListener( eventName, callback, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">else</span>
      obj.attachEvent(<span class="hljs-string">'on'</span> + eventName,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        callback.call(obj); <span class="hljs-comment">//将call的this指向obj</span>
      });
  }
<span class="hljs-comment">// callback.bind(obj)</span>

</div></code></pre>
<h4 id="6131-elementobjectclientwidth-elementobjectclientheight">6.1.3.1. elementObject.clientWidth, elementObject.clientHeight</h4>
<ul>
<li>返回元素对象的可见宽度和可见高度
<ul>
<li>即包括content和padding（包含滚动条）</li>
<li>由于是计算过来的，所以readonly，不能够修改</li>
</ul>
</li>
<li>只是返回相应的数字而不带px，可以直接用于计算</li>
</ul>
<h4 id="6132-elementobjectoffsetwidth-elementobjectoffsetheight">6.1.3.2. elementObject.offsetWidth, elementObject.offsetHeight</h4>
<ul>
<li>返回元素对象的整个宽度和整个高度
<ul>
<li>即包括content + padding + border</li>
<li>由于计算来的，所以readonly</li>
</ul>
</li>
<li>只是返回相应的数字</li>
</ul>
<h4 id="6133-elementobjectoffsetparent">6.1.3.3. elementObject.offsetParent</h4>
<ul>
<li>获取当前元素的定位父元素对象
<ul>
<li>获取到的离当前元素最近的非static祖先元素</li>
</ul>
</li>
<li>若没有，则默认为body</li>
</ul>
<h4 id="6134-elementobjectoffsetleftright-elementobjectoffsettopbuttom">6.1.3.4. elementObject.offset[Left,right], elementObject.offset[Top,buttom]</h4>
<ul>
<li>当前元素相对于其定位元素(offsetParent(非static))的水平偏移量/垂直偏移量
<ul>
<li>包含父元素的padding+top/left</li>
</ul>
</li>
</ul>
<h4 id="6135-elementobjectscrollwidth-elementobjectscrollheight">6.1.3.5. elementObject.scrollWidth, elementObject.scrollHeight</h4>
<ul>
<li>在父元素有overflow:auto/scroll下
<ul>
<li>获取滚动区域整个宽度/高度</li>
</ul>
</li>
</ul>
<h4 id="6136-elementobjectscrollleft-elementobjectscrolltop">6.1.3.6. elementObject.scrollLeft, elementObject.scrollTop</h4>
<ul>
<li>在父元素有overflow:auto/scroll下
<ul>
<li>获取滚动条滚动的距离（水平/垂直）</li>
</ul>
</li>
</ul>
<h4 id="6137-elementobjectscrollheight-elementobjectscrolltop%E5%92%8Celementobjectclientheight%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">6.1.3.7. elementObject.scrollHeight, elementObject.scrollTop和elementObject.clientHeight的结合使用</h4>
<ul>
<li>实现判断滚动条是否已经滚动到底</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">// 当垂直滚动条滚动到底的时候有</span>
  elementObject.clientHeight == elementObject.scrollHeight - elementObject.scrollTop
</div></code></pre>
<h4 id="6264-elementobjectonmousewheel">6.2.6.4. elementObject.onmousewheel</h4>
<ul>
<li>鼠标在该元素对象中的滚轮触发该事件
<ul>
<li>火狐不兼容</li>
<li>在火狐中，需要使用DMMMouseScroll来绑定事件
<ul>
<li>必须使用addEventListener来进行绑定</li>
<li>可以使用bind函数来实现绑定</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  elementObject.onmousewheel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
  bind(elementObject,<span class="hljs-string">'DOMMouseScroll'</span>, elementObject.onmousewheel);
</div></code></pre>
<h3 id="38-%E6%96%87%E6%A1%A3%E7%9A%84%E5%8A%A0%E8%BD%BD">3.8. 文档的加载</h3>
<h4 id="381-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%A1%BA%E5%BA%8F">3.8.1 浏览器加载页面的顺序</h4>
<ul>
<li>浏览器加载页面时，是按照自上向下的顺序加载的，读取到一行就运行一行
<ul>
<li>js代码写到页面下面的原因就是为了可以在页面加载完毕以后再执行js代码</li>
</ul>
</li>
</ul>
<h4 id="382-onload%E4%BA%8B%E4%BB%B6">3.8.2 onload事件</h4>
<ul>
<li>一张图片或页面加载完成之后才执行</li>
<li>window.onload = function() {...}
<ul>
<li>页面加载完成之后才会执行对应的函数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    btn.onclick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> alert(<span class="hljs-string">"点击了一下"</span>);
  }
</div></code></pre>
<h1 id="%E5%85%AD-js%E7%9A%84bom%E6%93%8D%E4%BD%9C">六 js的BOM操作</h1>
<h2 id="61-bombrower-object-model">6.1. BOM(brower Object Model)</h2>
<ul>
<li>浏览器对象模型
<ul>
<li>BOM可以使我们通过js来操作浏览器</li>
</ul>
</li>
</ul>
<h2 id="62-bom%E7%9A%84%E5%AF%B9%E8%B1%A1">6.2. BOM的对象</h2>
<ul>
<li>在浏览器当中都是作为window的对象的属性保存的，可以直接使用window对象来使用，也可以直接使用</li>
</ul>
<h3 id="621-window">6.2.1. Window</h3>
<ul>
<li>代表的是整个浏览器的窗口，同时window也是网页的全局对象</li>
</ul>
<h4 id="6211-window%E6%96%B9%E6%B3%95">6.2.1.1. Window方法</h4>
<h5 id="62111-alertstr">6.2.1.1.1. alert(str)</h5>
<ul>
<li>弹出对话框，提示str内容</td></li>
</ul>
<h5 id="62112-promptstr">6.2.1.1.2. prompt(str)</h5>
<ul>
<li>弹出对话框，提示str内容要求输入，并返回输入值</li>
</ul>
<h5 id="62113-comfirmstr">6.2.1.1.3. comfirm(str)</h5>
<ul>
<li>弹出对话框，显示str内容，并有确认和取消按钮，返回布尔值</li>
</ul>
<h5 id="62114-setintervalcallback-time">6.2.1.1.4. setInterval(callback, time)</h5>
<ul>
<li>定时函数</li>
<li>将一个函数每隔一段时间调用一次,time单位是毫秒（多次）</li>
<li>返回一个Number数据定时器id，这个数字作为定时器的唯一标识（id）</li>
</ul>
<h5 id="62115-clearintervalintervalid">6.2.1.1.5. clearInterval(intervalId)</h5>
<ul>
<li>用来关闭intervalId的定时器</li>
<li>内部可以添加任何类型的值，若所添加的不是intervalId则什么也不做</li>
</ul>
<h5 id="62116-settimeoutcallback-time">6.2.1.1.6. setTimeout(callback, time)</h5>
<ul>
<li>延时调用一个函数不马上执行而是隔一段时间再执行，只能实行一次</li>
</ul>
<h5 id="62117-cleartimeouttimeoutid">6.2.1.1.7. clearTimeout(timeoutId)</h5>
<ul>
<li>关闭一个演延时调用函数</li>
</ul>
<h5 id="62118-%E5%BB%B6%E6%97%B6%E8%B0%83%E7%94%A8%E5%92%8C%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB">6.2.1.1.8. 延时调用和定时调用的关系</h5>
<ul>
<li>延时调用和定时调用之间是可以相互替代的</li>
</ul>
<h3 id="622-navigator">6.2.2. Navigator</h3>
<ul>
<li>代表的当前浏览器的信息，通过该对象可以用来识别不同的浏览器</li>
</ul>
<h4 id="6221-navigator%E7%9A%84%E5%B1%9E%E6%80%A7">6.2.2.1. Navigator的属性</h4>
<ul>
<li>由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器</li>
</ul>
<h5 id="72211-navigatoruseragent">7.2.2.1.1. navigator.userAgent</h5>
<ul>
<li>一般我们只会使用userAgent用来判断浏览器的信息</li>
<li>返回的是一个字符串，这个字符串中包含有用来秒速浏览器信息的内容，不同浏览器会有不同的userAgent</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 适用于判断大部分浏览器名称</span>
  <span class="hljs-keyword">const</span> ua = navigator.userAgent;
  <span class="hljs-comment">// i正则表达式忽略大小写</span>
  <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/firefox/i</span>.test(ua)) 
      alert(<span class="hljs-string">"我是火狐"</span>);
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/chrome/i</span>.test(ua))
      alert(<span class="hljs-string">"我是chrome"</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/msie/i</span>.test(ua))
      alert(<span class="hljs-string">"我是ie10及以下"</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"ActiveXObject"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) 
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"你是ie11"</span>)

  <span class="hljs-comment">// 如果无法通过UserAgent不能判断，可以通过一些浏览器中特有的对象来识别</span>
  <span class="hljs-comment">// 不如ActiveXobject</span>
  <span class="hljs-keyword">if</span>(<span class="hljs-string">"ActiveXObject"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) 
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"你是ie"</span>)
  <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"你不是ie"</span>)
</div></code></pre>
<h3 id="623-location">6.2.3. Location</h3>
<ul>
<li>代表当前浏览器的地址栏信息，通过locatino可以获取地址按信息或者操作浏览器跳转页面</li>
</ul>
<h4 id="6231-localtion">6.2.3.1. localtion</h4>
<ul>
<li>可以得到当前页面的完成路径
<ul>
<li>给location赋值，则可以实现跳转</li>
</ul>
</li>
</ul>
<h5 id="72311-location%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E4%BC%BCa%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7">7.2.3.1.1. location实现元素对象的类似a标签的属性</h5>
<ul>
<li>若给location赋值一个完整路径或者相对路径，则页面会自动跳转到该路径，并且生成了相应的历史记录</li>
</ul>
<h4 id="6232-location%E7%9A%84%E5%B1%9E%E6%80%A7">6.2.3.2. location的属性</h4>
<ul>
<li><img src="./img/location_attr.jpg" alt="属性">;</li>
</ul>
<h4 id="6233-location%E7%9A%84%E6%96%B9%E6%B3%95">6.2.3.3. Location的方法</h4>
<h5 id="62331-locationassignurl">6.2.3.3.1. location.assign(URL);</h5>
<ul>
<li>跳转到URL，和直接赋值的作用相同</li>
</ul>
<h5 id="62332-locationreload">6.2.3.3.2. location.reload();</h5>
<ul>
<li>刷新页面，和刷新页面的按钮作用相同，不清空缓存</li>
<li>location.reload(true)
<ul>
<li>强制清空缓存并刷新页面</li>
</ul>
</li>
</ul>
<h5 id="62333-locationreplaceurl">6.2.3.3.3. location.replace(URL)</h5>
<ul>
<li>跳转到URL。且不留下历史记录</li>
</ul>
<h3 id="624-history">6.2.4. History</h3>
<ul>
<li>代表浏览器的立是记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，只能操作浏览器向前或向后跳转，而且该操作只在当次访问时有效。</li>
<li>可以用来进行浏览器的向前向后翻页</li>
</ul>
<h4 id="6241-history%E7%9A%84%E5%B1%9E%E6%80%A7">6.2.4.1. History的属性</h4>
<h5 id="62411-historylength">6.2.4.1.1. history.length</h5>
<ul>
<li>获取到当次访问页面的数量（关闭窗口就重新计数）</li>
</ul>
<h4 id="6242-history%E7%9A%84%E6%96%B9%E6%B3%95">6.2.4.2. History的方法</h4>
<h5 id="62421-historyback">6.2.4.2.1. history.back()</h5>
<ul>
<li>可以用来回退到上一个页面，作用和浏览器的回退效果一样</li>
</ul>
<h5 id="62422-historyforward">6.2.4.2.2. history.forward()</h5>
<ul>
<li>可以用来前进到上一个页面，作用和浏览器的回退效果一样</li>
</ul>
<h5 id="62423-historygon">6.2.4.2.3. history.go(n)</h5>
<ul>
<li>可以用来跳转到指定的页面
<ul>
<li>n为正数，向前前进n个页面</li>
<li>n为负数，向后回退n个页面</li>
</ul>
</li>
</ul>
<h3 id="625-screen">6.2.5. Screen</h3>
<ul>
<li>代表用户的屏幕的信息，通过该对象可以获取到用户的显示器相关的信息</li>
</ul>
<h3 id="626-bom%E7%9A%84%E5%BA%94%E7%94%A8">6.2.6. Bom的应用</h3>
<h4 id="6261-%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2">6.2.6.1. 图片切换</h4>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">text-align</span>: center;
        }
        <span class="hljs-selector-class">.box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">background</span>: <span class="hljs-number">#eaeaea</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
        }
        <span class="hljs-selector-class">.box</span> <span class="hljs-selector-tag">img</span>{
            <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;

        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../img/ex1.JPG"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"图片"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"begin"</span>&gt;</span>开始图片的切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"end"</span>&gt;</span>终止图片的切换<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">const</span> imgUrl = [
                <span class="hljs-string">'../img/ex1.JPG'</span>,
                <span class="hljs-string">'../img/ex2.JPG'</span>,
                <span class="hljs-string">'../img/ex3.JPG'</span>,
                <span class="hljs-string">'../img/ex4.JPG'</span>,
                <span class="hljs-string">'../img/ex5.JPG'</span>,
                <span class="hljs-string">'../img/ex6.JPG'</span>,
                <span class="hljs-string">'../img/ex7.JPG'</span>,
                <span class="hljs-string">'../img/ex8.JPG'</span>
            ]
            <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imgChange</span>(<span class="hljs-params">img, imgUrl</span>) </span>{
                img.src = imgUrl[index];
                index = (index + <span class="hljs-number">1</span>) % imgUrl.length;
            }
            <span class="hljs-keyword">const</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.box img'</span>)
            <span class="hljs-keyword">let</span> id;
            <span class="hljs-keyword">const</span> btn1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'button.begin'</span>);
            btn1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                clearInterval(id);
                id = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                    imgChange(img, imgUrl);
                }, <span class="hljs-number">1000</span>);
                <span class="hljs-comment">// 点击多次之后会越来越快的原因：</span>
                <span class="hljs-comment">/*每点击一个按钮，就会添加一个定时器，所以会开很多个定时器，所以切换速度变快了*/</span>
                <span class="hljs-comment">// 无法停下来的原因：只能清除最后一个定时器</span>
                <span class="hljs-comment">// 解决方案：在同一个元素对象开启一个定时器之前先清除先前的定时器。</span>
            }
            <span class="hljs-keyword">const</span> btn2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'button.end'</span>);
            btn2.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                clearInterval(id);
            }
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h4 id="6262-%E8%A7%A3%E5%86%B3div%E7%A7%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%AE%E5%92%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E9%94%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E9%98%B2%E8%AF%AF%E8%A7%A6">6.2.6.2. 解决div移动第一个键和第二个键之间的延迟问题（防误触）</h4>
<ul>
<li>触发机制使用一个定时器函数用于减少按键的间隔</li>
<li>方向由事件决定，速度由定时器决定</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
            <span class="hljs-attribute">position</span>: absolute;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-keyword">let</span> curValue = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">let</span> step = <span class="hljs-number">5</span>;
        <span class="hljs-keyword">let</span> box = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.box'</span>);
        <span class="hljs-keyword">const</span> dir = {
                <span class="hljs-number">38</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>],
                <span class="hljs-number">39</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
                <span class="hljs-number">40</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
                <span class="hljs-number">37</span>: [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>]
            }
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Operation</span>(<span class="hljs-params">curValue</span>) </span>{
                <span class="hljs-keyword">if</span>(!dir[curValue])
                    <span class="hljs-keyword">return</span>;
                <span class="hljs-comment">// 上：38 右：39 下：40 左：37</span>
                box.style.left = box.offsetLeft + step*dir[curValue][<span class="hljs-number">0</span>] + <span class="hljs-string">'px'</span>;
                box.style.top = box.offsetTop + step*dir[curValue][<span class="hljs-number">1</span>] + <span class="hljs-string">'px'</span>;
                <span class="hljs-comment">// return 0;</span>
            }
            <span class="hljs-comment">// 触发机制使用一个定时器函数用于减少按键的间隔</span>
            <span class="hljs-comment">// 方向由事件决定，速度由定时器决定</span>
            setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
                Operation(curValue)
             }, <span class="hljs-number">30</span>)
            <span class="hljs-comment">// 不能用清除interval，再重新建立一个interval会造成延迟的过程</span>
            <span class="hljs-built_in">document</span>.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                event = event || <span class="hljs-built_in">window</span>.event
                <span class="hljs-keyword">if</span> (event.shiftKey &amp;&amp; event.keyCode === <span class="hljs-number">38</span>) {
                    step += <span class="hljs-number">5</span>;
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (event.shiftKey &amp;&amp; event.keyCode === <span class="hljs-number">40</span>) {
                    step = step &gt;= <span class="hljs-number">10</span> ? step - <span class="hljs-number">5</span> : <span class="hljs-number">5</span>;
                    <span class="hljs-keyword">return</span>;
                }  
                curValue = event.keyCode;
            }
            <span class="hljs-built_in">document</span>.onkeyup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                curValue = <span class="hljs-number">0</span>;
            }
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h4 id="6263-%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E7%94%BB%E5%87%BD%E6%95%B0">6.2.6.3. 构造一个简单的动画函数</h4>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box1</span> {
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0000</span>;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">40px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn1"</span>&gt;</span>点击往右走<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn2"</span>&gt;</span>点击往左走<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn3"</span>&gt;</span>点击往上走<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn4"</span>&gt;</span>点击往下走<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn5"</span>&gt;</span>增加宽度<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn6"</span>&gt;</span>增加高度<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"stop"</span>&gt;</span>暂停<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">/*
            * 作用：以字符串的形式返回元素对象对应的cssStyle
            * 参数：
            *       obj:元素对象
            *       cssStyle:string 要取得的样式
            * 返回：对象元素样式的字符串表示(:string)
            * 注意：对应的属性一定要进行初始化，不然会返回auto
            */</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">obj, cssStyle</span>) </span>{
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle)
                    <span class="hljs-keyword">return</span> getComputedStyle(obj, <span class="hljs-literal">null</span>)[cssStyle];
                <span class="hljs-keyword">else</span> <span class="hljs-comment">//IE8及以下没有getComputedStyle方法</span>
                    <span class="hljs-keyword">return</span> obj.currentStyle[cssStyle];
            }
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearObjectInterval</span>(<span class="hljs-params">obj</span>) </span>{
                clearInterval(obj.intervalId);
                obj.intervalId = <span class="hljs-literal">undefined</span>;
            }
            <span class="hljs-keyword">let</span> box1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.box1'</span>);
            <span class="hljs-keyword">let</span> btn1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn1'</span>);
            <span class="hljs-keyword">let</span> btn2 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn2'</span>);
            <span class="hljs-keyword">let</span> btn3= <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn3'</span>);
            <span class="hljs-keyword">let</span> btn4 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn4'</span>);
            <span class="hljs-keyword">let</span> btn5 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn5'</span>);
            <span class="hljs-keyword">let</span> btn6 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.btn6'</span>)
            <span class="hljs-keyword">let</span> btnStop = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.stop'</span>);

            <span class="hljs-comment">// let intervalId;</span>
            <span class="hljs-comment">// 利用在对象中单独定义一个intervalId，从而绑定对象的intervalId,从而可以进行复用</span>
            <span class="hljs-comment">// let speed = 10;</span>
            <span class="hljs-comment">/*
            *  可以执行简单动画的函数
            *  参数：
            *       obj: 要执行动画的对象
            *       speed: 运动的速度
            *       target:运动的终止目标   
            *       attr: 要执行运动的属性
            *       callback:动画执行完后调用的函数，可以利用该性质实现自动旋转等功能
            */</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoMove</span>(<span class="hljs-params">obj, speed, target, attr, callback=function(</span>)</span>{}) {
                <span class="hljs-comment">// 清除定时器</span>
                clearInterval(obj.intervalId)

                <span class="hljs-keyword">if</span>(attr === <span class="hljs-string">'left'</span> || attr === <span class="hljs-string">'right'</span>) {
                    <span class="hljs-keyword">if</span>(attr === <span class="hljs-string">'left'</span>) 
                        speed = -speed;
                    attr = <span class="hljs-string">'left'</span>;
                }
                <span class="hljs-keyword">if</span>(attr === <span class="hljs-string">'top'</span> || attr === <span class="hljs-string">'buttom'</span>) {
                    <span class="hljs-keyword">if</span>(attr === <span class="hljs-string">'top'</span>) 
                        speed = -speed;
                    attr = <span class="hljs-string">'top'</span>;
                }
                <span class="hljs-comment">// 定义定时器</span>
                obj.intervalId = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">let</span> currentPositon = <span class="hljs-built_in">parseInt</span>(getStyle(obj, attr));
                    <span class="hljs-keyword">let</span> nextPosition = currentPositon + speed;
                    obj.style[attr] = speed &lt; <span class="hljs-number">0</span> ? nextPosition &lt; target ? target + <span class="hljs-string">'px'</span>: nextPosition + <span class="hljs-string">'px'</span>
                                                         : nextPosition &gt; target ? target + <span class="hljs-string">'px'</span>: nextPosition + <span class="hljs-string">'px'</span>;
                    <span class="hljs-keyword">if</span>(nextPosition === target) {
                        clearObjectInterval(obj)
                        callback();
                    }
                }, <span class="hljs-number">30</span>)
                
                
            }
            btn1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                autoMove(box1, <span class="hljs-number">10</span>, <span class="hljs-number">800</span>, <span class="hljs-string">'right'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{alert(<span class="hljs-string">"到底了"</span>)});
            }
            btn2.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                autoMove(box1, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'left'</span>);
            }
            btn3.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                autoMove(box1, <span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-string">'top'</span>);
            }
            btn4.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                autoMove(box1, <span class="hljs-number">10</span>, <span class="hljs-number">800</span>, <span class="hljs-string">'buttom'</span>);
            }
            btn5.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                autoMove(box1, <span class="hljs-number">10</span>, <span class="hljs-number">800</span>, <span class="hljs-string">'width'</span>);
            }
            btn6.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                autoMove(box1, <span class="hljs-number">10</span>, <span class="hljs-number">800</span>, <span class="hljs-string">'height'</span>);
            }
            
            btnStop.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                clearObjectInterval(box1);
            }
            
            <span class="hljs-comment">// btn1.onclick = function() {</span>
            <span class="hljs-comment">//     // 关闭先前的定时器</span>
            <span class="hljs-comment">//     clearInterval(intervalId);</span>
            <span class="hljs-comment">//     // 打开新的定时器</span>
            <span class="hljs-comment">//     intervalId =  setInterval(function() {</span>
            <span class="hljs-comment">//         // 若直接使用offsetLeft, offsetTop无法和所要接收的style形成一一对应的关系，所以可以使用getStlye()的方法得到对应的样式</span>
            <span class="hljs-comment">//         let currentPosition = parseInt(getStyle(box1, 'left'));</span>
            <span class="hljs-comment">//         let nextPosition = currentPosition + speed;</span>
            <span class="hljs-comment">//         // box终止的位置</span>
            <span class="hljs-comment">//         if(nextPosition &gt; 800)</span>
            <span class="hljs-comment">//             nextPosition = 800;</span>
            <span class="hljs-comment">//         box1.style.left = nextPosition + 'px';</span>
            <span class="hljs-comment">//     }, 30)</span>
            <span class="hljs-comment">// }</span>
            <span class="hljs-comment">// btn2.onclick = function() {</span>
            <span class="hljs-comment">//      // 关闭先前的定时器</span>
            <span class="hljs-comment">//     clearInterval(intervalId);</span>
            <span class="hljs-comment">//     // 打开新的定时器</span>
            <span class="hljs-comment">//     intervalId = setInterval(function() {</span>
            <span class="hljs-comment">//         // 若直接使用offsetLeft, offsetTop无法和所要接收的style形成一一对应的关系，所以可以使用getStlye()的方法得到对应的样式</span>
            <span class="hljs-comment">//         let currentPosition = parseInt(getStyle(box1, 'left'));</span>
            <span class="hljs-comment">//         let nextPosition = currentPosition +(-speed) ;</span>
            <span class="hljs-comment">//         // box终止的位置</span>
            <span class="hljs-comment">//         if(nextPosition &lt; 0)</span>
            <span class="hljs-comment">//             nextPosition = 0;</span>
            <span class="hljs-comment">//         box1.style.left = nextPosition + 'px';</span>
            <span class="hljs-comment">//     }, 30)</span>
            <span class="hljs-comment">// }</span>
            <span class="hljs-comment">// 重复的部分有点多，可以提取成一个对象或者函数，注意到函数的共用变量intervalId，可以作为返回值</span>
            
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h4 id="6264-%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0">6.2.6.4. 轮播图效果的实现</h4>
<ul>
<li>原理
<ul>
<li><img src="./img/ex17.jpg" alt="原理"></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div></div></code></pre>
<h1 id="%E4%B8%83-js%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8">七 js的迭代器</h1>
<h1 id="%E5%85%AB-promise">八 Promise</h1>
<h2 id="1-promised%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3">1 Promised的基本理解</h2>
<h3 id="11-promise%E7%9A%84%E7%90%86%E8%A7%A3">1.1 promise的理解</h3>
<ul>
<li>通常情况下, 要实现异步调用的返回, 必须判断异步调用有没有执行结束, 然后通过callback函数来获取数据</li>
<li>抽象表达
<ul>
<li>Promise是js中进行异步调用的解决办法</li>
</ul>
</li>
<li>具体表达
<ul>
<li>从语法上来说:Promise是一个构造函数</li>
<li>从功能上来说:Promse对象用于封装一个异步操作的方法并可以获取其结果</li>
</ul>
</li>
</ul>
<h3 id="12-promise%E7%9A%84%E7%8A%B6%E6%80%81">1.2 promise的状态</h3>
<ul>
<li>pending
<ul>
<li>未确定状态</li>
</ul>
</li>
<li>fulfilled
<ul>
<li>完成状态
<ul>
<li>当调用了resolved函数, 就会从pending -&gt; fulfilled转化</li>
</ul>
</li>
</ul>
</li>
<li>rejected
<ul>
<li>拒绝状态
<ul>
<li>当调用了rejected函数, 就会从pending-&gt; rejected转化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B">1.3. promise的基本使用流程</h3>
<ul>
<li><img src="./img/ex1_promise.jpg" alt="理解"></li>
</ul>
<h3 id="14-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8promise">1.4. 为什么使用promise</h3>
<h4 id="141-%E6%8C%87%E5%AE%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9B%B4%E5%8A%A0%E7%81%B5%E6%B4%BB">1.4.1 指定回调函数的方式更加灵活</h4>
<ul>
<li>传统的回调函数的定义必须在异步任务之前</li>
<li>promise回调函数的定义可以在程序的任意位置
<ul>
<li>promise =&gt; 启动异步而任务, 返回promise对象 =&gt; 给promise对象绑定回调函数</li>
<li>甚至在异步任务完成之后的任意时刻都进行回调.</li>
</ul>
</li>
</ul>
<h4 id="142-%E6%94%AF%E6%8C%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E9%97%AE%E9%A2%98">1.4.2 支持链式调用,可以解决回调地狱的问题</h4>
<h5 id="1421-%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1">1.4.2.1 回调地狱</h5>
<ul>
<li>回调函数的嵌套调用,外部回调函数异步执行的结果是嵌套的回调函数的前提
<ul>
<li>难以阅读而且很难找到错误</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 涉及到多个异步操作, 而且异步操作是串联执行</span>
<span class="hljs-comment">// 串联执行: 下一个异步任务是以前面的异步任务的结果作为条件调用的</span>
    doFirstSomething(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">firstResult, failCallBack</span>) </span>{
        doSecondSomething(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">secondResult, failCallBack</span>)</span>{
            doThirdSomething(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thirdResult, failCallBack</span>) </span>{
                <span class="hljs-built_in">console</span>.log(thirdResult)
            })
        })
    })
</div></code></pre>
<h5 id="1422-%E5%88%A9%E7%94%A8promise%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E9%97%AE%E9%A2%98">1.4.2.2 利用Promise的链式调用解决回调地狱的问题</h5>
<pre class="hljs"><code><div>    doFirstSomething().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">firstResult</span>) </span>{
        <span class="hljs-keyword">return</span> doSecondSomething()
        <span class="hljs-comment">// 必须返回一个promise类型</span>
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">secondResult</span>) </span>{
        <span class="hljs-keyword">return</span> doThirdSomething()
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thirdResult</span>) </span>{
        <span class="hljs-built_in">console</span>.log(thirdResult);
    })
    .catch(failCallBack)
</div></code></pre>
<h5 id="1423-%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E6%9C%80%E7%BB%88%E6%96%B9%E6%A1%88">1.4.2.3 解决回调地狱的最终方案</h5>
<ul>
<li>使用async和await</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> firstResult = <span class="hljs-keyword">await</span> doFirstSomething();
            <span class="hljs-keyword">const</span> secondResult = <span class="hljs-keyword">await</span> doSecondSomething(firstResult);
            <span class="hljs-keyword">const</span> thirdResult = <span class="hljs-keyword">await</span> doThirdSomething(secondResult);
            <span class="hljs-built_in">console</span>.log(thirdResult);
        }
        <span class="hljs-keyword">catch</span> {
            failCallBack();
        }

    }
</div></code></pre>
<h3 id="15-promise%E7%9A%84api">1.5 promise的API</h3>
<ul>
<li>语法和前后端交互的方法</li>
<li>(prototype)函数原型对象上的方法只能由实例对象进行调用
<ul>
<li>因为有原型链</li>
</ul>
</li>
</ul>
<h4 id="51-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1 基本语法</h4>
<pre class="hljs"><code><div>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{...}<span class="hljs-comment">/*executor*/</span>)
</div></code></pre>
<ul>
<li>executor是带有 resolve 和 reject 两个参数的函数</li>
<li>Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor</li>
<li>executor函数在<font color='red'>Promise构造函数返回所建promise实例对象前</font>被调用</li>
</ul>
<h4 id="52-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">5.2 函数对象的方法</h4>
<h5 id="521-promisealliterable">5.2.1 Promise.all(iterable))</h5>
<ul>
<li>作用: 用于将多个pending状态的promise实例对象的结果统一起来</li>
<li>返回一个Promise实例
<ul>
<li>如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的Promise</li>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved）</li>
<li>如果有一个promise的运行最终状态是非fullfilled, 则会回调reject的结果</li>
</ul>
</li>
<li>参数
<ul>
<li>iterable
<ul>
<li>以数组的形式, items为一般为多个处于pending状态的promise的实例对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> promise1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  setTimeout(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">'foo'</span>);
});

<span class="hljs-built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(values);
});
<span class="hljs-comment">// expected output: Array [3, 42, "foo"]</span>
</div></code></pre>
<h5 id="522-promiseraceiterable">5.2.2 Promise.race(iterable)</h5>
<ul>
<li>作用: 用于将多个pending状态promise实例进行竞争,只是取第一个执行成功的值</li>
<li>返回一个promise对象</li>
<li>参数
<ul>
<li>iterable
<ul>
<li>以数组的形式, items为一般为多个处于pending状态的promise的实例对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="523-promiseresolvevalue">5.2.3 Promise.resolve(value)</h5>
<ul>
<li>作用:产生一个成功值为value的promise</li>
<li>返回一个以给定值解析后的Promise实例对象</li>
<li>参数
<ul>
<li>value</li>
<li>将被Promise对象解析的参数也
<ul>
<li>可以是一个Promise对象</li>
<li>是一个thenable。
<ul>
<li>即将被传入then方法中的参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-comment">// 产生一个成功值为2的promise</span>
    <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        resolve(<span class="hljs-number">2</span>)
    })
    <span class="hljs-comment">// 实际上可以看作是语法糖</span>
    <span class="hljs-keyword">const</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)
</div></code></pre>
<h5 id="524-promiserejectreason">5.2.4 Promise.reject(reason)</h5>
<ul>
<li>返回一个失败的promise的实例对象</li>
</ul>
<h4 id="53-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">5.3 实例对象的方法</h4>
<ul>
<li>函数原型对象的方法只能由实例对象进行调用</li>
</ul>
<h5 id="531-promiseprototypethenonfulfilled-onrejected">5.3.1 Promise.prototype.then(onFulfilled[, onRejected])</h5>
<ul>
<li>作用: 当函数处于fulfilled状态时调用的函数, 指定一个异步调用的回调函数</li>
<li></li>
<li>返回一个新的promise</li>
<li>参数
<ul>
<li>onResolved函数: 成功的回调函数 (value) =&gt; {}</li>
<li>onRejected函数: 失败的回调函数 (reason) =&gt; {}</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>primiseObject.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
  <span class="hljs-comment">// fulfillment</span>
}, reason =&gt; {
  <span class="hljs-comment">// rejection</span>
});
</div></code></pre>
<h5 id="532-promiseprototypecatchonrejected">5.3.2 Promise.prototype.catch(onRejected)</h5>
<ul>
<li>相当于then的语法糖, 相当于then(undefined, onRejected)</li>
<li>返回一个新的promise对象</li>
<li>参数
<ul>
<li>onRejected函数: 失败的回调函数 (reason) =&gt; {}</li>
</ul>
</li>
</ul>
<h3 id="16-promise%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98">1.6 promise的几个关键问题</h3>
<h4 id="161-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98promise%E7%9A%84%E7%8A%B6%E6%80%81">1.6.1 如何改变promise的状态</h4>
<ul>
<li>resolve(value): 如果当前是pending状态=&gt;fulfilled状态</li>
<li>reject(reason): 如果当前是pending状态=&gt;rejected状态</li>
<li>抛出异常: 如果当前是pending状态=&gt;rejected状态</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejected</span>) =&gt;</span>{
        <span class="hljs-comment">//resolve(1) //promise变为fulfilled状态</span>
        <span class="hljs-comment">//reject(2) // promise变为rejected的状态</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"出错了"</span>) <span class="hljs-comment">//promise变为rejected的状态, reason为Error</span>
    })
</div></code></pre>
<h4 id="162-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E6%95%B0%E6%8D%AE">1.6.2 什么时候可以得到数据?</h4>
<ul>
<li>指定回调函数且promise的状态为fulfilled时,会异步调用回调函数</li>
<li>一般情况
<ul>
<li>先指定回调函数, 再改变状态</li>
</ul>
</li>
<li>特殊情况
<ul>
<li>先改变状态,再指定回调函数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-number">2</span>);
        }, <span class="hljs-number">1000</span>)
    })
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(value);
        })
    }, <span class="hljs-number">2000</span>)
</div></code></pre>
<h4 id="163-%E7%90%86%E8%A7%A3promise%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5">1.6.3 理解promise中的同步异步</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// 同步: new Promise内部的函数, setTimeout函数, then函数</span>
<span class="hljs-comment">// 异步: setTimeout的回调函数, then的回调函数</span>
<span class="hljs-comment">// 异步是要放入一个队列待执行的</span>
    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            resolve(<span class="hljs-number">1</span>)
        }, <span class="hljs-number">1000</span>)
    }).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(value);
    })
</div></code></pre>
<h4 id="164-promisethen%E8%BF%94%E5%9B%9E%E6%96%B0%E7%9A%84promise%E7%9A%84%E7%BB%93%E6%9E%9C%E7%8A%B6%E6%80%81%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E7%9A%84">1.6.4 promise.then()返回新的promise的结果状态由什么决定的</h4>
<ul>
<li>由then指定的回调函数的返回结果决定
<ul>
<li>如果抛出异常,新promise会变为rejected, reason为抛出的异常</li>
<li>如果返回的是非promise的任意值, 新的promise变为resolved, value为返回的值(包括没有返回值的undefined)</li>
<li>如果返回的是另一个新的promise, 此promise的状态结果即为返回的状态</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        resolve(<span class="hljs-number">2</span>);
    })
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-comment">// return 2;                   //fulfilled</span>
        <span class="hljs-comment">// return Promise.resolve(3);  //fulfilled</span>
        <span class="hljs-comment">// return Promise.reject(2)    //rejected</span>
        <span class="hljs-comment">// throw 5  //rejected</span>
    })
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(value)
    })
</div></code></pre>
<h4 id="165-promise%E5%A6%82%E4%BD%95%E4%B8%B2%E8%81%94%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">1.6.5 promise如何串联多个异步任务</h4>
<ul>
<li>promise的then()返回一个新的promise, 可以看成then()的链式调用</li>
<li>通过then的链式调用串联多个同步/异步任务</li>
</ul>
<h4 id="166-promise%E7%9A%84%E5%BC%82%E5%B8%B8%E7%A9%BF%E9%80%8F">1.6.6 promise的异常穿透</h4>
<ul>
<li>当使用promise的链式调用时,可以在最后指定失败的回调</li>
<li>前面任何操作出了异常,都会传到最后是吧的回调中进行处理
<ul>
<li>实际上.catch管理的并不是new的对象,而是通过then创建的一个个新对象,所以有穿透的概念</li>
</ul>
</li>
<li>定义方法:
<ul>
<li>所有的OnRejected的回调函数都是throw reason</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>     <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        resolve(<span class="hljs-number">2</span>);
    })
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-comment">// return 2;                   //fulfilled</span>
        <span class="hljs-comment">// return Promise.resolve(3);  //fulfilled</span>
        <span class="hljs-comment">// return Promise.reject(2)    //rejected</span>
        <span class="hljs-comment">// throw 5  //rejected</span>
    }, reason =&gt; <span class="hljs-keyword">throw</span> reason)
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(value)
    }, reason =&gt; <span class="hljs-keyword">throw</span> reason)
    .catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(reason)
    })
</div></code></pre>
<h4 id="167-%E4%B8%AD%E6%96%ADpromise%E9%93%BE">1.6.7 中断promise链</h4>
<ul>
<li>当使用promise的链式调用时, 在中间中断,不再调用后面的回调函数</li>
<li>办法: 在回调函数的后面返回一个pending状态的promise对象
<ul>
<li>return new Promise((resolve, reject) =&gt; {})</li>
</ul>
</li>
</ul>
<h2 id="2-%E6%89%8B%E5%86%99promise">2 手写promise</h2>
<h3 id="21-%E5%AE%9A%E4%B9%89%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84">2.1 定义整体结构</h3>
<ul>
<li>要注意哪些是Promise的函数，哪些是Promise.prototype函数</li>
</ul>
<h3 id="22-%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">2.2. 定义构造函数</h3>
<ul>
<li>Promise构造函数的基本变量
<ul>
<li>this.status
<ul>
<li>表示promise状态</li>
<li>默认值是&quot;pending&quot;</li>
</ul>
</li>
<li>this.data
<ul>
<li>undefined</li>
<li>存储resolve， reject传进来的数据</li>
</ul>
</li>
<li>this.callbacks
<ul>
<li>存储异步调用时的回调函数</li>
<li>item是object</li>
</ul>
</li>
</ul>
</li>
<li>返回新promise的过程</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    ...
  })
</div></code></pre>
<ul>
<li>excutor为在类的构造中需要调用的函数，所以在构造函数中需要执行excutor
<ul>
<li>由传入的参数知，其接收两个函数形式的参数</li>
</ul>
</li>
<li>这两个函数形式的参数的实参为Promise中已经定义好的函数
<ul>
<li>两个函数在类内部定义，在类外部被调用</li>
</ul>
</li>
<li>resolve/reject执行的过程
<ul>
<li>改变promise的状态</li>
<li>将data赋给类中的data</li>
<li>异步执行指定的回调函数
<ul>
<li>由于是异步执行，肯定会在同步执行后再执行</li>
</ul>
</li>
<li>注意
<ul>
<li>在类中定义这两个函数式this的指向
<ul>
<li>因为是在外部调用的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// ES5中定义模块</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">window</span>) </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">excutor</span>) </span>{
        <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>;
        <span class="hljs-keyword">this</span>.data = <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">this</span>.callbacks = [];
        <span class="hljs-comment">// 由于resolve是在外调用的,所以this对象是window</span>
        <span class="hljs-comment">// 利用一个that来使其指向对象</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>{
            <span class="hljs-comment">// 如果当前状态不是pending, 直接结束</span>
            <span class="hljs-keyword">if</span>(that.status !== <span class="hljs-string">'pending'</span>) 
                <span class="hljs-keyword">return</span>;   
            <span class="hljs-comment">// 将状态改为resolved</span>
            that.status = <span class="hljs-string">'fulfilled'</span>
            <span class="hljs-comment">// 保存value数据</span>
            that.data = value;
            <span class="hljs-comment">// 如果有待执行callback函数, 立即异步执行回调函数'</span>
            <span class="hljs-comment">// 为了放入异步执行的队列,使用setTimeout</span>
            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                <span class="hljs-keyword">if</span>(that.callbacks.length &gt; <span class="hljs-number">0</span>) {
                    that.callbacks.forEach(<span class="hljs-function"><span class="hljs-params">callbackObj</span> =&gt;</span> {
                        callbackObj.onResolved(that.data);
                    })
                }
                    
            }) 
        }
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>{
             <span class="hljs-comment">// 如果当前状态不是pending, 直接结束</span>
            <span class="hljs-keyword">if</span>(that.status !== <span class="hljs-string">'pending'</span>)
                <span class="hljs-keyword">return</span>;
            that.status = <span class="hljs-string">'rejected'</span>;

            that.data = reason;

            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                that.callbacks.forEach(<span class="hljs-function"><span class="hljs-params">callbackObj</span> =&gt;</span> {
                    callbackObj.onRejected(that.data);
                })
            }) 
        }
        <span class="hljs-comment">// 立即执行excutor</span>
        <span class="hljs-comment">// 抛出异常,利用catch捕获异常</span>
        <span class="hljs-comment">// 由于传进来的excutor是一个函数, 所以直接调用即可</span>
        <span class="hljs-keyword">try</span> {
            excutor(resolve, reject);
        }
        <span class="hljs-keyword">catch</span>(error) {
            reject(error)
        }
        

    }

    <span class="hljs-comment">// 返回一个成功的指定结果promise </span>
    MyPromise.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> MyPromise) {
                <span class="hljs-comment">// 当是MyPromsie的类型时，根据promise的结果来确定当前新的promise的状态</span>
                value.then(resolve, reject);
            }
            <span class="hljs-keyword">else</span> {
                resolve(value)
            }
        })
    }
    <span class="hljs-comment">// 返回一个失败的指定结果promise</span>
    MyPromise.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            reject(reason)
        })
    }
    <span class="hljs-comment">// 只有当所有的promise都成功时才成功</span>
    MyPromise.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>{
        <span class="hljs-keyword">const</span> values = []; <span class="hljs-comment">//用于存放成功的value值</span>
        <span class="hljs-keyword">let</span> resolveCount = <span class="hljs-number">0</span>;  <span class="hljs-comment">//用于判断成功异步调用resolve的次数，当次数达到和promises相同时，就是全部成功</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            promises.forEach(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> {
                <span class="hljs-comment">// 将非promise的转化为promise</span>
                MyPromise.resolve(promise).then(
                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
                        resolveCount ++;
                        values[index] = value;
                        <span class="hljs-keyword">if</span>(resolveCount == promises.length)
                            resolve(values);
                    },
                    reason =&gt; {
                        reject(reason);
                        <span class="hljs-comment">// reject可以被调用多次，但是前面在reject中不是pending直接结束</span>
                        <span class="hljs-comment">// 所以只是第一次调用</span>
                    }
                )
            })
        })
    };
    <span class="hljs-comment">// 由第一个promise完成时决定</span>
    MyPromise.race = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            promises.forEach(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> {
                MyPromise.resolve(promise).then(
                    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
                        resolve(value);
                    },
                    reason =&gt; {
                            reject(reason);
                    }
                )
            })
        })
    };

    <span class="hljs-comment">// Promise原型对象的then()</span>
    <span class="hljs-comment">// 指定成功和失败的回调函数, 返回一个新的promise对象</span>
    MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>{
        <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">"function"</span>)
            onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;
        <span class="hljs-comment">// 解决异常穿透的问题</span>
        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">"function"</span>)
            onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {<span class="hljs-keyword">throw</span> reason}
        <span class="hljs-comment">// 返回一个新的promise且promise由回调函数的执行结果确定</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">callback</span>) </span>{
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-keyword">const</span> result = callback(that.data);
                    <span class="hljs-keyword">if</span>(result <span class="hljs-keyword">instanceof</span> MyPromise) {
                        <span class="hljs-comment">// 实际上是直接执行了return的promise的值传递给新的promise的reject和resolve</span>
                        result.then(
                            <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> resolve(value),
                            reason =&gt; reject(reason)
                        )
                        <span class="hljs-comment">// result.then(resolve, reject)</span>
                        <span class="hljs-comment">// 可以写成简洁版的原因，resolve在内部调用，传入的只是该函数的定义，而该函数就是promise内部已经定义的函数</span>
                        <span class="hljs-comment">// 里面的that指向的是当前的promise</span>
                        
                    }
                    <span class="hljs-comment">// 利用.then取出其结果</span>
                    <span class="hljs-keyword">else</span> {
                        resolve(result)
                    }
                }
                <span class="hljs-keyword">catch</span>(error) {
                    reject(error)
                }
            }
            <span class="hljs-comment">// 假设当前状态还是pending状态,则加入回调函数</span>
            <span class="hljs-keyword">if</span>(that.status === <span class="hljs-string">"pending"</span>) {
                that.callbacks.push({
                    onResolved(value) {
                        handler(onResolved)
                    },
                    onRejected(value) {
                        handler(onRejected)
                    }
                })
            }
            <span class="hljs-comment">// 假设当前状态是"fulfilled", 则异步执行回调函数</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(that.status === <span class="hljs-string">"fulfilled"</span>) {  
                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                     <span class="hljs-comment">// 决定返回promise的状态</span>
                    <span class="hljs-comment">//  1 onResolved抛出错误：</span>
                    <span class="hljs-comment">//  2 onResolved返回一个非promise的值</span>
                    <span class="hljs-comment">//  3 onResolved返回一个promise对象</span>
                    <span class="hljs-comment">//         - 需要promise异步调用完后再得到相应的结果</span>
                    handler(onResolved)
                })
            }
            <span class="hljs-keyword">else</span> {
                setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                    handler(onRejected);
                })
            }
        })
        
        
    };

    <span class="hljs-comment">// Promise原型对象的catch()</span>
    <span class="hljs-comment">// 指定失败的回调函数, 返回一个新的promise对象</span>
    MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">undefined</span>, onRejected)
    };


    <span class="hljs-comment">// 向外暴露Promise函数</span>
    <span class="hljs-built_in">window</span>.MyPromise = MyPromise;
})(<span class="hljs-built_in">window</span>)

</div></code></pre>
<h2 id="3-async%E5%92%8Cawait%E4%BD%BF%E7%94%A8">3 async和await使用</h2>
<h3 id="31-async-%E5%87%BD%E6%95%B0">3.1 async 函数</h3>
<ul>
<li>async函数的返回值是一个新的promise对象</li>
<li>async函数返回的promise的结果由函数执行的结果决定</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  }
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-number">2</span>;
  }
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)
}
fn().then(
    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onResolved1: "</span> + value),
    reason =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onRejected1: "</span> + reason)
)
fn2().then(
    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onResolved2: "</span> + value),
    reason =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onRejected2: "</span> + reason)
)
fn3().then(
    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onResolved3: "</span> + value),
    reason =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onRejected3: "</span> + reason)
)
<span class="hljs-comment">/*
  输出结果
  onResolved1: 1
  onRejected2: 2
  onRejected3: 3
*/</span>
</div></code></pre>
<h3 id="32-await-%E8%A1%A8%E8%BE%BE%E5%BC%8F">3.2 await 表达式</h3>
<ul>
<li>表达式
<ul>
<li>若是promise
<ul>
<li>取得promise对象的value值(即成功的结果)</li>
<li>若想得到失败的结果,只能使用try, catch</li>
</ul>
</li>
<li>若不是promise
<ul>
<li>则取得表达式中本身的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> value = fn3()
    }
    <span class="hljs-keyword">catch</span>(error) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"发生异常:"</span> + error)
    }
  }
test();
<span class="hljs-comment">// 发生异常:3</span>
</div></code></pre>
<h3 id="33-%E6%B3%A8%E6%84%8F">3.3 注意</h3>
<ul>
<li>await必须写在async函数中,但async函数中可以没有awit</li>
<li>如果await的promise失败,会抛出异常,需要通过try...catch进行捕获</li>
</ul>
<h2 id="4-%E5%AE%8F%E9%98%9F%E5%88%97%E5%92%8C%E5%BE%AE%E9%98%9F%E5%88%97">4 宏队列和微队列</h2>
<h3 id="41-%E5%8E%9F%E7%90%86%E5%9B%BE">4.1 原理图</h3>
<ul>
<li><img src="./img/ex2_promise.jpg" alt="图"></li>
<li>JS中用来存储待执行的回调函数的队列包裹2个不同特定的队列
<ul>
<li>宏队列
<ul>
<li>用来保存代执行的宏任务
<ul>
<li>定时器回调函数, DOM事件的回调函数</li>
</ul>
</li>
</ul>
</li>
<li>微队列
<ul>
<li>用来保存待执行的微任务
<ul>
<li>promise的回调函数/MutationObserver回调函数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="42-js%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%A7%A6%E5%8F%91%E5%87%BD%E6%95%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%94%BE%E5%85%A5%E4%BA%86%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97">4.2 js的异步任务的触发函数什么时候放入了对应的异步执行队列？</h3>
<ul>
<li>当异步调用触发时，会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM）完成时，然后事件触发线程将异步对应的回调函数 加入到消息队列中，回调函数在响应的消息队列中的等待被执行。</li>
</ul>
<h3 id="43-js%E7%9A%84%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">4.3 js的异步执行流程</h3>
<ul>
<li>JS引擎首先必须先执行所有的初始化同步任务代码</li>
<li>每次准备取出第一个宏任务前,都要将所有的微任务一个一个取出执行</li>
</ul>
<pre class="hljs"><code><div>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {     <span class="hljs-comment">//会放入宏队列</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"timeout callback1()"</span>);
    <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>).then(    <span class="hljs-comment">//会放入微队列</span>
        <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Promise onResolved3() "</span> + value);
        }
    )
}, <span class="hljs-number">0</span>)
 
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">//会放入宏队列</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"timeout callback2()"</span>);
}, <span class="hljs-number">0</span>)

<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then( <span class="hljs-comment">//会放入微队列</span>
    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Promise onResolved1() "</span> + value);
    }
)

<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>).then( <span class="hljs-comment">//会放入微队列</span>
    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Promise onResolved2() "</span> + value);
    }
)

<span class="hljs-comment">/** 输出结果
 * Promise onResolved1() 1
 * Promise onResolved2() 2
 * timeout callback1()
 * Promise onResolved3() 3
 * timeout callback2()
 * /
</span></div></code></pre>
<h2 id="5-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">5 常见面试题</h2>
<h3 id="51-%E8%AE%A4%E6%B8%85%E6%A5%9A%E5%93%AA%E4%BA%9B%E6%98%AF%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%93%AA%E4%BA%9B%E6%98%AF%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81">5.1 认清楚哪些是异步回调函数,哪些是同步代码</h3>
<pre class="hljs"><code><div>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">//同步代码</span>
    resolve()
  }).then(
    <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>); <span class="hljs-comment">//异步回调函数,且插入微队列</span>
    }
  )
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>{        
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 start'</span>);
  <span class="hljs-keyword">await</span> async2(); 
  <span class="hljs-comment">/*
  相当于
  async2().then(
    value =&gt; {
      console.log(async1 end)
    }
  )
  */</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 end'</span>);
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async2'</span>); 
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>); 
setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>);
}, <span class="hljs-number">0</span>);  
async1();
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>);
    resolve();
  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>);
});
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>);

<span class="hljs-comment">/**
  [setTimeout]
  [promise2]
  script start
  async1 start
  async2
  async1 end
  promise1
  script end 
  promise2
  setTimeout
*/</span>
</div></code></pre>
<h1 id="%E4%B9%9D-axios">九 axios</h1>
<h2 id="1-http%E7%9A%84%E7%90%86%E8%A7%A3">1 http的理解</h2>
<h3 id="11-http%E8%AF%B7%E6%B1%82%E4%BA%A4%E4%BA%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B">1.1 http请求交互的基本过程</h3>
<ul>
<li><img src="./img/axios_ex1.jpg" alt="理解"></li>
</ul>
<h3 id="12-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">1.2 http请求报文</h3>
<ul>
<li><img src="./img/http_request.jpg" alt="请求报文"></li>
</ul>
<h4 id="121-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90">1.2.1 请求报文的组成</h4>
<h5 id="1211-%E8%AF%B7%E6%B1%82%E8%A1%8C">1.2.1.1 请求行</h5>
<h6 id="11111-method%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">1.1.1.1.1 method(请求方法)</h6>
<ul>
<li>控制服务器端的增删改查
<ul>
<li>GET: 请求指定的页面信息，并返回实体主题 --服务端数据查询</li>
<li>POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 --服务端数据的修改/增加</li>
<li>DELETE：请求服务器删除Request-URL所标识的资源 --服务端数据的删除</li>
<li>PUT：向指定资源位置上传其最新内容 --服务端数据的增加</li>
</ul>
</li>
<li>其他
<ul>
<li>HEAD: 向服务器索与GET请求相一致的响应，只不过响应体将不会被返回</li>
<li>TRACE: 回显服务器收到的请求，主要用于测试或诊断</li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
</ul>
</li>
</ul>
<h6 id="11112-url">1.1.1.1.2 URL</h6>
<h6 id="11113-%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC">1.1.1.1.3 协议版本</h6>
<ul>
<li>http的版本类型</li>
</ul>
<h5 id="1212-%E8%AF%B7%E6%B1%82%E5%A4%B4">1.2.1.2 请求头</h5>
<ul>
<li>请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号&quot;:&quot;分隔</li>
</ul>
<h6 id="12121-user-agent">1.2.1.2.1 User-Agent</h6>
<ul>
<li>产生浏览器类型</li>
</ul>
<h6 id="12122-accipt">1.2.1.2.2 Accipt</h6>
<ul>
<li>客户端可识别的相应内容类型列表</li>
</ul>
<h6 id="12123-accept-language">1.2.1.2.3 Accept-Language</h6>
<ul>
<li>客户端可接收的语言类型</li>
</ul>
<h6 id="12124-accept-encoding">1.2.1.2.4 Accept-Encoding</h6>
<ul>
<li>客户端可接受的编码压缩格式</li>
</ul>
<h6 id="12125-accept-charset">1.2.1.2.5 Accept-Charset</h6>
<ul>
<li>客户端可接受的应答的字符集</li>
</ul>
<h6 id="12126-host">1.2.1.2.6 Host</h6>
<ul>
<li>请求主机名，允许多个域名同处一个IP，即虚拟主机</li>
</ul>
<h6 id="12127-connection">1.2.1.2.7 connection</h6>
<ul>
<li>连接方式
<ul>
<li>close</li>
<li>keepalive</li>
</ul>
</li>
</ul>
<h6 id="12128-cookie">1.2.1.2.8 Cookie</h6>
<ul>
<li>存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie</li>
</ul>
<h5 id="1213-%E7%A9%BA%E8%A1%8C">1.2.1.3 空行</h5>
<ul>
<li>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头</li>
</ul>
<h5 id="1214-%E8%AF%B7%E6%B1%82%E5%8C%85%E4%BD%93">1.2.1.4 请求包体</h5>
<ul>
<li>存不存在与方法的选择有关</li>
<li>get方法中
<ul>
<li>不存在请求包体</li>
</ul>
</li>
<li>其他方法包含以下属性
<ul>
<li>Content-Type</li>
<li>Content-Length</li>
</ul>
</li>
</ul>
<h4 id="122-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8C%85%E4%BD%93content-type%E4%BB%A5%E5%8F%8Aaxios%E7%9A%84config%E7%9A%84%E5%85%B3%E7%B3%BB">1.2.2 请求方法与请求包体Content-type以及axios的config的关系</h4>
<tabel>
  <thead>
    <tr>
      <th>请求方法</th>
      <th>请求包体中的Content-type</th>
      <th>axios的config写法</th>
      <th>发送请求的显示方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GET</td>
      <td>无</td>
      <td>axios的config写法</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>application/json</td>
      <td>axios的config写法</td>
      <td>请求体中的数据将会以json字符串的形式发送到后端</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>application/x-www-form-urlencoded</td>
      <td>axios的config写法</td>
      <td>请求体中的数据会以普通表单形式（键值对）发送到后端</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>multipart/form-data</td>
      <td>axios的config写法</td>
      <td>般用来上传文件，指定传输数据为二进制数据</td>
    </tr>
  </tbody>
</table>
<h3 id="13-http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">1.3 http响应报文</h3>
<ul>
<li><img src="./img/http_reponse.jpg" alt="相应报文"></li>
</ul>
<h4 id="131-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E7%BB%84%E6%88%90">1.3.1 响应报文的组成</h4>
<h5 id="1311-%E7%8A%B6%E6%80%81%E8%A1%8C">1.3.1.1 状态行</h5>
<ul>
<li>状态行由 HTTP 协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;</li>
</ul>
<h6 id="13111-http%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5">1.3.1.1.1 http协议字段</h6>
<h6 id="13112-%E7%8A%B6%E6%80%81%E7%A0%81">1.3.1.1.2 状态码</h6>
<table>
  <thead>
    <tr>
      <th>状态码</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1xx</td>
      <td>表示服务器已接收了客户端请求，客户端可继续发送请求</td>
    </tr>
    <tr>
      <td>2xx</td>
      <td>表示服务器已成功接收到请求并进行处理;</td>
    </tr>
    <tr>
      <td>3xx</td>
      <td>表示服务器要求客户端重定向;</td>
    </tr>
    <tr>
      <td>4xx</td>
      <td>表示客户端的请求有非法内容</td>
    </tr>
    <tr>
      <td>5xx</td>
      <td>表示服务器未能正常处理客户端的请求而出现意外错误;</td>
    </tr>
  </tbody>
</table>
<h6 id="13113-%E7%8A%B6%E6%80%81%E7%A0%81%E6%8F%8F%E8%BF%B0%E6%96%87%E6%9C%AC">1.3.1.1.3 状态码描述文本</h6>
<table>
  <thead>
    <tr>
      <th>状态码</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>200 OK</td>
      <td>表示客户端请求成功;</td>
    </tr>
    <tr>
      <td>400 Bad Request</td>
      <td>表示客户端请求有语法错误，不能被服务器所理解;</td>
    </tr>
    <tr>
      <td>401 Unauthonzed</td>
      <td>表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用;</td>
    </tr>
    <tr>
      <td>403 Forbidden</td>
      <td>表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因;</td>
    </tr>
    <tr>
      <td>404 Not Found</td>
      <td>请求的资源不存在，例如，输入了错误的URL;</td>
    </tr>
     <tr>
      <td>500 Internal Server Error</td>
      <td>表示服务器发生不可预期的错误，导致无法完成客户端的请求;</td>
    </tr>
    <tr>
      <td>503 Service Unavailable</td>
      <td>表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常;</td>
    </tr>
  </tbody>
</table>
<h5 id="1312-%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8">1.3.1.2 响应头部</h5>
<h6 id="13121-location">1.3.1.2.1 Location</h6>
<ul>
<li>用于重定向接受者到一个新的位置。
<ul>
<li>例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源;</li>
</ul>
</li>
</ul>
<h6 id="13122-server">1.3.1.2.2 Server</h6>
<ul>
<li>Server 响应报头域包含了服务器用来处理请求的软件信息及其版本。
<ul>
<li>它和 User-Agent 请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户端软件(浏览器)和操作系统的信息。</li>
</ul>
</li>
</ul>
<h6 id="13123-vary">1.3.1.2.3 Vary</h6>
<ul>
<li>指示不可缓存的请求头列表</li>
</ul>
<h6 id="13124-vary">1.3.1.2.4 Vary</h6>
<ul>
<li>指示不可缓存的请求头列表</li>
</ul>
<h6 id="13125-connection">1.3.1.2.5 Connection</h6>
<ul>
<li>连接方式</li>
<li>close</li>
<li>keepalive</li>
</ul>
<h5 id="1313-%E7%A9%BA%E8%A1%8C">1.3.1.3 空行</h5>
<h5 id="1314-%E5%93%8D%E5%BA%94%E5%8C%85%E4%BD%93">1.3.1.4 响应包体</h5>
<h3 id="14-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">1.4 基础知识补充</h3>
<h4 id="141-connection%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">1.4.1 Connection在不同报文中的作用</h4>
<ul>
<li>对于请求来说
<ul>
<li>close(告诉 WEB 服务器或者代理服务器，在完成本次请求的响应后，断开连接，不等待本次连接的后续请求了)</li>
<li>keepalive(告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求);</li>
</ul>
</li>
<li>对于响应来说
<ul>
<li>close(连接已经关闭)</li>
<li>keepalive(连接保持着，在等待本次连接的后续请求);</li>
<li>Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB 服务器保持连接多长时间(秒);例如：Keep-Alive：300;</li>
</ul>
</li>
</ul>
<h2 id="2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8F%90%E4%BE%9B%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84api%E5%88%86%E7%B1%BB">2 服务器提供给客户端的API分类</h2>
<h3 id="21-%E5%88%86%E7%B1%BB%E4%BE%9D%E6%8D%AE">2.1 分类依据</h3>
<ul>
<li>服务器提供的API端口允许客户端做CRUD操作的权限
<ul>
<li>即对应的两端交互的接口不同类型请求的响应类型</li>
</ul>
</li>
</ul>
<h3 id="22-%E7%B1%BB%E5%9E%8B">2.2 类型</h3>
<h4 id="221-rest-apirestful">2.2.1 REST API（restful）</h4>
<ul>
<li>发送请求运行CRUD哪个操作由请求方式决定</li>
<li>同一个请求路径可以同时进行多个操作
<ul>
<li>同时进行get或post</li>
</ul>
</li>
<li>请求方式可以有GET/POST/PUT/DELETE</li>
</ul>
<h4 id="222-%E9%9D%9E-rest-apirestless">2.2.2 非 REST API(restless)</h4>
<ul>
<li>请求方式不决定请求的CRUD操作</li>
<li>一个请求路径只能对应一个操作</li>
<li>一般只有GET/POST</li>
</ul>
<h2 id="3-%E6%90%AD%E5%BB%BA%E5%85%B7%E6%9C%89rest-api%E7%9A%84%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95">3 搭建具有REST API的简单服务器用于测试</h2>
<ul>
<li><a href="https://github.com/typicode/json-serve">网址</a></li>
<li>注意
<ul>
<li>db.json必须是在根目录下
<ul>
<li>db.json
<ul>
<li>posts: 发布文章</li>
<li>comments: 评论文章</li>
<li>profile: 我的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-ajax%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80--xhr">4 AJAX编程的基础--XHR</h2>
<h3 id="41-xhr%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">4.1. XHR的基本定义</h3>
<ul>
<li>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据</li>
<li>XMLHttpRequest 在 AJAX 编程中被大量使用。
<ul>
<li>AJAX技术：向服务器请求数据但不进行页面的跳转，而只是获取其中的数据</li>
</ul>
</li>
<li>显然XMLHttpRequest是异步调用</li>
</ul>
<h3 id="42-xhr%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">4.2 XHR的基本使用</h3>
<h4 id="421-xhr%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">4.2.1 XHR的构造函数</h4>
<ul>
<li>该构造函数用于初始化一个 XMLHttpRequest 实例对象。在调用下列任何其他方法之前，必须先调用该构造函数，或通过其他方式，得到一个实例对象。</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> XmlHttpRequest()
</div></code></pre>
<h4 id="423-xhr%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%BB%8E%E5%BB%BA%E7%AB%8B%E5%88%B0%E6%8E%A5%E6%94%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%8F%98%E5%8C%96">4.2.3 XHR实例对象从建立到接收到数据状态以及变化</h4>
<ul>
<li><img src="./img/axios_ex4.jpg" alt="状态"></li>
<li><img src="./img/axios_ex8.jpg" alt="状态关系"></li>
<li>分界的操作
<ul>
<li>open, send</li>
</ul>
</li>
</ul>
<h4 id="422-xhr%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BA%8B%E4%BB%B6">4.2.2 XHR实例对象接收数据时事件</h4>
<ul>
<li>事件的基本模型</li>
<li><img src="./img/axios_ex3.jpg" alt="模型"></li>
</ul>
<table>
  <tr>
    <td>loadstart</td>
    <td>接收到响应数据时触发。</td>
  </tr>
  <tr>
    <td>load</td>
    <td>XMLHttpRequest请求成功完成时触发。</td>
  </tr>
  <tr>
    <td>loadend</td>
    <td>当请求结束时触发, <font color="red">无论请求成功 ( load) 还是失败 (abort 或 error)。</font></td>
  </tr>
  <tr>
    <td>abort</td>
    <td>request被中止时触发（例如调用XHR.abort()）</td>
  </tr>
  <tr>
    <td>error</td>
    <td>当request遭遇错误时触发。</td>
  </tr>
  <tr>
    <td>progress</td>
    <td>当请求接收到更多数据时，周期性地触发。</td>
  </tr>
  <tr>
    <td>timeout</td>
    <td>在预设时间内没有接收到响应时触发。</td>
  </tr>
</table>
<ul>
<li>注意
<ul>
<li>load和loadend的区别：即使loadend只有在成功接收到了数据才会触发</li>
<li>progress: 由于接收响应的过程并不是连续的过程，每当再接收到一块数据时就会触发</li>
</ul>
</li>
</ul>
<h4 id="423-xhr%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">4.2.3 XHR的属性和方法</h4>
<h5 id="4231-%E4%B8%8E%E6%8E%A5%E6%94%B6%E5%88%B0%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7">4.2.3.1 与接收到响应结果相关的属性</h5>
<h6 id="42311-xmlhttprequestresponsetype%E5%8F%AA%E8%AF%BB">4.2.3.1.1 XmlHttpRequest#responseType(只读)</h6>
<ul>
<li>用于决定响应正文的格式</li>
<li>responseType取值以及对应的类型</li>
</ul>
<table>
  <thead>
    <tr>
      <th>取值</th>
      <th>对应的类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>""(空字符串)</td>
      <td>response采用默认类型 DOMString，与设置为 text 相同。</td>
    </tr>
    <tr>
      <td>arraybuffer</td>
      <td>response 是一个包含二进制数据的 JavaScript ArrayBuffer。</td>
    </tr>
    <tr>
      <td>blob</td>
      <td>response 是一个包含二进制数据的 Blob 对象 。</td>
    </tr>
    <tr>
      <td>document</td>
      <td>response 是一个 HTML Document 或 XML XMLDocument，</td>
    </tr>
    <tr>
      <td>json</td>
      <td>response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON 解析得到的。</td>
    </tr>
    <tr>
      <td>text</td>
      <td>response 是一个以 DOMString 对象表示的文本。</td>
    </tr>
  </tbody>
</table>
<h6 id="42312-xmlhttprequestresponse%E5%8F%AA%E8%AF%BB">4.2.3.1.2 XmlHttpRequest#response(只读)</h6>
<ul>
<li>返回响应的正文，响应报文的类型由XmlHttpRequest#responseType决定</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> url = <span class="hljs-string">'somePage.html'</span>; <span class="hljs-comment">//一个本地页面</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">load</span>(<span class="hljs-params">url, callback</span>) </span>{
    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

  xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) {
      callback(xhr.response);
    }
  }

  xhr.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>);
  xhr.send(<span class="hljs-string">''</span>);
}
</div></code></pre>
<h6 id="42313-xmlhttprequeststatus--statustext%E5%8F%AA%E8%AF%BB">4.2.3.1.3 XmlHttpRequest#status / statusText（只读）</h6>
<ul>
<li>返回响应的状态码 / 状态码的描述</li>
</ul>
<h6 id="42314-xmlhttprequestresponseurl%E5%8F%AA%E8%AF%BB">4.2.3.1.4 XmlHttpRequest#responseURL(只读)</h6>
<ul>
<li>返回响应的序列化URL
<ul>
<li>如果URL为空则返回空字符串。</li>
<li>如果URL有锚点，则位于URL # 后面的内容会被删除。</li>
<li>如果URL有重定向， responseURL 的值会是经过多次重定向后的最终 URL</li>
</ul>
</li>
</ul>
<h6 id="42315-xmlhttprequestresponsetext%E5%8F%AA%E8%AF%BB">4.2.3.1.5 XmlHttpRequest#responseText(只读)</h6>
<ul>
<li>DOMString 是XMLHttpRequest 返回的纯文本的值。当DOMString 为null时，表示请求失败了。当DOMString 为&quot;&quot;时，表示这个请求还没有被send()</li>
</ul>
<h6 id="42316-xmlhttprequestresponsexml%E5%8F%AA%E8%AF%BB">4.2.3.1.6 XmlHttpRequest#responseXML(只读)</h6>
<ul>
<li>返回一个包含请求检索的HTML或XML的Document
<ul>
<li>responseXML 对于任何其他类型的数据以及 data: URLs 为 null。</li>
</ul>
</li>
</ul>
<h6 id="42317-xmlhttprequestgetallresponseheaders">4.2.3.1.7 XmlHttpRequest#getAllResponseHeaders()</h6>
<ul>
<li>以字符串的形式返回所有用 , 分隔的响应头，如果没有收到响应，则返回 null。</li>
</ul>
<h6 id="42318-xmlhttprequestgetresponseheadername">4.2.3.1.8 XmlHttpRequest#getResponseHeader(name)</h6>
<ul>
<li>返回包含指定响应头文本的字符串。</li>
<li>参数
<ul>
<li>一个字符串，表示要返回的报文项名称</li>
</ul>
</li>
</ul>
<h5 id="4232-%E4%B8%8E%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7">4.2.3.2 与状态相关的属性</h5>
<h6 id="42321-xmlhttprequestreadystate%E5%8F%AA%E8%AF%BB">4.2.3.2.1 XmlHttpRequest#readyState(只读)</h6>
<ul>
<li>返回一个XMLHttpRequest实例对象(client)当前所处的状态</li>
</ul>
<h6 id="42322-xmlhttprequestonreadystatechange--callback">4.2.3.2.2 XmlHttpRequest#onreadystatechange = callback</h6>
<ul>
<li>只要 readyState 属性发生变化，就会调用相应的处理函数</li>
<li>注意
<ul>
<li>当一个 XMLHttpRequest 请求被 abort() 方法取消时，其对应的 readystatechange 事件不会被触发。</li>
<li>不能用于同步的requests对象之中
<ul>
<li>因为产生阻塞所以无法探查得到</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'UNSENT'</span>, xhr.status);

xhr.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/server'</span>, <span class="hljs-literal">true</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OPENED'</span>, xhr.status);

xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'LOADING'</span>, xhr.status);
};

xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'DONE'</span>, xhr.status);
};

xhr.send(<span class="hljs-literal">null</span>);

<span class="hljs-comment">/**
 * 输出如下：
 *
 * UNSENT（未发送） 0
 * OPENED（已打开） 0
 * LOADING（载入中） 200
 * DONE（完成） 200
 */</span>
</div></code></pre>
<h5 id="4233-%E4%B8%8E%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">4.2.3.3 与请求超时相关的属性和方法</h5>
<h6 id="42331-xmlhttprequesttimeout">4.2.3.3.1 XmlHttpRequest#timeout</h6>
<ul>
<li>用于设置/读取该实例对象请求的超时时间</li>
</ul>
<h6 id="42332-xmlhttprequestontimeout--callback">4.2.3.3.2 XmlHttpRequest#ontimeout = callback</h6>
<ul>
<li>超时触发callback</li>
</ul>
<h5 id="4234-%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95">4.2.3.4 特殊的事件触发有关方法</h5>
<h6 id="42341-xmlhttprequestabort">4.2.3.4.1 XmlHttpRequest#abort()</h6>
<ul>
<li>如果请求已被发出，则立刻中止请求。</li>
</ul>
<h5 id="4235-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%9C%89%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">4.2.3.5 发送请求有关的属性和方法</h5>
<h6 id="42351-xmlhttprequestopenmethod-url-async-user-password">4.2.3.5.1 XmlHttpRequest#open(method, url[, async[, user[, password]]])</h6>
<ul>
<li>初始化一个请求，并没有发送</li>
<li>参数
<ul>
<li>method
<ul>
<li>请求方式</li>
</ul>
</li>
<li>url
<ul>
<li>请求地址</li>
</ul>
</li>
<li>async
<ul>
<li>true: 异步</li>
<li>false：同步
<ul>
<li>send()代码会发生阻塞</li>
</ul>
</li>
</ul>
</li>
<li>user
<ul>
<li>用户名</li>
</ul>
</li>
<li>password
<ul>
<li>密码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="42352-xmlhttprequestsetrequestheaderheadername-value">4.2.3.5.2 XmlHttpRequest#setRequestHeader(headerName, value)</h6>
<ul>
<li>设置HTTP请求头部的方法。
<ul>
<li><font color="red">此方法必须在open() 方法和 send()之间调用</font>。如果多次对同一个请求头赋值，只会生成一个合并了多个值的请求头</li>
</ul>
</li>
<li>键值对应
<ul>
<li>Content-Type 文本的格式</li>
</ul>
</li>
</ul>
<h6 id="42353-xmlhttprequestsendbody">4.2.3.5.3 XmlHttpRequest#send(body)</h6>
<ul>
<li>向服务器发送已经初始好的ajax请求</li>
<li>body
<ul>
<li>若method为get，则为null，因为get没有请求体</li>
<li>请求体
<ul>
<li>string 使用键值的方式：类似于foo=bar&amp;lorem=ipsum</li>
<li>object 使用对象的方式</li>
<li>blob对象类型</li>
<li>Int8Array 对象类型</li>
<li>document (json等) 对象类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
xhr.open(<span class="hljs-string">"POST"</span>, <span class="hljs-string">'/server'</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">//发送合适的请求头信息</span>
xhr.setRequestHeader(<span class="hljs-string">"Content-type"</span>, <span class="hljs-string">"application/x-www-form-urlencoded"</span>);

xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-comment">// 请求结束后,在此处写处理代码 </span>
};
xhr.send(<span class="hljs-string">"foo=bar&amp;lorem=ipsum"</span>); 
</div></code></pre>
<h2 id="5-%E5%88%A9%E7%94%A8xhr%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0axios">5 利用XHR简单实现axios</h2>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * axios的特点
 *  1. 函数的返回值是一个promise，成功的结果为response，异常的返回error
 *  2. 能处理多种类型的请求：GET/POST/PUT/DELETE
 *  3. 函数的参数为一个配置对象
 *       {
 *            url       请求地址
 *            method    请求方式    
 *            params    GET/DELETE请求的query参数
 *            data      POST或DELETE请求的请求体参数
 *        }
 *  4. 响应的数据专户为对象或数组：JSON.parse(request.response)
 */</span>

<span class="hljs-comment">// 由于传入的是一个对象，该形参运用的是对象的结构语法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">axios</span>(<span class="hljs-params">{
    url, 
    method=<span class="hljs-string">"GET"</span>,
    params={},
    data={}
}</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-comment">// 1. 执行异步的ajax请求</span>
        method = method.toUpperCase();
        <span class="hljs-comment">// 创建xhr请求</span>
        <span class="hljs-keyword">const</span> request = XMLHttpRequest();
        <span class="hljs-comment">// 初始化xhr</span>
        request.open(method, url)
        <span class="hljs-comment">// 发送请求</span>
        <span class="hljs-keyword">switch</span>(method) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"GET"</span> || <span class="hljs-string">"PUT"</span>:
                <span class="hljs-comment">// 处理query形式的参数，并拼接到url上面 id=1&amp;...</span>
                <span class="hljs-keyword">let</span> queryString = <span class="hljs-string">''</span>;
                <span class="hljs-built_in">Object</span>.keys(params).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
                    queryString += <span class="hljs-string">`<span class="hljs-subst">${key}</span>=<span class="hljs-subst">${params[key]}</span>&amp;`</span>
                })
                <span class="hljs-keyword">if</span>(queryString){
                    queryString = queryString.substr(<span class="hljs-number">0</span>, queryString.length - <span class="hljs-number">1</span>);
                    url += <span class="hljs-string">'?'</span> + ueryString;
                }
                request.send(<span class="hljs-literal">null</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">"POST"</span> || <span class="hljs-string">"DELETE"</span>:
                <span class="hljs-comment">// 告诉请求体是json格式</span>
                request.setRequestHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json;charset=utf-8"</span>)
                request.send(<span class="hljs-built_in">JSON</span>.stringify(data))
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">// 绑定状态改变的监听来判断运行结果</span>
        request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span>(request.readyState !== <span class="hljs-number">4</span>)
                <span class="hljs-keyword">return</span>;
            <span class="hljs-comment">//  如果状态码在200-300之间，代表成功，否则失败</span>
            <span class="hljs-keyword">const</span> {status, statusText} = request;
            <span class="hljs-comment">// 2.1 如果请求成功，调用resolve()</span>

            <span class="hljs-comment">// 2.2 如果请求失败,调用reject()</span>
            <span class="hljs-keyword">if</span>(status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>) {
                <span class="hljs-keyword">const</span> response = {
                    <span class="hljs-attr">data</span>: <span class="hljs-built_in">JSON</span>.parse(request.response),
                    status,
                    statusText
                }
                resolve(response);
            }
                
            <span class="hljs-keyword">else</span>{
                reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"request error status is"</span> + status))
            }
        }
        
    })
}
</div></code></pre>
<h2 id="6-axios%E7%9A%84%E4%BD%BF%E7%94%A8">6 axios的使用</h2>
<h3 id="61-axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">6.1 axios的基本定义</h3>
<ul>
<li>是一个基于 promise 的ajax请求库，可以用在浏览器和node.js 中。</li>
</ul>
<h3 id="62-axios%E7%9A%84%E7%89%B9%E5%BE%81">6.2 axios的特征</h3>
<ul>
<li>从浏览器中创建XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API（基于promise的异步ajax请求库）</li>
<li>支持拦截请求和响应</li>
<li>转换请求数据和响应数据（就是json.parse)</li>
<li>支持取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<h3 id="63-axios%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">6.3 axios的基本使用</h3>
<h4 id="630-ajax%E8%AF%B7%E6%B1%82%E5%92%8C%E6%99%AE%E9%80%9A%E7%9A%84http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB">6.3.0 ajax请求和普通的http请求的区别</h4>
<ul>
<li>对于服务端，ajax请求和普通的http请求没有区别，区别在于浏览器</li>
<li>浏览器发送请求时
<ul>
<li>ajax请求是由浏览器中的ajax引擎进行发送</li>
<li>ajax请求是一种特殊的http请求，只有XHR或fetch发出的才是ajax请求，其他都是非ajax请求</li>
</ul>
</li>
<li>浏览器接收到响应报文时
<ul>
<li>一般请求：浏览器一般会直接显示响应体的数据，也就是我们所说的刷新/跳转页面</li>
<li>ajax请求：浏览器不会对界面进行更新操作，只是调用监视的回调函数并传入响应的相关数据</li>
</ul>
</li>
</ul>
<h4 id="631-axios%E7%9A%84config%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E5%90%AB%E4%B9%89">6.3.1 axios的config对应的参数和含义</h4>
<h4 id="632-axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F">6.3.2 axios发送请求的三种不同方式</h4>
<h5 id="6321-%E5%B0%86axios%E8%A7%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8E%BB%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">6.3.2.1 将axios视为一个对象去向服务器端发送请求</h5>
<pre class="hljs"><code><div>    <span class="hljs-comment">//发送get请求</span>
  axios.get(url[, config])
  <span class="hljs-comment">// 发送delete请求         </span>
  axios.delete(url[, config])
  <span class="hljs-comment">// 发送post请求</span>
  axios.post(url[, data[, config]])
  <span class="hljs-comment">// 发送put请求</span>
  axios.put(url[, data[, config]])
</div></code></pre>
<h6 id="6321-axiosgeturlconfig">6.3.2.1 axios.get(url[,config])</h6>
<ul>
<li>向服务端查询数据，返回类型为Promise类型</li>
<li>参数
<ul>
<li>config
<ul>
<li>是一个对象</li>
</ul>
</li>
</ul>
</li>
<li>由于get方式没有请求体，所以在进行查询时需要设置config的params
<ul>
<li>params是一个键值的对象</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 为给定 ID 的 user 创建请求</span>
axios.get(<span class="hljs-string">'/user?ID=12345'</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error);
  });

<span class="hljs-comment">// 可选地，上面的请求可以这样做</span>
axios.get(<span class="hljs-string">'/user'</span>, {
    <span class="hljs-attr">params</span>: {
      <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>
    }
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error);
  });
</div></code></pre>
<h6 id="6322-axiosposturl-data">6.3.2.2 axios.post(url ,data)</h6>
<ul>
<li>向服务器端修改数据或者增加数据，返回一个Promise</li>
<li>由于post有请求体，所以可以直接传入data，而不需要设置config中的params</li>
</ul>
<pre class="hljs"><code><div>  axios.post(<span class="hljs-string">'/user'</span>, {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Fred'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Flintstone'</span>
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error);
  });
</div></code></pre>
<h6 id="6323-axiosputurl-data">6.3.2.3 axios.put(url ,data)</h6>
<ul>
<li>对服务器中相应的id数据进行修改或者更新，返回一个Promise类型</li>
<li>由于put有请求体，所以可以直接传入data，而不需要设置config中的params</li>
</ul>
<pre class="hljs"><code><div>  axios.put(<span class="hljs-string">'/user/1'</span>, {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Fred'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Flintstone'</span>data
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error);
  });
</div></code></pre>
<h5 id="6322-%E5%B0%86axios%E8%A7%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%8E%BB%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">6.3.2.2 将axios视为一个函数去向服务器端发送请求</h5>
<ul>
<li>缺点：只能有一个异步的ajax请求</li>
</ul>
<h6 id="6331-axiosconfig">6.3.3.1 axios(config)</h6>
<ul>
<li>返回一个promise对象</li>
</ul>
<pre class="hljs"><code><div>  axios({
    <span class="hljs-attr">method</span>: <span class="hljs-string">"post"</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-string">"xxx"</span>
    <span class="hljs-comment">// ...</span>
  })
</div></code></pre>
<h5 id="6323-%E5%B0%86axios%E8%A7%86%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%BB%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">6.3.2.3 将axios视为一个构造函数去向服务器端发送请求</h5>
<h6 id="63231-axioscreateconfig">6.3.2.3.1 axios.create(config)</h6>
<ul>
<li>返回一个axios的实例</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">// 一般用于首先配置默认请求</span>
  <span class="hljs-keyword">const</span> instance = axios.create({
    <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://...'</span>
  })
  <span class="hljs-comment">// 使用instance发送请求</span>
  instance({
    <span class="hljs-attr">url</span>:<span class="hljs-string">'/xxx'</span>
  })
</div></code></pre>
<h6 id="63232-axios%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">6.3.2.3.2 axios实例的方法</h6>
<ul>
<li>和全局的axios没有区别</li>
</ul>
<pre class="hljs"><code><div>  axios#request(config)
  axios#<span class="hljs-keyword">get</span>(url[, config])
  axios#delete(url[, config])
  axios#head(url[, config])
  axios#options(url[, config])
  axios#post(url[, data[, config]])
  axios#put(url[, data[, config]])
  axios#patch(url[, data[, config]])
  axios#getUri([config])
</div></code></pre>
<h4 id="633-axios%E7%9A%84%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE">6.3.3 axios的全局配置</h4>
<h5 id="6331-axiosdefaultsconfigkey--value">6.3.3.1 axios.defaults.configKey = value</h5>
<ul>
<li>设置全局axios的配置</li>
</ul>
<pre class="hljs"><code><div>  axios.defaults.baseURL = <span class="hljs-string">'https://api.example.com'</span>;
  axios.defaults.headers.common[<span class="hljs-string">'Authorization'</span>] = AUTH_TOKEN;
  axios.defaults.headers.post[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'application/x-www-form-urlencoded'</span>;
</div></code></pre>
<h4 id="634-axios%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8">6.3.4 axios的拦截器</h4>
<h5 id="6341-axiosinterceptorsrequestusefuncconfig--functionerror">6.3.4.1 axios.interceptors.request.use(func(config) {}, function(error) {})</h5>
<ul>
<li>在ajax请求发送之前对config做一些处理</li>
</ul>
<pre class="hljs"><code><div>  axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
    <span class="hljs-comment">// Do something before request is sent</span>
    <span class="hljs-keyword">return</span> config;
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// Do something with request error</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
  });
</div></code></pre>
<ul>
<li>为什么需要返回config
<ul>
<li>在axios中，拦截器和request请求是以链的形式串联起来的，若不返回config，则返回undefine，相当于向下一个函数传递了config为undefined，所以会报错</li>
</ul>
</li>
</ul>
<h5 id="6342-axiosinterceptorsresponseusefuncresponse--functionerror">6.3.4.2 axios.interceptors.response.use(func(response) {}, function(error) {})</h5>
<ul>
<li>在axios获得response对response进行一些处理</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Add a response interceptor</span>
axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-comment">// Any status code that lie within the range of 2xx cause this function to trigger</span>
    <span class="hljs-comment">// Do something with response data</span>
    <span class="hljs-keyword">return</span> response;
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// Any status codes that falls outside the range of 2xx cause this function to trigger</span>
    <span class="hljs-comment">// Do something with response error</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
  });
</div></code></pre>
<ul>
<li>为什么需要返回response
<ul>
<li>在axios中，拦截器和request请求是以链的形式串联起来的，若不返回response，则返回undefine，相当于向下一个函数传递了response为undefined，所以会报错</li>
</ul>
</li>
</ul>
<h5 id="6343-%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B">6.3.4.3 拦截器的运行流程</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>)
<span class="hljs-comment">// 必须return config和reponse，否则报错</span>
<span class="hljs-comment">//请求拦截器</span>
axios.interceptors.request.use(
    <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"request interceptor1 onResolved"</span>);
        <span class="hljs-keyword">return</span> config;
    },
    error =&gt; {
        <span class="hljs-built_in">Promise</span>.reject(error)
    }
)
axios.interceptors.request.use(
    <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"request interceptor2 onResolved"</span>);
        <span class="hljs-keyword">return</span> config;
    },
    error =&gt; {
        <span class="hljs-built_in">Promise</span>.reject(error)
    }
)
<span class="hljs-comment">// 响应拦截器</span>
axios.interceptors.response.use(
    <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"request interceptor3 onResolved"</span>);
        <span class="hljs-keyword">return</span> response;
    },
    error =&gt; {
        <span class="hljs-built_in">Promise</span>.reject(error)
    }
)
axios.interceptors.response.use(
    <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"request interceptor4 onResolved"</span>);
        <span class="hljs-keyword">return</span> response;
    },
    error =&gt; {
        <span class="hljs-built_in">Promise</span>.reject(error)
    }
)
axios.get(<span class="hljs-string">"http://localhost:3000/posts"</span>).then(
    <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"取得的数据为"</span> + response.data)
    }
)
<span class="hljs-comment">/**
 *  结果
 * request interceptor2 onResolved
 * request interceptor1 onResolved
 * request interceptor3 onResolved
 * request interceptor4 onResolved
 * 取得的数据为[object Object],[object Object]
 */</span>
</div></code></pre>
<ul>
<li>一般的执行流程：
<ul>
<li>请求拦截器 -&gt; 异步request请求 -&gt; 响应拦截器 -&gt; then的回调函数</li>
</ul>
</li>
<li>请求拦截器
<ul>
<li>栈</li>
</ul>
</li>
<li>响应拦截器
<ul>
<li>队列</li>
</ul>
</li>
</ul>
<h4 id="635-axios%E7%9A%84reponse">6.3.5 axios的reponse</h4>
<ul>
<li>回调函数中的reponse参数的结构</li>
</ul>
<pre class="hljs"><code><div>  {
  <span class="hljs-comment">// `data` 由服务器提供的响应</span>
  <span class="hljs-attr">data</span>: {},

  <span class="hljs-comment">// `status` 来自服务器响应的 HTTP 状态码</span>
  <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,

  <span class="hljs-comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>
  <span class="hljs-attr">statusText</span>: <span class="hljs-string">'OK'</span>,

  <span class="hljs-comment">// `headers` 服务器响应的头</span>
  <span class="hljs-attr">headers</span>: {},

  <span class="hljs-comment">// `config` 是为请求提供的配置信息</span>
  <span class="hljs-attr">config</span>: {}
}
</div></code></pre>
<h4 id="636-axios%E7%9A%84%E5%8F%96%E6%B6%88">6.3.6 axios的取消</h4>
<ul>
<li>作用：取消未完成的请求</li>
</ul>
<h5 id="6361-%E6%96%B9%E6%B3%951-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%87%BD%E6%95%B0">6.3.6.1 方法1 使用内部的函数</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;
<span class="hljs-keyword">const</span> source = CancelToken.source();

axios.get(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">cancelToken</span>: source.token
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thrown</span>) </span>{
  <span class="hljs-keyword">if</span> (axios.isCancel(thrown)) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Request canceled'</span>, thrown.message);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// handle error</span>
  }
});

axios.post(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'new name'</span>
}, {
  <span class="hljs-attr">cancelToken</span>: source.token
})

<span class="hljs-comment">// cancel the request (the message parameter is optional)</span>
source.cancel(<span class="hljs-string">'Operation canceled by the user.'</span>);
</div></code></pre>
<h5 id="6362-%E6%96%B9%E6%B3%952%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">6.3.6.2 方法2：创建一个对象</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;
<span class="hljs-keyword">let</span> cancel;

axios.get(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>{
    <span class="hljs-comment">// An executor function receives a cancel function as a parameter</span>
    cancel = c;
  })
});

<span class="hljs-comment">// cancel the request</span>
cancel();
</div></code></pre>
<h5 id="6363-%E5%BA%94%E7%94%A8">6.3.6.3 应用</h5>
<h6 id="63631-%E7%94%A8%E4%BA%8E%E8%AF%B7%E6%B1%82%E5%BD%93%E5%89%8D%E7%9A%84%E8%AF%B7%E6%B1%82">6.3.6.3.1 用于请求当前的请求</h6>
<pre class="hljs"><code><div>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> cancel === <span class="hljs-string">'function'</span>)
    cancel();
  <span class="hljs-comment">// 之后在then的回调函数中</span>
  <span class="hljs-comment">// 将cancel设置为null，若已经执行好的，cancel为null,所以不会再执行</span>
</div></code></pre>
<h6 id="63632-%E7%94%A8%E4%BA%8E%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82">6.3.6.3.2 用于请求上一个请求</h6>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> cancel = c;
  btn1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> cancel === <span class="hljs-string">"function"</span>)
      cancel(<span class="hljs-string">"取消上一个请求"</span>)
    axios({
      <span class="hljs-attr">url</span>:<span class="hljs-string">"url1"</span>,
      <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
      <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> cancelToken(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> {
        cancel = c;
      })
    }).then(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      response =&gt; {
        ...
        cancel = <span class="hljs-literal">null</span>;
      },
      error =&gt; {
        <span class="hljs-keyword">if</span>(isCancel(error)) {
          ...
        }
        <span class="hljs-keyword">else</span>{
          ...
          cancel = <span class="hljs-literal">null</span>;
        }
      }
    })
  }
  btn2.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> cancel === <span class="hljs-string">"function"</span>)
      cancel(<span class="hljs-string">"取消上一个请求"</span>)
    axios({
      <span class="hljs-attr">url</span>:<span class="hljs-string">"url2"</span>,
      <span class="hljs-attr">method</span>: <span class="hljs-string">"get"</span>,
      <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> cancelToken(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> {
        cancel = c;
      })
    }).then(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      response =&gt; {
        ...
        cancel = <span class="hljs-literal">null</span>;
      },
      error =&gt; {
        <span class="hljs-keyword">if</span>(isCancel(error)) {
          ...
        }
        <span class="hljs-keyword">else</span>{
          ...
          cancel = <span class="hljs-literal">null</span>;
        }
      }
    })
  }
</div></code></pre>
<ul>
<li>为什么在reject的回调函数中要分情况，而isCancel不能赋值为null？
<ul>
<li>异步函数的机制是浏览器将异步任务交给操作系统中的线程去执行，当达到触发条件时，在将其加入宏队列或者微队列中执行</li>
<li>执行的步骤
<ul>
<li>在执行完全部同步代码后，当用户点击btn1时，触发了点击事件，执行了axios的同步代码，将cancel赋值为函数之后发出请求</li>
<li>当用户点击了btn2时，触发了btn2事件，于是将其回调函数加入了宏队列，此时执行了其回调函数中的同步代码，取消btn1中的请求，同时将cancel赋值为btn2请求的cancel函数。由于请求被取消，所以触发了axios取消的事件
<ul>
<li>若此时部分情况将cancel赋值为null，则会将第二个请求的cancel函数赋值为null，进而使得后面的取消无效</li>
</ul>
</li>
<li>重点是理解同步任务和异步任务是如何执行的，执行的顺序是什么</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-axios%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">7 axios源码分析</h2>
<h3 id="71-axios%E4%B8%8Eaxios%E7%9A%84%E5%85%B3%E7%B3%BB">7.1 axios与Axios的关系</h3>
<ul>
<li>从语法上来说
<ul>
<li>axios不是Axios的实例</li>
</ul>
</li>
<li>从功能上来说
<ul>
<li>axios是Axios的实例</li>
<li>axios既有Axios原型上的属性和方法，又有Axios实例对象的属性和方法</li>
</ul>
</li>
<li>axios是Axios.prototype.request函数bind()返回的函数</li>
<li>axios作为对象有Axios原型对象上的所有方法，有Axios对象的所有属性</li>
<li>源码</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">/**
 * Create an instance of Axios
 *
 * <span class="hljs-doctag">@param <span class="hljs-type">{Object}</span> </span>defaultConfig The default config for the instance
 * <span class="hljs-doctag">@return <span class="hljs-type">{Axios}</span> </span>A new instance of Axios
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInstance</span>(<span class="hljs-params">defaultConfig</span>) </span>{
  <span class="hljs-comment">// 1. 创建了一个Axios的实例</span>
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> Axios(defaultConfig);
  <span class="hljs-comment">/*
  module.exports = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i &lt; args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  */</span>

    <span class="hljs-comment">// 2.1 instance是一个函数</span>
    <span class="hljs-comment">// 2.2 当instance被调用的时候，Axios.prototype.request的this会指向context对象（即context拥有了其所有属性和方法)，并且由context来执行request</span>
    <span class="hljs-comment">// 2.3 该方法实现了axios(config)时执行了request</span>
  <span class="hljs-keyword">var</span> instance = bind(Axios.prototype.request, context);
  <span class="hljs-comment">// Copy axios.prototype to instance</span>
  <span class="hljs-comment">// 3.1 Axios.prototype对象中的属性和方法绑定给instance, 可以发现get，post等实际上也是使用了request</span>
  <span class="hljs-comment">// 3.2 该方法实现了axios.get(),axios.request()等方法</span>
  utils.extend(instance, Axios.prototype, context);

  <span class="hljs-comment">// 4.1 Copy context to instance</span>
  <span class="hljs-comment">// 4.2 使得axios是Axios的一个实例，具有default和interceptor的特殊属性</span>
  utils.extend(instance, context);

  <span class="hljs-keyword">return</span> instance;
  <span class="hljs-comment">// instance是Axios的一个实例，且有Axios原型对象的属性和方法，而且又是一个函数，可以直接调用原型对象中的request方法</span>
}
</div></code></pre>
<ul>
<li>axios的指向</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> axios = createInstance(defaults);
</div></code></pre>
<h3 id="72-axios%E4%B8%8Einstance%E7%9A%84%E5%8C%BA%E5%88%AB">7.2 axios与instance的区别</h3>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> instance = axios.create(config)
</div></code></pre>
<ul>
<li>相同点
<ul>
<li>都是一个能发送给任意请求的函数:request(config)</li>
<li>都有发特定请求的各种方法get()/post()/put()/delete()</li>
<li>都有默认配置和拦截器属性defaluts/interceptor</li>
</ul>
</li>
<li>不同
<ul>
<li>默认匹配值很可能不一样</li>
<li>instance后面没有添加一些方法
<ul>
<li>create()/CancelToken()/all</li>
</ul>
</li>
</ul>
</li>
<li>源码</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Factory for creating new instances</span>
axios.create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">instanceConfig</span>) </span>{
  <span class="hljs-keyword">return</span> createInstance(mergeConfig(axios.defaults, instanceConfig));
};
</div></code></pre>
<ul>
<li>axios特有的属性和方法</li>
</ul>
<pre class="hljs"><code><div>axios.Axios = Axios;

<span class="hljs-comment">// Factory for creating new instances</span>
axios.create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">instanceConfig</span>) </span>{
  <span class="hljs-keyword">return</span> createInstance(mergeConfig(axios.defaults, instanceConfig));
};

<span class="hljs-comment">// Expose Cancel &amp; CancelToken</span>
axios.Cancel = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cancel/Cancel'</span>);
axios.CancelToken = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cancel/CancelToken'</span>);
axios.isCancel = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cancel/isCancel'</span>);

<span class="hljs-comment">// Expose all/spread</span>
axios.all = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">all</span>(<span class="hljs-params">promises</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(promises);
};
axios.spread = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers/spread'</span>);

</div></code></pre>
<h3 id="73-axios%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE">7.3 axios执行的流程图</h3>
<ul>
<li>
<p><img src="./img/axios_ex6.png" alt="流程图"></p>
</li>
<li>
<p>request(config)</p>
<ul>
<li>将请求拦截器/dispatchRequest()/响应拦截器通过promise链串连起来, 返回promise</li>
<li>dispatchRequest()
<ul>
<li>转换请求数据，调用xhrAdapter() =&gt; 请求返回后转换响应函数数据，返回promise</li>
<li>xhrAdapter()
<ul>
<li>创建xhr对象，根据config进行相应的设置，发送特定的请求，并接收响应的数据，返回promise。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>request(config)源码了解</p>
</li>
</ul>
<pre class="hljs"><code><div>Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-comment">/*eslint no-param-reassign:0*/</span>
  <span class="hljs-comment">// Allow for axios('example/url'[, config]) a la fetch API</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config === <span class="hljs-string">'string'</span>) {
    config = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || {};
    config.url = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
  } <span class="hljs-keyword">else</span> {
    config = config || {};
  }

  config = mergeConfig(<span class="hljs-keyword">this</span>.defaults, config);

  <span class="hljs-comment">// Set config.method</span>
  <span class="hljs-comment">// 1. 判断请求的类型</span>
  <span class="hljs-keyword">if</span> (config.method) {
    config.method = config.method.toLowerCase();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaults.method) {
    config.method = <span class="hljs-keyword">this</span>.defaults.method.toLowerCase();
  } <span class="hljs-keyword">else</span> {
    config.method = <span class="hljs-string">'get'</span>;
  }

  <span class="hljs-comment">// 2. 创建保存请求/响应拦截回调函数的数组</span>
  <span class="hljs-comment">/*
  数组的中间为发送请求的函数
  数组的左边为请求拦截器的回调函数（成功或失败）
  数组的右边为响应拦截器的回调函数
  */</span>
  <span class="hljs-keyword">var</span> chain = [dispatchRequest, <span class="hljs-literal">undefined</span>];
  <span class="hljs-keyword">var</span> promise = <span class="hljs-built_in">Promise</span>.resolve(config);

  <span class="hljs-comment">// 3. 后添加的请求拦截器回调函数加入到数组的前面</span>
  <span class="hljs-keyword">this</span>.interceptors.request.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshiftRequestInterceptors</span>(<span class="hljs-params">interceptor</span>) </span>{
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  <span class="hljs-comment">// 4. 后添加的响应拦截器回调函数加入到数组的后面</span>
  <span class="hljs-keyword">this</span>.interceptors.response.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushResponseInterceptors</span>(<span class="hljs-params">interceptor</span>) </span>{
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
  <span class="hljs-comment">// 5. 通过promise的then()串联起所有的请求拦截器/请求方法/响应拦截器</span>
  <span class="hljs-keyword">while</span> (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
  <span class="hljs-comment">// 返回用来指定我们的onResolved和onRejected的promise</span>
  <span class="hljs-keyword">return</span> promise;
};
</div></code></pre>
<ul>
<li>dispatchRequest()源码了解</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">/*
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    // 如果是Params数据，则转化为urlencoded类型
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    //// 如果是对象，则转换为json类型的数据
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],
 */</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchRequest</span>(<span class="hljs-params">config</span>) </span>{
  throwIfCancellationRequested(config);
  <span class="hljs-comment">// 1. 发请求前对设置，数据等进行处理</span>
  <span class="hljs-comment">// Ensure headers exist</span>
  config.headers = config.headers || {};

  <span class="hljs-comment">// Transform request data</span>
  config.data = transformData(
    config.data,
    config.headers,
    <span class="hljs-comment">// 1. 对请求头和类型进行转化</span>
    config.transformRequest

  );

  <span class="hljs-comment">// Flatten headers</span>
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    [<span class="hljs-string">'delete'</span>, <span class="hljs-string">'get'</span>, <span class="hljs-string">'head'</span>, <span class="hljs-string">'post'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'patch'</span>, <span class="hljs-string">'common'</span>],
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanHeaderConfig</span>(<span class="hljs-params">method</span>) </span>{
      <span class="hljs-keyword">delete</span> config.headers[method];
    }
  );

  <span class="hljs-keyword">var</span> adapter = config.adapter || defaults.adapter;
  <span class="hljs-comment">// 2. 发送请求</span>
  <span class="hljs-keyword">return</span> adapter(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onAdapterResolution</span>(<span class="hljs-params">response</span>) </span>{
    throwIfCancellationRequested(config);
    <span class="hljs-comment">/*
    transformResponse: [function transformResponse(data) {
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { }
    }
      return data;
    }],
    */</span>

    <span class="hljs-comment">// 3. 对请求的数据的格式进行转换</span>
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    <span class="hljs-keyword">return</span> response;
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onAdapterRejection</span>(<span class="hljs-params">reason</span>) </span>{
    <span class="hljs-keyword">if</span> (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      <span class="hljs-comment">// Transform response data</span>
      <span class="hljs-keyword">if</span> (reason &amp;&amp; reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(reason);
  });
};
</div></code></pre>
<ul>
<li>xhrAdapter()源码了解</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xhrAdapter</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchXhrRequest</span>(<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">var</span> requestData = config.data;
    <span class="hljs-keyword">var</span> requestHeaders = config.headers;

    <span class="hljs-keyword">if</span> (utils.isFormData(requestData)) {
      <span class="hljs-keyword">delete</span> requestHeaders[<span class="hljs-string">'Content-Type'</span>]; <span class="hljs-comment">// Let the browser set it</span>
    }

    <span class="hljs-keyword">if</span> (
      (utils.isBlob(requestData) || utils.isFile(requestData)) &amp;&amp;
      requestData.type
    ) {
      <span class="hljs-keyword">delete</span> requestHeaders[<span class="hljs-string">'Content-Type'</span>]; <span class="hljs-comment">// Let the browser set it</span>
    }
    <span class="hljs-comment">// 1. 创建xml的对象</span>
    <span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();

    <span class="hljs-comment">// HTTP basic authentication</span>
    <span class="hljs-keyword">if</span> (config.auth) {
      <span class="hljs-keyword">var</span> username = config.auth.username || <span class="hljs-string">''</span>;
      <span class="hljs-keyword">var</span> password = <span class="hljs-built_in">unescape</span>(<span class="hljs-built_in">encodeURIComponent</span>(config.auth.password)) || <span class="hljs-string">''</span>;
      requestHeaders.Authorization = <span class="hljs-string">'Basic '</span> + btoa(username + <span class="hljs-string">':'</span> + password);
    }

    <span class="hljs-keyword">var</span> fullPath = buildFullPath(config.baseURL, config.url);
    <span class="hljs-comment">// 2.配置xml的对象的参数</span>
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), <span class="hljs-literal">true</span>);

    <span class="hljs-comment">// Set the request timeout in MS</span>
    request.timeout = config.timeout;

    <span class="hljs-comment">// Listen for ready state</span>
    <span class="hljs-comment">// 3. 设置状态监听器来监视党情的状态</span>
    request.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleLoad</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// 3.1 如果状态不为4</span>
      <span class="hljs-keyword">if</span> (!request || request.readyState !== <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-comment">// The request errored out and we didn't get a response, this will be</span>
      <span class="hljs-comment">// handled by onerror instead</span>
      <span class="hljs-comment">// With one exception: request that using file: protocol, most browsers</span>
      <span class="hljs-comment">// will return status as 0 even though it's a successful request</span>
      <span class="hljs-keyword">if</span> (request.status === <span class="hljs-number">0</span> &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf(<span class="hljs-string">'file:'</span>) === <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-comment">// Prepare the response</span>
      <span class="hljs-comment">// 3.2 接收响应的数据</span>
      <span class="hljs-keyword">var</span> responseHeaders = <span class="hljs-string">'getAllResponseHeaders'</span> <span class="hljs-keyword">in</span> request ? parseHeaders(request.getAllResponseHeaders()) : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> responseData = !config.responseType || config.responseType === <span class="hljs-string">'text'</span> ? request.responseText : request.response;
      <span class="hljs-keyword">var</span> response = {
        <span class="hljs-attr">data</span>: responseData,
        <span class="hljs-attr">status</span>: request.status,
        <span class="hljs-attr">statusText</span>: request.statusText,
        <span class="hljs-attr">headers</span>: responseHeaders,
        <span class="hljs-attr">config</span>: config,
        <span class="hljs-attr">request</span>: request
      };

      <span class="hljs-comment">// 3.3 根据reponse的status来确定请求是成功还是失败</span>
      settle(resolve, reject, response);

        <span class="hljs-comment">/*
        validateStatus: function validateStatus(status) {
          return status &gt;= 200 &amp;&amp; status &lt; 300;
        }
        // 若status位于200~300之间，则证明请求是成功的
        */</span>
      <span class="hljs-comment">/*
      function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;

        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError(
            'Request failed with status code ' + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      */</span>
      <span class="hljs-comment">// Clean up request</span>
      request = <span class="hljs-literal">null</span>;
    };

    <span class="hljs-comment">// Handle browser request cancellation (as opposed to a manual cancellation)</span>
    <span class="hljs-comment">// 3.4 绑定中断的事件</span>
    request.onabort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAbort</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!request) {
        <span class="hljs-keyword">return</span>;
      }

      reject(createError(<span class="hljs-string">'Request aborted'</span>, config, <span class="hljs-string">'ECONNABORTED'</span>, request));

      <span class="hljs-comment">// Clean up request</span>
      request = <span class="hljs-literal">null</span>;
    };
  ................
  <span class="hljs-comment">// 4. 发送请求</span>
  request.send(requestData);
</div></code></pre>
<h3 id="74-axios%E5%A6%82%E4%BD%95%E6%8A%8Ainterceptor%E5%92%8Crequest%E4%B8%B2%E8%81%94%E8%B5%B7%E6%9D%A5">7.4 axios如何把interceptor和request串联起来</h3>
<ul>
<li><img src="./img/axios_ex7.jpg" alt="串连图"></li>
</ul>
<pre class="hljs"><code><div>Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-comment">/*eslint no-param-reassign:0*/</span>
  <span class="hljs-comment">// Allow for axios('example/url'[, config]) a la fetch API</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config === <span class="hljs-string">'string'</span>) {
    config = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || {};
    config.url = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];
  } <span class="hljs-keyword">else</span> {
    config = config || {};
  }

  config = mergeConfig(<span class="hljs-keyword">this</span>.defaults, config);

  <span class="hljs-comment">// Set config.method</span>
  <span class="hljs-comment">// 1. 判断请求的类型</span>
  <span class="hljs-keyword">if</span> (config.method) {
    config.method = config.method.toLowerCase();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaults.method) {
    config.method = <span class="hljs-keyword">this</span>.defaults.method.toLowerCase();
  } <span class="hljs-keyword">else</span> {
    config.method = <span class="hljs-string">'get'</span>;
  }

  <span class="hljs-comment">// 2. 创建保存请求/响应拦截回调函数的数组</span>
  <span class="hljs-comment">/*
  数组的中间为发送请求的函数
  数组的左边为请求拦截器的回调函数（成功或失败）
  数组的右边为响应拦截器的回调函数
  */</span>
  <span class="hljs-keyword">var</span> chain = [dispatchRequest, <span class="hljs-literal">undefined</span>];
  <span class="hljs-keyword">var</span> promise = <span class="hljs-built_in">Promise</span>.resolve(config);

  <span class="hljs-comment">// 3. 后添加的请求拦截器回调函数加入到数组的前面</span>
  <span class="hljs-keyword">this</span>.interceptors.request.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshiftRequestInterceptors</span>(<span class="hljs-params">interceptor</span>) </span>{
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  <span class="hljs-comment">// 4. 后添加的响应拦截器回调函数加入到数组的后面</span>
  <span class="hljs-keyword">this</span>.interceptors.response.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushResponseInterceptors</span>(<span class="hljs-params">interceptor</span>) </span>{
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });
  <span class="hljs-comment">// 5. 通过promise的then()串联起所有的请求拦截器/请求方法/响应拦截器</span>
  <span class="hljs-keyword">while</span> (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }
  <span class="hljs-comment">// 返回用来指定我们的onResolved和onRejected的promise</span>
  <span class="hljs-keyword">return</span> promise;
};
</div></code></pre>
<ul>
<li>请求拦截器后添加先执行</li>
</ul>
<h3 id="75-axios%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88request%E7%9A%84%E8%AF%B7%E6%B1%82%E7%9A%84">7.5 axios是如何取消request的请求的</h3>
<ul>
<li>通过创建一个cancelToken的对象进行取消</li>
<li>源码
<ul>
<li>在xml函数中有abort()方法来取消请求</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 若配置中存在cancelToken则调用request.abort();</span>
<span class="hljs-keyword">if</span> (config.cancelToken) {

      <span class="hljs-comment">// Handle cancellation</span>
      config.cancelToken.promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onCanceled</span>(<span class="hljs-params">cancel</span>) </span>{
        <span class="hljs-keyword">if</span> (!request) {
          <span class="hljs-keyword">return</span>;
        }

        request.abort();
        reject(cancel);
        <span class="hljs-comment">// Clean up request</span>
        request = <span class="hljs-literal">null</span>;
      });
    }

    <span class="hljs-keyword">if</span> (!requestData) {
      requestData = <span class="hljs-literal">null</span>;
    }

</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CancelToken</span>(<span class="hljs-params">executor</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> executor !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'executor must be a function.'</span>);
  }

  <span class="hljs-comment">// 通过一个全局的resolve，使的可以在外部调用当前的promise</span>
  <span class="hljs-keyword">var</span> resolvePromise;
  <span class="hljs-keyword">this</span>.promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseExecutor</span>(<span class="hljs-params">resolve</span>) </span>{
    resolvePromise = resolve;
  });
  <span class="hljs-comment">//保存当前的对象为token</span>
  <span class="hljs-keyword">var</span> token = <span class="hljs-keyword">this</span>;
  <span class="hljs-comment">// 执行器：</span>
  <span class="hljs-comment">// 1. 为外面的形参定义成一个函数，以便于外面的函数进行调用</span>
  <span class="hljs-comment">// 2. 执行外面传入的函数体</span>
  executor(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancel</span>(<span class="hljs-params">message</span>) </span>{
    <span class="hljs-comment">// 即若是调用cancel则会将其变为resolve</span>
    <span class="hljs-comment">// 如果有reason，则证明已经取消完成了</span>
    <span class="hljs-keyword">if</span> (token.reason) {
      <span class="hljs-comment">// Cancellation has already been requested</span>
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 将token的reason指定为一个Cancel对象</span>
    token.reason = <span class="hljs-keyword">new</span> Cancel(message);
    <span class="hljs-comment">// 成功的回调，成功才调用cancel</span>
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwIfRequested</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reason) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">this</span>.reason;
  }
};

<span class="hljs-comment">/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */</span>
CancelToken.source = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">source</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> cancel;
  <span class="hljs-keyword">var</span> token = <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>{
    cancel = c;
  });
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">token</span>: token,
    <span class="hljs-attr">cancel</span>: cancel
  };
};
</div></code></pre>
<ul>
<li>当配置了cancelToken对象时，保存cancel函数
<ul>
<li>创建一个用于将来中断请求的cancelPromise</li>
<li>并定义了一个用于取消请求的cancel函数</li>
<li>将cance函数传递出来</li>
</ul>
</li>
<li>调用cancel()取消请求</li>
<li>调用cancel()取消请求
<ul>
<li>执行cancel函数，传入错误信息message</li>
<li>内部会让cancelPromise变为成功，且成功的值为一个cancelPromise</li>
<li>在cancelPromise的成功回调中断请求，并让发请求的promise失败，失败的reason为Cancel对象</li>
</ul>
</li>
</ul>
<h1 id="%E5%8D%81-es6%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93">十 ES6增加的内容总结</h1>
<h2 id="1-%E7%B1%BB%E7%9A%84%E6%96%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F">1. 类的新的定义方式</h2>
<h3 id="11-class">1.1. class</h3>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>(a, b) {
      <span class="hljs-keyword">this</span>.x = a;
      <span class="hljs-keyword">this</span>.y = b;
    }

    gimmeXY() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x * <span class="hljs-keyword">this</span>.y;
    }
  }
</div></code></pre>
<ul>
<li>class Foo表明创建一个具名函数</li>
<li>constructor为构造函数，在new的时候会执行</li>
<li>类的方法可以使用字面量的简洁语法，<font color='red'>类的方法默认是不可以枚举的</font>。</li>
<li><font color='red'>内部不需要逗号来分割成员</font></li>
</ul>
<h4 id="111-extends%E5%92%8Csuper">1.1.1. extends和super</h4>
<h5 id="1111-extends">1.1.1.1 extends</h5>
<ul>
<li>ES6类通过extends提供了一个语法糖，用来在两个函数原型之间建立[[ Prototype ]]委托链接，被误称为&quot;继承&quot;或表示为&quot;原型继承&quot;</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>{
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>{
    <span class="hljs-comment">// ...</span>
  }
</div></code></pre>
<h5 id="1112-super">1.1.1.2 super</h5>
<ul>
<li>功能与位置有关
<ul>
<li>在构造器中，super表示父类的构造函数（new father())
<ul>
<li>必须在前面进行调用</li>
</ul>
</li>
<li>在方法中，super表示父类的原型father.prototype</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">super</span>();
      <span class="hljs-keyword">this</span>.b = <span class="hljs-number">2</span>;
      <span class="hljs-comment">// super(); 报错，必须放在第一行</span>
    }
  }
</div></code></pre>
<h4 id="112-newtarget">1.1.2 new.target</h4>
<ul>
<li>指向new实际上直接调用的构造器, 与继承无关
<ul>
<li>其他函数的new.target则为undefined</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Func: "</span>, <span class="hljs-keyword">new</span>.target.name)
    }
  }

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">super</span>();
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Func: "</span>, <span class="hljs-keyword">new</span>.target.name)
      <span class="hljs-comment">// super(); 报错，必须放在第一行</span>
    }
  }

  <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Foo();
  <span class="hljs-comment">// Func:  Foo</span>
  <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Bar();
  <span class="hljs-comment">// Func:  Bar</span>
  <span class="hljs-comment">// Func:  Bar</span>
</div></code></pre>
<h4 id="113-static">1.1.3 static</h4>
<ul>
<li>直接定义的函数是连接到函数的原型</li>
<li>static定义的函数并不在类的原型链上，而是在函数构造器之间的双向/并行链上
<ul>
<li>无法通过对象的实例来访问，但可以通过函数名来访问</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">static</span> cool() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"cool"</span>);
    }
    wow() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"wow"</span>)
    }
  };

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-keyword">static</span> awesome() {
      <span class="hljs-keyword">super</span>.cool();
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"awesome"</span>);
    }

    neat() {
      <span class="hljs-keyword">super</span>.wow();
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"neat"</span>);
    }
  }

  Foo.cool(); 
  <span class="hljs-comment">// cool</span>

  Bar.cool();
  <span class="hljs-comment">// cool 访问到的是Foo.cool</span>
  Bar.awesome();
  <span class="hljs-comment">// cool awesome</span>
  <span class="hljs-comment">// 为什么能够访问到？</span>
  <span class="hljs-comment">/*
    static成员能用函数名称访问到，所以访问aewsome
    为什么可以访问super.cool()?
    cool()也是static，可以用函数名访问到
  */</span>
  <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Bar();
  b.neat();
  <span class="hljs-comment">// wow neat</span>

  <span class="hljs-built_in">console</span>.log(b.awesome);
  <span class="hljs-comment">// undefined</span>
  <span class="hljs-built_in">console</span>.log(b.cool)
  <span class="hljs-comment">// undefined</span>
</div></code></pre>
<h2 id="2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">2 块级作用域</h2>
<ul>
<li>{...}代表一个块级作用域</li>
</ul>
<h3 id="21-let">2.1 let</h3>
<h4 id="211-let-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%89%B9%E7%82%B9">2.1.1. let 关键字的特点</h4>
<ul>
<li>块级作用域</li>
<li>不存在变量提升</li>
<li>TDZ错误（暂时性死区错误）</li>
</ul>
<pre class="hljs"><code><div>  {
    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
  }
  <span class="hljs-built_in">console</span>.log(a)    <span class="hljs-comment">// 2</span>
  <span class="hljs-comment">// undefined</span>
  <span class="hljs-comment">// 2</span>
  <span class="hljs-comment">// 1 说明a已经被声明，所以var有变量提升</span>
  <span class="hljs-comment">// 2 说明var不存在块级作用域</span>
  {
    <span class="hljs-built_in">console</span>.log(b);
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 3</span>
  }
    <span class="hljs-built_in">console</span>.log(b)  <span class="hljs-comment">// 4</span>
    <span class="hljs-comment">// Reference Error</span>
    <span class="hljs-comment">// Reference Error</span>
    <span class="hljs-comment">// 3 说明let不存在变量提升，此时为TDZ错误</span>
    <span class="hljs-comment">// 4 说明let为块级作用域，块外无法访问块内的变量定义</span>
</div></code></pre>
<h4 id="212-let-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8Efor">2.1.2 let 关键字与for</h4>
<ul>
<li>在ES6的for循环中，计数变量一般使用let</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> arr = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>;i ++){
    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(i);
    }
  }
  arr[<span class="hljs-number">0</span>]();
  arr[<span class="hljs-number">1</span>]();
  <span class="hljs-comment">// 2 2</span>
  <span class="hljs-keyword">var</span> arr = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>;i ++){
    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(i);
    }
  }
  arr[<span class="hljs-number">0</span>]();
  arr[<span class="hljs-number">1</span>]();
  <span class="hljs-comment">// 0 1</span>
</div></code></pre>
<h3 id="22-const">2.2 const</h3>
<h4 id="221-%E7%89%B9%E7%82%B9">2.2.1 特点</h4>
<ul>
<li>具有块级作用域</li>
<li>没有变量提升</li>
<li>声明常量时必须赋值</li>
<li>常量赋值后，值不能修改
<ul>
<li>基本数据类型
<ul>
<li>字面值不能修改</li>
</ul>
</li>
<li>复合数据类型
<ul>
<li>对应的存储地址不能改，但结构内的内容是可以改的</li>
<li>理解
<ul>
<li>const指的是不能修改内存中对应栈的值，而复杂数据类型中对应栈的值存储的是对应堆中的数据的地址，即数据实际上是存在内存的堆中，所以可以修改，但是复杂数据类型不能重新赋值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="23-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%BE%85%E6%9F%A5%E8%AF%81">2.3 块级作用域函数(有待查证)</h3>
<ul>
<li>在ES6前，函数声明不存在块级作用域</li>
<li>在ES6后，函数的声明具有块级作用域，同时还有变量提升</li>
</ul>
<pre class="hljs"><code><div>  {
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"A"</span>);
    }
    foo();
  }
  foo();
  <span class="hljs-comment">// A</span>
  <span class="hljs-comment">// ReferenceError</span>
</div></code></pre>
<h2 id="3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">3 函数的参数的默认值</h2>
<ul>
<li>在ES6前，函数的参数默认值需要通过||来使得参数取到默认值</li>
<li>使用参数值的注意事项
<ul>
<li>当对应<font color="red">实参为空或者是undefined</font>时，使用默认的参数</li>
<li>当对应的实参为null时，会强制转化为0</li>
</ul>
</li>
<li>函数的参数可以看作一个作用域</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// ES6前</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x, y</span>) </span>{
    x = x != <span class="hljs-literal">undefined</span> ? x : <span class="hljs-number">31</span>;
    y = y != <span class="hljs-literal">undefined</span> ? y : <span class="hljs-number">1</span>;
    <span class="hljs-built_in">console</span>.log(x + y); 
  }
  foo(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>);
  <span class="hljs-comment">// 34</span>
<span class="hljs-comment">// ES6</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x = <span class="hljs-number">31</span>, y = <span class="hljs-number">1</span></span>) </span>{
    <span class="hljs-built_in">console</span>.log(x + y); 
  }
    foo(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>);
  <span class="hljs-comment">// 34</span>
</div></code></pre>
<h2 id="4-%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95">4 对象字面量的扩展</h2>
<ul>
<li><font color="red">注意是用于对象中的属性和方法定义</font></li>
</ul>
<h3 id="41-%E7%AE%80%E6%B4%81%E5%B1%9E%E6%80%A7key%E5%80%BC%E5%92%8Cvalue%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D%E7%9B%B8%E5%90%8C">4.1 简洁属性(key值和value的变量名相同)</h3>
<ul>
<li>前提：key值和value的变量名相同</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>, y = <span class="hljs-number">3</span>;
<span class="hljs-comment">// 非简洁写法：</span>
  <span class="hljs-keyword">var</span> o = {
    <span class="hljs-attr">x</span>: x,
    <span class="hljs-attr">y</span>: y
  }
<span class="hljs-comment">// 间接写法</span>
  <span class="hljs-keyword">var</span> o = {
    x, 
    y
  }

</div></code></pre>
<h3 id="42-%E7%AE%80%E6%B4%81%E6%96%B9%E6%B3%95">4.2 简洁方法</h3>
<ul>
<li>注意：
<ul>
<li>简洁方法对应的是<font color="red">函数未命名的方法</font>，即x,y,z并不是它们函数的名称，而是它们的key值
<ul>
<li>无法直接使用函数名称来进行调用，需要在前面增加对象名或者this进行调用
<ul>
<li>o.x()</li>
<li>this.x()</li>
</ul>
</li>
</ul>
</li>
<li>如果要使用<font color="red">递归</font>的方法，最好采用有有名称函数的调用。</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 老方法</span>
  <span class="hljs-keyword">var</span> o = {
    <span class="hljs-attr">x</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// ...</span>
    },
    <span class="hljs-attr">y</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-attr">z</span>: *<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-comment">// ...</span>
    }
  }
<span class="hljs-comment">// ES6</span>
  <span class="hljs-keyword">var</span> o = {
    x() {
      <span class="hljs-comment">// ...</span>
    },
    y() {
      <span class="hljs-comment">// ...</span>
    }
    * z() {
      <span class="hljs-comment">// ...</span>
    }<span class="hljs-comment">//生成器</span>
  }
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> o = {
    <span class="hljs-attr">x</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params">val</span>) </span>{
      <span class="hljs-keyword">if</span>(val &lt; <span class="hljs-number">0</span>) 
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> val + x(val - <span class="hljs-number">1</span>)
      }
    } 
  }
  <span class="hljs-comment">// 函数内的x函数指的就是本身</span>
</div></code></pre>
<h3 id="43-%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%90%8D">4.3 使用计算属性名</h3>
<ul>
<li>在ES6以前，若想要以一个计算属性名作为key，则需要单独累出</li>
<li>ES6提供了可以在对象字面量内部使用定义计算属性名
<ul>
<li>[]内部使用计算表达式作为属性值，也可以是计算属性值([ Symbol.iterator ])</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// ES6之前</span>
  <span class="hljs-keyword">var</span> prefix = <span class="hljs-string">"user_"</span>;
  <span class="hljs-keyword">var</span> o = {
  <span class="hljs-attr">baz</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>)</span>{ .. }
  };
  o[ prefix + <span class="hljs-string">"foo"</span> ] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>)</span>{ .. };
  o[ prefix + <span class="hljs-string">"bar"</span> ] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>)</span>{ .. };
<span class="hljs-comment">// ES6</span>
  <span class="hljs-keyword">var</span> prefix = <span class="hljs-string">"user_"</span>;
  <span class="hljs-keyword">var</span> o = {
  <span class="hljs-attr">baz</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>)</span>{ .. },
    [ prefix + <span class="hljs-string">"foo"</span> ]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>)</span>{ .. },
    [ prefix + <span class="hljs-string">"bar"</span> ]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>)</span>{ .. }
  }; 
</div></code></pre>
<h3 id="44-%E5%85%B3%E8%81%94%E5%8E%9F%E5%9E%8B">4.4 关联原型</h3>
<ul>
<li>Object.setPrototypeOf(son, father)
<ul>
<li>使得son的原型为father</li>
<li><a href="#event-assignment">用于事件的委派 </a></li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> o1 = {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-keyword">var</span> o2 = {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-built_in">Object</span>.setPrototypeOf(o2, o1);
  <span class="hljs-comment">// o2.__proto__ = o1 类似于o1将事件委托给了o2</span>
</div></code></pre>
<h3 id="45-super%E5%AF%B9%E8%B1%A1">4.5 super对象</h3>
<ul>
<li>super对象<font color="red">只允许在简洁方法中出现</font>，而不允许在普通函数表达式中出现
<ul>
<li>super代指原型链的对象，常用于调用原型链中的函数（同名或者非同名）</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> o1 = {
    foo() {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"o1.foo"</span>);
    };
  }
  <span class="hljs-keyword">var</span> o2 = {
    foo() {
      <span class="hljs-keyword">super</span>.foo();
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"o2.foo"</span>);
    }
  }
</div></code></pre>
<h2 id="5-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">5 解构赋值</h2>
<ul>
<li>方便从数组，对象中提取值</li>
<li><font color="red">特征</font>
<ul>
<li>数组或对象的字面量写在赋值函数的前面（左边）</li>
<li>数组或��象的字面量作为形参</li>
</ul>
</li>
</ul>
<h3 id="51-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84">5.1 数组解构</h3>
<ul>
<li>变量的位置和数组值的位置一一对应</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
  <span class="hljs-keyword">let</span> [a, b, c] = arr;
  <span class="hljs-comment">// 1， 3，4</span>
</div></code></pre>
<h3 id="52-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84">5.2 对象解构</h3>
<ul>
<li>从被解构对象中找到与key值相匹配的value值，并进行赋值</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 简洁属性的方法</span>
  <span class="hljs-keyword">let</span> person = {<span class="hljs-attr">name</span>: <span class="hljs-string">"bulumrcai"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">175</span>}
  <span class="hljs-keyword">let</span> {age, name, height} = person;
  <span class="hljs-comment">//age 23 name bulumrcai height 175</span>

<span class="hljs-comment">// 正常匹配的方法</span>
  <span class="hljs-keyword">let</span> person = {<span class="hljs-attr">name</span>: <span class="hljs-string">"bulumrcai"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">175</span>}
  <span class="hljs-keyword">let</span> {<span class="hljs-attr">name</span>: myname} = person;
  <span class="hljs-comment">// myname: bulumrcai</span>
  <span class="hljs-comment">// myname实际上是类似于重新命名为。。。</span>
</div></code></pre>
<h3 id="53-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95">5.3 解构赋值的两种写法</h3>
<h4 id="531-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E7%9A%84%E5%8F%98%E9%87%8F%E6%9C%AA%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E6%9C%AA%E5%A3%B0%E6%98%8E">5.3.1 用于解构的变量未声明变量未声明</h4>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
  <span class="hljs-keyword">let</span> [a, b, c] = arr;

  <span class="hljs-keyword">let</span> person = {<span class="hljs-attr">name</span>: <span class="hljs-string">"bulumrcai"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">175</span>}
  <span class="hljs-keyword">let</span> {age, name, height} = person;
</div></code></pre>
<h4 id="532-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E7%9A%84%E5%8F%98%E9%87%8F%E5%B7%B2%E7%BB%8F%E5%A3%B0%E6%98%8E%E5%89%8D%E9%9D%A2%E6%97%A0%E9%9C%80%E5%8A%A0%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B">5.3.2 用于解构的变量已经声明(前面无需加声明类型)</h4>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> a, b,c;
  <span class="hljs-keyword">let</span> arr =[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
  [a, b, c] = arr;

  <span class="hljs-keyword">let</span> myName;
  <span class="hljs-keyword">let</span> person = {<span class="hljs-attr">name</span>: <span class="hljs-string">"bulumrcai"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">175</span>};
  {<span class="hljs-attr">name</span>: myName} = person;
</div></code></pre>
<h3 id="54-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F">5.4 用于解构变量的数量</h3>
<ul>
<li>太少</li>
<li>刚刚好</li>
<li>太多
<ul>
<li>多出的变量会被赋值为undefined</li>
</ul>
</li>
</ul>
<h3 id="55-%E9%87%8D%E5%A4%8D%E8%B5%8B%E5%80%BC">5.5 重复赋值</h3>
<ul>
<li>当对象出现复数个相同的key值，会对用于解构的变量赋值</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> a = {<span class="hljs-attr">b</span>: <span class="hljs-number">4</span>};
  <span class="hljs-keyword">var</span> {<span class="hljs-attr">b</span>: c, <span class="hljs-attr">b</span>: d} = a;
  <span class="hljs-built_in">console</span>.log(c, d);
  <span class="hljs-comment">// 4 4</span>
</div></code></pre>
<h3 id="56-%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0%E5%BD%93%E6%95%B0%E7%BB%84%E6%88%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82">5.6 解构参数（当数组或对象的字面量作为形参）</h3>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f3</span>(<span class="hljs-params">[ x, y, ...z], ...w</span>) </span>{
    <span class="hljs-built_in">console</span>.log( x, y, z, w );
  }
  f3( [] ); <span class="hljs-comment">// undefined undefined [] []</span>
  f3( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ); <span class="hljs-comment">// 1 2 [3,4] [5,6]</span>
</div></code></pre>
<h3 id="57-%E7%94%A8%E4%BA%8E%E8%A7%A3%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">5.7 用于解构变量的默认值</h3>
<p>当对应的参数的值为undefined时，会使用默认的参数</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>];
  <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  <span class="hljs-keyword">var</span> [a = <span class="hljs-number">3</span>, b = <span class="hljs-number">6</span>, c = <span class="hljs-number">9</span>, d = <span class="hljs-number">12</span> ] = arr1;
  <span class="hljs-keyword">var</span> [ x = <span class="hljs-number">5</span>, y = <span class="hljs-number">10</span>, z = <span class="hljs-number">15</span>, w = <span class="hljs-number">20</span>] = arr2;
  <span class="hljs-built_in">console</span>.log(a, b, c, d);
  <span class="hljs-built_in">console</span>.log(x, y, z, w);
  <span class="hljs-comment">//  1 2 3 12 </span>
  <span class="hljs-comment">// 4 5 6 20</span>
</div></code></pre>
<h4 id="571-%E8%A7%A3%E6%9E%84%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%BD%A2%E5%8F%82%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E9%9A%BE%E7%82%B9">5.7.1 解构的默认值和形参的默认值（难点）</h4>
<ul>
<li><font color="red">根据触发填充默认值的条件进行区分</font>
<ul>
<li>解构的默认值：
<ul>
<li>当被解构的数组/对象中没有相应值触发</li>
</ul>
</li>
<li>形参的默认值：
<ul>
<li>当形参为空或者为undefined触发</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f6</span>(<span class="hljs-params">{ x = <span class="hljs-number">10</span> } = {}, { y } = { y: <span class="hljs-number">10</span> }</span>) </span>{
    <span class="hljs-built_in">console</span>.log( x, y );
  }
  f6(); 
  <span class="hljs-comment">/**
    * 没有传入参数，则使用形参的默认值即
    * {x = 10} = {}, {y} = {y: 10}
    * 从{}无法找到x对应的value值，所以使用解构的默认值即x = 10
    * {y: 10}找到y对应的值，所以y=10
  */</span>
  f6( {}, {} ); 
  <span class="hljs-comment">/**
    * 传入参数{}，{}
    * {x = 10} = {}, {y} = {}
    * 从{}无法找到x对应的value值，所以使用解构的默认值即x = 10
    * {}无法找到y对应的值，又没有解构的默认值，所以y=undefined
  */</span>

</div></code></pre>
<h3 id="58-%E4%B8%8E%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95%E7%9A%84%E7%BB%93%E5%90%88%E5%BA%94%E7%94%A8">5.8 与其他用法的结合应用</h3>
<ul>
<li>使用实现不使用临时变量使两个变量的值交换</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>, y = <span class="hljs-number">20</span>;
  [y, x] = [x, y];
  <span class="hljs-comment">// 解释</span>
  <span class="hljs-comment">// 赋值表达式右边先执行，则有新构建一个数组[10, 20];</span>
  <span class="hljs-comment">// 左边为数组的形式，显然使用了数组的解构，所以对应位置被赋予对对应的值，即</span>
  <span class="hljs-comment">// y = 10, x = 20;</span>
</div></code></pre>
<ul>
<li>与扩展运算符结合实现截取数组</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]
  <span class="hljs-keyword">var</span> [,,...b] = a;
  <span class="hljs-built_in">console</span>.log(b);
  <span class="hljs-comment">// [4, 6, 7]</span>
</div></code></pre>
<h2 id="6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">6 展开运算符（...)</h2>
<ul>
<li>...后面跟上的实际上不是一个数组，<font color>而是一个iterable类型的变量</font>
<ul>
<li>...后面跟上array类型时，实际上数组要先做一步处理
<ul>
<li>arr[Symbol.iterator]()，利用生成器函数来生成对应的iterable变量</li>
</ul>
</li>
</ul>
</li>
<li>rest/spread --&gt; 展开/收集运算符</li>
</ul>
<h3 id="61--%E7%94%A8%E4%BA%8Eiteratble%E5%89%8D%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">6.1 ... 用于iteratble前(展开运算符)</h3>
<ul>
<li>实际上是iterable类型,作用是将变量展开为各个独立的值
<ul>
<li>...[1,2,4] =&gt; 1, 2, 4</li>
</ul>
</li>
<li>作用
<ul>
<li>用于实参的输入</li>
<li>用于合并数组(基本代替了concat函数的作用)</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 用于合并数组</span>
  <span class="hljs-keyword">var</span> a = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
  <span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>, ...a, <span class="hljs-number">5</span>];
  <span class="hljs-built_in">console</span>.log(b);
  <span class="hljs-comment">// [1, 2, 3 ,4 ,5]</span>
</div></code></pre>
<h3 id="62-%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E4%B8%AD%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0">6.2 ...用于函数的形参中（剩余参数）</h3>
<ul>
<li>这种参数被称为剩余参数,对应变量的<font color="red">返回值是一个真正的数组</font>
<ul>
<li>用于替代arguments（类数组），而...后面的形参为真正的数组</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 作为剩余参数，且剩余参数为真正的数组</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-keyword">let</span> res = args.reduce(<span class="hljs-function">(<span class="hljs-params">preValue, value</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> preValue + value;
    }, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> res;
  }

<span class="hljs-comment">// 用于实参的输入</span>
  <span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
  <span class="hljs-built_in">console</span>.log(sum(...a));
  <span class="hljs-comment">// 15</span>
</div></code></pre>
<ul>
<li>允许我们讲一个不定数量的参数以数组的形式传递给函数</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">...argv</span>) </span>{
    <span class="hljs-keyword">return</span> argv.reduce(<span class="hljs-function">(<span class="hljs-params">preValue, curValue</span>) =&gt;</span> preValue + curValue, <span class="hljs-number">0</span>);
  }
  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>))
  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))
  <span class="hljs-comment">// 4, 7</span>
</div></code></pre>
<ul>
<li>剩余参数和解构赋值配合使用</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
  <span class="hljs-keyword">const</span> [arvg, ...list] = arr;
  <span class="hljs-built_in">console</span>.log(arvg, list)
  <span class="hljs-comment">// 1, [3, 4, 5]</span>
</div></code></pre>
<h2 id="7-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F">7 模板字面量</h2>
<ul>
<li>返回值是一个字符串</li>
<li>利用``作为界定符声明字符串的字面量</li>
<li>优点</li>
<li>可以分散在<font color="red">多行</font>进行字符串字面量的定义</li>
<li>字面量中字符串的<font color="red">换行符会被保留</font></li>
</ul>
<h3 id="71-%E6%8F%92%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F">7.1 插入字符串字面量</h3>
<ul>
<li>可以在字面量中增加${js表达式} --- 插入表达式
<ul>
<li>会返回当中js表达式的返回值，并将对应的返回值加入到字符串之中</li>
<li>js表达式可以是函数的调用，在线函数表达式调用，设置插入字符串的字面量</li>
</ul>
</li>
<li>${js表达式}的作用域
<ul>
<li>对应的词法作用域</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upper</span>(<span class="hljs-params">s</span>) </span>{
    <span class="hljs-keyword">return</span> s.toUpperCase();
  }
  <span class="hljs-keyword">var</span> who = <span class="hljs-string">"reader"</span>;
  <span class="hljs-keyword">var</span> text = <span class="hljs-string">`
  A very <span class="hljs-subst">${upper(<span class="hljs-string">"warm"</span>)}</span> welcome 
  to all of you <span class="hljs-subst">${upper(<span class="hljs-string">`<span class="hljs-subst">${who}</span>s`</span>)}</span>!
  `</span>
  <span class="hljs-built_in">console</span>.log(text);
  <span class="hljs-comment">/*

  A very WARM welcome 
  to all of you READERS!

  */</span>
</div></code></pre>
<h3 id="72-%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F">7.2. 标签模板字面量</h3>
<ul>
<li><span id="template-call">一种特殊的函数调用形式</a></li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcName</span>(<span class="hljs-params">strings, ...values</span>) </span>{
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-comment">// 函数调用</span>
  funcName<span class="hljs-string">`...`</span> 
</div></code></pre>
<ul>
<li>funcName<code>...</code>
<ul>
<li>一种特殊的函数调用
<ul>
<li>不需要()，而是``进行函数的调用</li>
</ul>
</li>
</ul>
</li>
<li>参数
<ul>
<li>strings: 由普通的字符串组成的数组，得到的是<font color="red">以插入表达式分割</font>的字符</li>
<li>...values: 由插入表达式结果组成的数组</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">strings, ...values</span>) </span>{
    <span class="hljs-built_in">console</span>.log(strings);
    <span class="hljs-built_in">console</span>.log(values);
  }

  <span class="hljs-keyword">var</span> desc = <span class="hljs-string">"awesome"</span>;

  foo<span class="hljs-string">`Everything is <span class="hljs-subst">${desc}</span>!`</span>;

</div></code></pre>
<ul>
<li>常用于对模板字面量所组成的字符串进行改造</li>
<li>用于将字符串中的数字改造成美元</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dollabillsyall</span>(<span class="hljs-params">strings, ...values</span>) </span>{
    <span class="hljs-keyword">return</span> strings.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">preValue, currentValue, index</span>) </span>{
      <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> values[index - <span class="hljs-number">1</span>] === <span class="hljs-string">"number"</span>) {
          preValue += <span class="hljs-string">`$<span class="hljs-subst">${values[index<span class="hljs-number">-1</span>].toFixed(<span class="hljs-number">2</span>)}</span>`</span>;
        }
        <span class="hljs-keyword">else</span> {
          preValue += values[index];
        }
      }
      <span class="hljs-keyword">return</span> preValue + currentValue;
    }, <span class="hljs-string">""</span>)
  }

  <span class="hljs-keyword">var</span> amt1 = <span class="hljs-number">11.99</span>, amt2 = amt1 * <span class="hljs-number">1.08</span>, name = <span class="hljs-string">"Kyle"</span>;
  <span class="hljs-keyword">var</span> text = dollabillsyall
  <span class="hljs-string">`Thanks for you purchase, <span class="hljs-subst">${name}</span>! your
  product cost was <span class="hljs-subst">${amt1}</span>, which with tax 
  comes out <span class="hljs-subst">${amt2}</span>
  `</span>
  <span class="hljs-built_in">console</span>.log(text)
  <span class="hljs-comment">/*
  Thanks for you purchase, 11.99! your
  product cost was $11.99, which with tax 
  comes out $12.95
  */</span>
</div></code></pre>
<h3 id="73-raw%E5%AD%97%E7%AC%A6%E4%B8%B2">7.3. raw字符串</h3>
<ul>
<li>在参数strings返回的数组中，该数组有一个属性raw
<ul>
<li>原始数据，即其中的换行符等是以转义的形式表示出来，而不是被视为一个换行符</li>
</ul>
</li>
<li>String.raw(strings, ...values)
<ul>
<li>js提供了一个模板字符串函数</li>
<li>返回一个转义字符没有被变成相应格式的原始字符串</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-built_in">String</span>.raw<span class="hljs-string">`...`</span>
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>.raw<span class="hljs-string">`hello\nworld`</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`hello\nworld`</span>)
  <span class="hljs-comment">/*
    hello\nworld
    hello
    world
  */</span>
  
</div></code></pre>
<h2 id="8-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">8  箭头函数</h2>
<pre class="hljs"><code><div>  (argv1, argv2...) =&gt; {};
  <span class="hljs-comment">// 相当于</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">argv1, argv2...</span>) </span>{};
</div></code></pre>
<ul>
<li>通常会把箭头函数赋值给一个变量，然后再进行调用</li>
<li>特点
<ul>
<li>当函数没有返回值的时候，会默认返回undefined</li>
</ul>
</li>
<li>目的
<ul>
<li>简化匿名函数定义的语法</li>
</ul>
</li>
</ul>
<h3 id="81-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99">8.1 箭头函数的特殊规则</h3>
<h4 id="811-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">8.1.1 只有一个变量</h4>
<ul>
<li>括号可以省略</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {<span class="hljs-built_in">console</span>.log(value)}
</div></code></pre>
<h4 id="812-%E5%8F%AA%E6%9C%89%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81">8.1.2. 只有一行代码</h4>
<ul>
<li>大括号可以省略</li>
<li>并默认返回对应表达式的执行结果：如布尔表达式则返回true或false</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value &gt; <span class="hljs-number">100</span>;
</div></code></pre>
<h3 id="82-%E7%AE%AD%E5%A4%B4this%E6%8C%87%E5%90%91">8.2 箭头this指向</h3>
<ul>
<li>箭头函数不绑定this，this关键字将指向定义位置中的this
<ul>
<li>能产生局部作用域的函数中定义</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  obj = {<span class="hljs-attr">name</span>: <span class="hljs-string">"bulumrcai"</span>};
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>)
  }

  <span class="hljs-keyword">const</span> fun = fn.call(obj);
  fun();
  <span class="hljs-comment">// obj obj</span>

</div></code></pre>
<ul>
<li>在不能产生局部作用域的对象定义(this并不是指向对象的this)</li>
</ul>
<pre class="hljs"><code><div>  obj = {
          <span class="hljs-attr">name</span>: <span class="hljs-string">"bulumrcai"</span>
          <span class="hljs-attr">sayhello</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>(<span class="hljs-keyword">this</span>.age)
        };
  <span class="hljs-comment">// undefined this指向的是window</span>
</div></code></pre>
<h3 id="83-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">8.3 箭头函数的应用注意事项</h3>
<ul>
<li>用于使代码更短，对于长的代码，不要考虑使用箭头函数</li>
</ul>
<h2 id="9-forof%E5%BE%AA%E7%8E%AF">9 for...of...循环</h2>
<ul>
<li>of后面的参数是iterable</li>
<li>默认具有iterable的内置对象</li>
<li>Array, String, Generator, collection, typedArray</li>
</ul>
<h3 id="91-forof%E5%92%8Cforin%E7%9A%84%E5%8C%BA%E5%88%AB">9.1 for...of和for...in...的区别</h3>
<ul>
<li>for...of...为变量赋的值是value</li>
<li>for...in...为变量赋的值是index</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> a = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>];

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> a) {
    <span class="hljs-built_in">console</span>.log(val);
  }
  <span class="hljs-comment">// a b c d e</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> a) {
    <span class="hljs-built_in">console</span>.log(index);
  }
  <span class="hljs-comment">// 0 1 2 3 4</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// for...of... 等价代码</span>
  <span class="hljs-keyword">var</span> a = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>];

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> val, ret, it = a[<span class="hljs-built_in">Symbol</span>.iterator]();(ret = it.next()) &amp;&amp; !ret.done;) {
    val = ret.value;
    <span class="hljs-built_in">console</span>.log( val )
  }
</div></code></pre>
<h2 id="10-%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%8B%93%E5%B1%95">10 数字字面量的拓展</h2>
<ul>
<li>0b  二进制</li>
<li>0o  八进制</li>
<li>0x  十六进制</li>
<li>.toString(radix)
<ul>
<li>转化为对应进制的字符串</li>
</ul>
</li>
</ul>
<h2 id="11-unicode%E7%BC%96%E7%A0%81%E5%90%8E%E9%9D%A2%E5%86%8D%E8%A1%A5%E5%85%85">11 Unicode编码（后面再补充）</h2>
<h2 id="12-%E7%AC%A6%E5%8F%B7symbol">12 符号（symbol）</h2>
<h3 id="121-symbol%E7%9A%84%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89">12.1 symbol的创建(自定义)</h3>
<ul>
<li><font color="red">不需要使用new符号</font>。不是一个构造器，也不会创建一个对象</li>
<li>与string，number等方法类似</li>
</ul>
<h3 id="122-symbol%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">12.2 symbol常用的方法</h3>
<h4 id="1221-typeof">12.2.1 typeof</h4>
<ul>
<li>返回值为symbol</li>
</ul>
<h4 id="1222-instanceof">12.2.2 instanceof</h4>
<ul>
<li>与string，number的字面量不是对应String, Number的实例一样，symbol也不是Symbol的实例</li>
<li>返回值为false</li>
</ul>
<h4 id="1223-valueof">12.2.3 valueOf</h4>
<ul>
<li>返回symbol字面量</li>
</ul>
<h4 id="1224-symboltostring">12.2.4 Symbol#toString</h4>
<ul>
<li>返回相应的symbol的字符串格式</li>
</ul>
<h4 id="1225-symbolfordesc">12.2.5 Symbol.for(desc)</h4>
<ul>
<li>在全局符号注册表中搜索，如果有描述文字相同的符号，则返回该symbol</li>
<li>若没有，则新建一个该desc的符号，并且返回</li>
</ul>
<h4 id="1226-symbolkeyforsymbol">12.2.6 Symbol.keyFor(symbol)</h4>
<ul>
<li>提取符号的注册文本的描述(desc)</li>
</ul>
<h3 id="123-%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%BA%94%E7%94%A8">12.3 符号的应用</h3>
<h4 id="12231-%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%B3%A8%E5%86%8C">12.2.3.1 符号的注册</h4>
<ul>
<li>符号一般是进行全局注册
<ul>
<li>可以通过Symbol.for的方法确定唯一性desc</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> evet = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">"event"</span>);
  <span class="hljs-comment">// 在全局符号注册表中搜索，如果有描述文字相同的符号，则返回该symbol</span>
  <span class="hljs-comment">// 若没有，则新建一个该desc的符号，并且返回</span>
</div></code></pre>
<h4 id="12232-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AC%A6%E5%8F%B7">12.2.3.2 作为对象属性的符号</h4>
<ul>
<li>会用一种特殊的方式存储，使得这个属性<font color="red">不出现在这个对象的一般枚举属性之中</font></li>
<li>需要使用Object.getPropertySymbols(obj)才能取得对应的符号属性</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> o = {
    <span class="hljs-attr">foo</span>: <span class="hljs-number">42</span>,
    [ <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"bar"</span>) ]: <span class="hljs-string">"hello world"</span>,
    <span class="hljs-attr">baz</span>: <span class="hljs-literal">true</span>
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyNames( o ));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols( o ));
</div></code></pre>
<h4 id="12233-%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7">12.2.3.3 内置符号</h4>
<ul>
<li>iterator
<ul>
<li>Array</li>
<li>在表示时@@iterator来指代内置的符号</li>
</ul>
</li>
</ul>
<h2 id="13-map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">13 Map数据结构</h2>
<ul>
<li>为什么要使用Map数据结构
<ul>
<li>对象只能使用字符串作为键，而Map实现了可以使用任意的变量作为键
<ul>
<li>无法用[]的形式进行访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="131-map%E7%9A%84%E6%9E%84%E9%80%A0">13.1 Map的构造</h3>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(obj);
</div></code></pre>
<ul>
<li>obj
<ul>
<li>为空</li>
<li>为一个iterable,正好是entries的返回值，格式和下面的数组一样</li>
<li>为一个数组  [ [key, value], [ key,value ]]</li>
<li>为一个Map</li>
</ul>
</li>
</ul>
<h3 id="132-map%E7%9A%84%E6%96%B9%E6%B3%95">13.2 Map的方法</h3>
<h4 id="1321-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">13.2.1 增删改查</h4>
<h5 id="13211-mapsetkey-value">13.2.1.1 Map#set(key, value)</h5>
<ul>
<li>给Map对象添加/修改相应的键值</li>
</ul>
<h5 id="13212-mapdeletekey">13.2.1.2 Map#delete(key)</h5>
<ul>
<li>删除Map对象中对应的键</li>
</ul>
<h5 id="13213-mapclearkey">13.2.1.3 Map#clear(key)</h5>
<ul>
<li>清空Map对象中的键</li>
</ul>
<h5 id="13214-maphaskey">13.2.1.4 Map#has(key)</h5>
<ul>
<li>返回boolean，判断是否有给定的键</li>
</ul>
<h5 id="13215-mapgetkey">13.2.1.5 Map#get(key)</h5>
<ul>
<li>返回key对应的value值</li>
</ul>
<h4 id="1322-mapsize">13.2.2 Map#size()</h4>
<ul>
<li>返回Map对象的大小</li>
</ul>
<h4 id="1323-mapentries">13.2.3 Map#entries()</h4>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Map#entries() ]为数组后的格式为 [ [key, value], [ key,value ]]</li>
</ul>
</li>
</ul>
<h4 id="1324-mapvalues">13.2.4 Map#values()</h4>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Map#entries() ]为数组后的格式为 [ value1, value2...]</li>
</ul>
</li>
</ul>
<h4 id="1325-mapkeys">13.2.5 Map#keys()</h4>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Map#entries() ]为数组后的格式为 [ key1, key2...]</li>
</ul>
</li>
</ul>
<h3 id="133-weakmap%E6%96%B9%E6%B3%95">13.3 WeakMap方法</h3>
<ul>
<li>用法类似于Map</li>
<li>区别
<ul>
<li>只有增改查和大小的操作，不能机型删除，暴露key，value等操作</li>
</ul>
</li>
<li>优势</li>
</ul>
<h2 id="14-set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">14 Set数据结构</h2>
<ul>
<li>Set的唯一性使得内部元素不能进行类型转化来判断是否相等。</li>
</ul>
<h3 id="141-set%E7%9A%84%E6%9E%84%E9%80%A0">14.1. Set的构造</h3>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span> = new Set(obj)
</div></code></pre>
<ul>
<li>obj
<ul>
<li>obj可以为空</li>
<li>可以是一个iterator</li>
<li>可以是一个数组</li>
<li>可以是一个set对象实例</li>
</ul>
</li>
</ul>
<h3 id="142-set%E7%9A%84%E6%96%B9%E6%B3%95">14.2. Set的方法</h3>
<h4 id="1421-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">14.2.1 增删改查</h4>
<h5 id="14211-setaddkey-value">14.2.1.1 Set#add(key, value)</h5>
<ul>
<li>给Map对象添加/修改相应的键值</li>
</ul>
<h5 id="14212-setdeletekey">14.2.1.2 Set#delete(key)</h5>
<ul>
<li>删除Map对象中对应的键</li>
</ul>
<h5 id="14213-setclearkey">14.2.1.3 Set#clear(key)</h5>
<ul>
<li>清空Map对象中的键</li>
</ul>
<h5 id="14214-sethaskey">14.2.1.4 Set#has(key)</h5>
<ul>
<li>返回boolean，判断是否有给定的键</li>
</ul>
<h4 id="1422-setsize">14.2.2 Set#size()</h4>
<ul>
<li>返回Set的大小</li>
</ul>
<h4 id="1423-setentries">14.2.3 Set#entries()</h4>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Set#entries() ]为数组后的格式为 [ [value1, value1], [ value2,value2] ]</li>
</ul>
</li>
</ul>
<h4 id="1424-setkeys">14.2.4 Set#keys()</h4>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Set#keys() ]为数组后的格式为 [value1, value2...]</li>
</ul>
</li>
</ul>
<h4 id="1425-setvalues">14.2.5 Set#values()</h4>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Set#values() ]为数组后的格式为 [value1, value2...]</li>
</ul>
</li>
</ul>
<h2 id="15-array%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">15 Array的扩展方法</h2>
<h3 id="151-arrayof">15.1. Array.of()</h3>
<ul>
<li>成为数组推荐的函数形式构造器
<ul>
<li>解决了单个参数导致只有长度而没有赋值的情况</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.of(obj)
</div></code></pre>
<ul>
<li>obj
<ul>
<li>...val: 任意数量的参数</li>
<li>array</li>
</ul>
</li>
</ul>
<h3 id="152-arrayfromarraylikefunc">15.2. Array.from(arraylike,func?)</h3>
<ul>
<li>将iterable或者是类数组转化为数组
<ul>
<li>返回一个数组</li>
</ul>
</li>
<li>func可以对数组中的元素进行处理
<ul>
<li>类似于map的用法</li>
</ul>
</li>
<li>优点
<ul>
<li>避免空槽
<ul>
<li>空白的地方会自动填充undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">let</span> arraylike = {
    <span class="hljs-string">'0'</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-string">'1'</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>
  }

  <span class="hljs-comment">// ES6以前，调用数组的赋值操作</span>
  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arraylike);
  <span class="hljs-keyword">const</span> arr = [].slice.call(arraylike)
  <span class="hljs-comment">// ES6</span>
  <span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(arrayLike);
  <span class="hljs-built_in">console</span>.log(arr);
<span class="hljs-comment">// [a, b]</span>
</div></code></pre>
<h3 id="153-arrayfrom%E5%92%8Carrayof%E5%AF%B9%E4%BA%8E%E5%AD%90%E7%B1%BB%E7%9A%84%E5%BD%B1%E5%93%8D">15.3. Array.from和Array.of对于子类的影响</h3>
<ul>
<li>可以通过extends来继承Array</li>
<li>from, of都是用访问它的构造器来构造数组</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
    <span class="hljs-comment">// ...</span>
  }

  MyArray.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">instanceof</span> MyArray; <span class="hljs-comment">// true</span>
  MyArray.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>;  <span class="hljs-comment">// true</span>

  <span class="hljs-built_in">Array</span>.of(MyArray.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)) <span class="hljs-keyword">instanceof</span> MyArray <span class="hljs-comment">// false</span>
</div></code></pre>
<h3 id="154-arraycopywithintarget-start-end">15.4. Array#copyWithin(target, start[, end])</h3>
<ul>
<li>不会增加数组的长度，到达数组结尾复制就会停止</li>
<li>当target &gt; start时，赋值算法会反向进行</li>
<li>当为负数的时候，相当于倒序(最后一个的下标为-1)</li>
<li>返回一个被自身数据替换的数组</li>
<li>参数
<ul>
<li>target 要复制到的索引</li>
<li>start 开始复制的索引（包括）</li>
<li>end 赋值结束的索引（不包括）</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
  <span class="hljs-comment">// [1, 2, 3, 1, 5]</span>
  <span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">3</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>));
  <span class="hljs-comment">// [1, 2, 3, 3, 5]</span>
  <span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].copyWithin(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));
  <span class="hljs-comment">// [1, 2, 2, 3, 4]</span>
  <span class="hljs-comment">// 反向赋值，保证不是[1, 2, 2, 2, 2]</span>
</div></code></pre>
<h3 id="155-arrayfillvalue-start-end">15.5. Array#fill(value[, start, end])</h3>
<ul>
<li>返回一个被填充了相应val的数组</li>
<li>若只有参数value，则默认全部填充为value</li>
<li>参数
<ul>
<li>val 要填充的值
<ul>
<li>若只有一个参数，则默认填充全部</li>
</ul>
</li>
<li>start 填充的开始索引（包括）</li>
<li>end 填充的结束索引（不包括）</li>
</ul>
</li>
<li>常用于初始化</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>).fill(<span class="hljs-number">0</span>);
  <span class="hljs-built_in">console</span>.log(arr)
  <span class="hljs-comment">// 全部被填充为0</span>
</div></code></pre>
<h3 id="156-arrayfindfunc">15.6. Array#find(func)</h3>
<ul>
<li>返回一个自定义是否匹配的值</li>
<li>func
<ul>
<li>返回值是布尔值，当为true时，find会返回相应的value</li>
</ul>
</li>
</ul>
<h3 id="157-arrayfindindexfunc">15.7. Array#findIndex(func)</h3>
<ul>
<li>为什么不适用Array#indexOf(val)
<ul>
<li>Array#indexOf(val)是不改变类型的进行比较</li>
<li>findIndex由于func的缘故可以自定义的进行比较</li>
</ul>
</li>
<li>返回一个自定义的匹配索引</li>
<li>func
<ul>
<li>返回值是布尔值，当为true时，find会返回相应的index</li>
</ul>
</li>
<li>Array#indexOf(value)
<ul>
<li>若找到对应的值，则返回相应的索引</li>
<li>没有找到则返回-1</li>
<li><font color="red">采用的是严格匹配===</font></li>
</ul>
</li>
<li>需要严格匹配则使用Array#indexOf</li>
</ul>
<h3 id="158-arrayentries">15.8. Array#entries()</h3>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Set#values() ]为数组后的格式为 [[index , value], [index , value]...]</li>
</ul>
</li>
</ul>
<h3 id="159-arraykeys">15.9. Array#keys()</h3>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Set#values() ]为数组后的格式为 [value1, value2...]</li>
</ul>
</li>
</ul>
<h3 id="1510-arrayvalues">15.10. Array#values()</h3>
<ul>
<li>返回一个iterator
<ul>
<li>经过展开后:[ ...Set#values() ]为数组后的格式为 [0, 1...]</li>
</ul>
</li>
</ul>
<h2 id="16-object%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">16. Object的扩展方法</h2>
<h3 id="161-objectis">16.1. Object.is()</h3>
<ul>
<li>执行比===更严格的值比较</li>
<li>常用于区分
<ul>
<li>NaN</li>
<li>+/- 0</li>
</ul>
</li>
</ul>
<h3 id="162-objectgetpropertysymbolsobj">16.2. Object.getPropertySymbols(obj)</h3>
<ul>
<li>获得obj中的不可枚举的symbol的数组</li>
</ul>
<h3 id="163-objectsetprototypeofson-father">16.3. Object.setPrototypeOf(son, father)</h3>
<ul>
<li>一般用于行为委托</li>
</ul>
<h3 id="164-objectassigntarget-source">16.4. Object.assign(target, ...source)</h3>
<ul>
<li>返回一个浅复制的对象</li>
<li>target对象创建source相应的键，然后赋值为source中对应的值</li>
</ul>
<h2 id="17-number%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">17. Number的扩展方法</h2>
<h3 id="171-numberepsilon">17.1 Number.EPSILON</h3>
<ul>
<li>任意两个值之间的最小差2^-52，常用于极小值的判断</li>
</ul>
<h3 id="172-numbermaxsafeinteger">17.2 Number.MAX_SAFE_INTEGER</h3>
<ul>
<li>安全的无歧义的最大整数:2^53 - 1</li>
</ul>
<h3 id="173-numberminsafeinteger">17.3 Number.MIN_SAFE_INTEGER</h3>
<ul>
<li>安全的无歧义的最小整数:-(2^-53 - 1)</li>
</ul>
<h3 id="174-numberisnanval">17.4 Number.isNaN(val)</h3>
<ul>
<li>用于判断是不是为NaN值</li>
</ul>
<h3 id="175-numberisfiniteval">17.5 Number.isFinite(val)</h3>
<ul>
<li>判断是不是有限的数字</li>
<li><font color="red">没有进行类型转化</font></li>
</ul>
<h3 id="176-numberisintegerval">17.6 Number.isInteger(val)</h3>
<ul>
<li>判断val是否是整数</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFloat</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>.inFinite(x) &amp;&amp; !<span class="hljs-built_in">Number</span>.isInteger(x)
  }
</div></code></pre>
<h3 id="177-numberissafeintegerval">17.7 Number.isSafeInteger(val)</h3>
<ul>
<li>判断整数是否在安全范围内</li>
</ul>
<h2 id="18-string%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95">18. String的扩展方法</h2>
<h3 id="181-%E9%92%88%E5%AF%B9unicode%E7%9A%84%E5%87%BD%E6%95%B0%E4%B9%8B%E5%90%8E%E8%A1%A5%E5%85%85">18.1 针对Unicode的函数（之后补充）</h3>
<h4 id="1811-stringfromcodepoint">18.1.1 String.fromCodePoint()</h4>
<h4 id="1812-stringcodepointat">18.1.2 String#codePointAt()</h4>
<h4 id="1813-stringnomalize">18.1.3 String.nomalize()</h4>
<h3 id="182-stringraw">18.2 String.raw()</h3>
<ul>
<li>与模板字符串字面量一起使用</li>
</ul>
<h3 id="183-stringrepeatn">18.3 String#repeat(n)</h3>
<ul>
<li>返回重复了n次的字符</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"foo"</span>.repeat(<span class="hljs-number">3</span>));
  <span class="hljs-comment">// foofoofoo</span>
</div></code></pre>
<h3 id="184-%E6%96%B0%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95">18.4 新的索引方法</h3>
<h5 id="1841-stringstartswithstr-index">18.4.1 String#startsWith(str[, index])</h5>
<ul>
<li>查看第index位是否是以str为开始，index默认值为0</li>
</ul>
<h5 id="1842-stringendswithstr-index">18.4.2 String#endsWith(str[, index])</h5>
<ul>
<li>查看第index位是否是以str为结束，index默认值为0</li>
</ul>
<h5 id="1843-stringincludesstr-index">18.4.3 String#includes(str[, index])</h5>
<ul>
<li>查看第index位开始是否包含str，index默认值为0</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">var</span> palindrome = <span class="hljs-string">"step on no pets"</span>;
  palindrome.startsWith( <span class="hljs-string">"step on"</span> ); <span class="hljs-comment">// true</span>
  palindrome.startsWith( <span class="hljs-string">"on"</span>, <span class="hljs-number">5</span> ); <span class="hljs-comment">// true</span>

  palindrome.endsWith( <span class="hljs-string">"no pets"</span> ); <span class="hljs-comment">// true</span>
  palindrome.endsWith( <span class="hljs-string">"no"</span>, <span class="hljs-number">10</span> ); <span class="hljs-comment">// true</span>

  palindrome.includes( <span class="hljs-string">"on"</span> ); <span class="hljs-comment">// true</span>
  palindrome.includes( <span class="hljs-string">"on"</span>, <span class="hljs-number">6</span> ); <span class="hljs-comment">// false</span>
</div></code></pre>
<pre class="hljs"><code><div>{
  
  <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>, <span class="hljs-comment">// default</span>


  <span class="hljs-comment">// `transformRequest` allows changes to the request data before it is sent to the server</span>
  <span class="hljs-comment">// This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'</span>
  <span class="hljs-comment">// The last function in the array must return a string or an instance of Buffer, ArrayBuffer,</span>
  <span class="hljs-comment">// FormData or Stream</span>
  <span class="hljs-comment">// You may modify the headers object.</span>
  <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, headers</span>) </span>{
    <span class="hljs-comment">// Do whatever you want to transform the data</span>

    <span class="hljs-keyword">return</span> data;
  }],

  <span class="hljs-comment">// `transformResponse` allows changes to the response data to be made before</span>
  <span class="hljs-comment">// it is passed to then/catch</span>
  <span class="hljs-attr">transformResponse</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-comment">// Do whatever you want to transform the data</span>

    <span class="hljs-keyword">return</span> data;
  }],

  <span class="hljs-comment">// `headers` are custom headers to be sent</span>
  <span class="hljs-attr">headers</span>: {<span class="hljs-string">'X-Requested-With'</span>: <span class="hljs-string">'XMLHttpRequest'</span>},

  <span class="hljs-comment">// `params` are the URL parameters to be sent with the request</span>
  <span class="hljs-comment">// Must be a plain object or a URLSearchParams object</span>
  <span class="hljs-attr">params</span>: {
    <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>
  },

  <span class="hljs-comment">// `paramsSerializer` is an optional function in charge of serializing `params`</span>
  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>
  <span class="hljs-attr">paramsSerializer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>{
    <span class="hljs-keyword">return</span> Qs.stringify(params, {<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'brackets'</span>})
  },

  <span class="hljs-comment">// `data` is the data to be sent as the request body</span>
  <span class="hljs-comment">// Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH'</span>
  <span class="hljs-comment">// When no `transformRequest` is set, must be of one of the following types:</span>
  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>
  <span class="hljs-comment">// - Browser only: FormData, File, Blob</span>
  <span class="hljs-comment">// - Node only: Stream, Buffer</span>
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Fred'</span>
  },
  
  <span class="hljs-comment">// syntax alternative to send data into the body</span>
  <span class="hljs-comment">// method post</span>
  <span class="hljs-comment">// only the value is sent, not the key</span>
  <span class="hljs-attr">data</span>: <span class="hljs-string">'Country=Brasil&amp;City=Belo Horizonte'</span>,

  <span class="hljs-comment">// `timeout` specifies the number of milliseconds before the request times out.</span>
  <span class="hljs-comment">// If the request takes longer than `timeout`, the request will be aborted.</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>, <span class="hljs-comment">// default is `0` (no timeout)</span>

  <span class="hljs-comment">// `withCredentials` indicates whether or not cross-site Access-Control requests</span>
  <span class="hljs-comment">// should be made using credentials</span>
  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `adapter` allows custom handling of requests which makes testing easier.</span>
  <span class="hljs-comment">// Return a promise and supply a valid response (see lib/adapters/README.md).</span>
  <span class="hljs-attr">adapter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
    <span class="hljs-comment">/* ... */</span>
  },

  <span class="hljs-comment">// `auth` indicates that HTTP Basic auth should be used, and supplies credentials.</span>
  <span class="hljs-comment">// This will set an `Authorization` header, overwriting any existing</span>
  <span class="hljs-comment">// `Authorization` custom headers you have set using `headers`.</span>
  <span class="hljs-comment">// Please note that only HTTP Basic auth is configurable through this parameter.</span>
  <span class="hljs-comment">// For Bearer tokens and such, use `Authorization` custom headers instead.</span>
  <span class="hljs-attr">auth</span>: {
    <span class="hljs-attr">username</span>: <span class="hljs-string">'janedoe'</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-string">'s00pers3cret'</span>
  },

  <span class="hljs-comment">// `responseType` indicates the type of data that the server will respond with</span>
  <span class="hljs-comment">// options are: 'arraybuffer', 'document', 'json', 'text', 'stream'</span>
  <span class="hljs-comment">//   browser only: 'blob'</span>
  <span class="hljs-attr">responseType</span>: <span class="hljs-string">'json'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `responseEncoding` indicates encoding to use for decoding responses (Node.js only)</span>
  <span class="hljs-comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span>
  <span class="hljs-attr">responseEncoding</span>: <span class="hljs-string">'utf8'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `xsrfCookieName` is the name of the cookie to use as a value for xsrf token</span>
  <span class="hljs-attr">xsrfCookieName</span>: <span class="hljs-string">'XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>
  <span class="hljs-attr">xsrfHeaderName</span>: <span class="hljs-string">'X-XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `onUploadProgress` allows handling of progress events for uploads</span>
  <span class="hljs-comment">// browser only</span>
  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>{
    <span class="hljs-comment">// Do whatever you want with the native progress event</span>
  },

  <span class="hljs-comment">// `onDownloadProgress` allows handling of progress events for downloads</span>
  <span class="hljs-comment">// browser only</span>
  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>{
    <span class="hljs-comment">// Do whatever you want with the native progress event</span>
  },

  <span class="hljs-comment">// `maxContentLength` defines the max size of the http response content in bytes allowed in node.js</span>
  <span class="hljs-attr">maxContentLength</span>: <span class="hljs-number">2000</span>,

  <span class="hljs-comment">// `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed</span>
  <span class="hljs-attr">maxBodyLength</span>: <span class="hljs-number">2000</span>,

  <span class="hljs-comment">// `validateStatus` defines whether to resolve or reject the promise for a given</span>
  <span class="hljs-comment">// HTTP response status code. If `validateStatus` returns `true` (or is set to `null`</span>
  <span class="hljs-comment">// or `undefined`), the promise will be resolved; otherwise, the promise will be</span>
  <span class="hljs-comment">// rejected.</span>
  <span class="hljs-attr">validateStatus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>{
    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// default</span>
  },

  <span class="hljs-comment">// `maxRedirects` defines the maximum number of redirects to follow in node.js.</span>
  <span class="hljs-comment">// If set to 0, no redirects will be followed.</span>
  <span class="hljs-attr">maxRedirects</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span>
  <span class="hljs-comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>
  <span class="hljs-comment">// Only either `socketPath` or `proxy` can be specified.</span>
  <span class="hljs-comment">// If both are specified, `socketPath` is used.</span>
  <span class="hljs-attr">socketPath</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span>
  <span class="hljs-comment">// and https requests, respectively, in node.js. This allows options to be added like</span>
  <span class="hljs-comment">// `keepAlive` that are not enabled by default.</span>
  <span class="hljs-attr">httpAgent</span>: <span class="hljs-keyword">new</span> http.Agent({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> }),
  <span class="hljs-attr">httpsAgent</span>: <span class="hljs-keyword">new</span> https.Agent({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> }),

  <span class="hljs-comment">// `proxy` defines the hostname and port of the proxy server.</span>
  <span class="hljs-comment">// You can also define your proxy using the conventional `http_proxy` and</span>
  <span class="hljs-comment">// `https_proxy` environment variables. If you are using environment variables</span>
  <span class="hljs-comment">// for your proxy configuration, you can also define a `no_proxy` environment</span>
  <span class="hljs-comment">// variable as a comma-separated list of domains that should not be proxied.</span>
  <span class="hljs-comment">// Use `false` to disable proxies, ignoring environment variables.</span>
  <span class="hljs-comment">// `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and</span>
  <span class="hljs-comment">// supplies credentials.</span>
  <span class="hljs-comment">// This will set an `Proxy-Authorization` header, overwriting any existing</span>
  <span class="hljs-comment">// `Proxy-Authorization` custom headers you have set using `headers`.</span>
  <span class="hljs-attr">proxy</span>: {
    <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,
    <span class="hljs-attr">auth</span>: {
      <span class="hljs-attr">username</span>: <span class="hljs-string">'mikeymike'</span>,
      <span class="hljs-attr">password</span>: <span class="hljs-string">'rapunz3l'</span>
    }
  },

  <span class="hljs-comment">// `cancelToken` specifies a cancel token that can be used to cancel the request</span>
  <span class="hljs-comment">// (see Cancellation section below for details)</span>
  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) </span>{
  }),

  <span class="hljs-comment">// `decompress` indicates whether or not the response body should be decompressed </span>
  <span class="hljs-comment">// automatically. If set to `true` will also remove the 'content-encoding' header </span>
  <span class="hljs-comment">// from the responses objects of all decompressed responses</span>
  <span class="hljs-comment">// - Node only (XHR cannot turn off decompression)</span>
  <span class="hljs-attr">decompress</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// default</span>

}
</div></code></pre>
<p>config</p>
<table>
  <thead>
    <tr>
      <th>设置的名称</th>
      <th>设置的作用</th>
      <th>设置的取值</th>
      <th>设置的要求</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>baseURL</td>
      <td>基础Url</td>
      <td>string: 基础网址</td>
      <td>无</td>
    </tr>
    <tr>
      <td>url</td>
      <td>网址</td>
      <td>string: 网址</td>
      <td>无</td>
    </tr>
    <tr>
      <td>method</td>
      <td>请求方法</td>
      <td>string: 网址</td>
      <td>
      get<br/>
      post<br/>
      delete<br/>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
